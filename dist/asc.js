/**
 * @license
 * The AssemblyScript Compiler Frontend.
 * Copyright Daniel Wirtz / The AssemblyScript Authors.
 * SPDX-License-Identifier: Apache-2.0
 */
!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("binaryen")):"function"==typeof define&&define.amd?define(["binaryen"],n):"object"==typeof exports?exports.asc=n(require("binaryen")):e.asc=n(e.binaryen)}("undefined"!=typeof self?self:this,(function(e){return(()=>{var n={469:(e,n,t)=>{const r=t(551),i=t(484),a=t(286);var s;a.exit=(s=a.exit,function(e){e&&console.log(new Error("exit "+e.toString()).stack),s(e)});const o=t(198),l=t(820),u=t(565),c=t(342),p=t(790),f=t.g.binaryen||(t.g.binaryen=t(911)),d="win32"===a.platform,h=d?"\r\n":"\n",g=d?"\\":"/";function x(e){return e.startsWith(".")||(e="."+e),{ext:e,ext_d:".d"+e,re:new RegExp("\\"+e+"$"),re_d:new RegExp("\\.d\\"+e+"$"),re_except_d:new RegExp("^(?!.*\\.d\\"+e+"$).*\\"+e+"$"),re_index:new RegExp("(?:^|[\\\\\\/])index\\"+e+"$")}}const m=x(".ts");function _(e,n){return"number"==typeof e?0===e?null:n.wrap(e):e}var y,E,T,b,v,A;Object.defineProperty(n,"ready",{get:()=>f.ready}),a.removeAllListeners&&a.removeAllListeners("uncaughtException"),function(){const e=a.argv.findIndex((e=>"--wasm"==e));if(~e){let n=a.argv[e+1];a.argv.splice(e,2),y=function(e){const n=t(388),i=new(t(259).Rtrace)({onerror(e,n){console.log(e,n)},getMemory:()=>a.memory,oncollect(){var e=i.gcProfile;if(e&&e.length&&r.writeFileSync){let n=Date.now();r.writeFileSync(`rtrace-gc-profile-${n}.json`,JSON.stringify(e)),r.writeFileSync(`rtrace-gc-profile-${n}.csv`,`time,memory,pause\n${e.join("\n")}`)}}});var{exports:a}=n.instantiateSync(r.readFileSync(e),i.install({binaryen:f}));return a._start&&a._start(),a}(n),E=y.__newString,T=y.__getString,b=y.__pin,v=y.__unpin,A=y.__collect}else y=t(370),E=e=>e,T=e=>e,b=e=>e,v=e=>{},A=e=>{}}(),n.assemblyscript=y,n.isBundle=!0,n.version="0.0.0",n.options=t(422),n.libraryPrefix=T(y.LIBRARY_PREFIX.valueOf()),n.defaultOptimizeLevel=3,n.defaultShrinkLevel=1,n.libraryFiles=n.isBundle?{array:'/// <reference path="./rt/index.d.ts" />\n\nimport { BLOCK_MAXSIZE } from "./rt/common";\nimport { COMPARATOR, SORT } from "./util/sort";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from "./util/string";\nimport { idof, isArray as builtin_isArray } from "./builtins";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_ILLEGALGENTYPE, E_EMPTYARRAY, E_HOLEYARRAY } from "./util/error";\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureSize(array: usize, minSize: usize, alignLog2: u32): void {\n  // depends on the fact that Arrays mimic ArrayBufferView\n  var oldCapacity = changetype<ArrayBufferView>(array).byteLength;\n  if (minSize > <usize>oldCapacity >>> alignLog2) {\n    if (minSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    let newCapacity = minSize << alignLog2;\n    let newData = __renew(oldData, newCapacity);\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    if (newData !== oldData) { // oldData has been free\'d\n      store<usize>(array, newData, offsetof<ArrayBufferView>("buffer"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>("dataStart"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, newCapacity, offsetof<ArrayBufferView>("byteLength"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn\'t strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it\'s fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  private dataStart: usize;\n  private byteLength: i32;\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn\'t be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is "holey".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? builtin_isArray(value) && value !== null : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING("\'Array.create\' is deprecated. Use \'new Array\' instead, making sure initial elements are initialized.");\n    var array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var bufferSize = <usize>length << alignof<T>();\n    var buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator("[]") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator("{}") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator("[]=") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureSize(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator("{}=") private __uset(index: i32, value: T): void {\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    var len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    start = start < 0 ? max(length + start, 0) : min(start, length);\n    end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(dataStart + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          dataStart + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(dataStart + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length_;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      let dataStart = this.dataStart;\n      while (fromIndex < length) {\n        let elem = load<T>(dataStart + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var dataStart = this.dataStart;\n    while (fromIndex < length) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var dataStart = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var length = this.length_;\n    var newLength = length + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>length << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>length << alignof<T>()), value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, other.length_, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var len = this.length_;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      dataStart + (<usize>to << alignof<T>()),\n      dataStart + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var element = load<T>(this.dataStart + (<usize>(--length) << alignof<T>()));\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var out = changetype<Array<U>>(__newArray(length, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      let result = fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n      store<U>(outStart + (<usize>index << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n      if (fn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = length - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var newLength = this.length_ + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    var dataStart = this.dataStart;\n    memory.copy(\n      dataStart + sizeof<T>(),\n      dataStart,\n      <usize>(newLength - 1) << alignof<T>()\n    );\n    store<T>(dataStart, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var result = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>())); \n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    var length = this.length_;\n    if (length) {\n      let front = this.dataStart;\n      let back = this.dataStart + (<usize>(length - 1) << alignof<T>());\n      while (front < back) {\n        let temp = load<T>(front);\n        store<T>(front, load<T>(back));\n        store<T>(back, temp);\n        front += sizeof<T>();\n        back -= sizeof<T>();\n      }\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    var length = this.length_;\n    if (length <= 1) return this;\n    var base = this.dataStart;\n    if (length == 2) {\n      let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n      let b: T = load<T>(base); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        store<T>(base, b, sizeof<T>()); // arr[1] = b;\n        store<T>(base, a); // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(base, length, comparator);\n    return this;\n  }\n\n  join(separator: string = ","): string {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(dataStart, length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(dataStart, length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(dataStart, length, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(dataStart, length, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(dataStart, length, separator);\n    ERROR("unspported element type");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      throw new TypeError(E_ILLEGALGENTYPE);\n    }\n    // Get the length and data start values\n    var length = this.length_;\n    var selfDataStart = this.dataStart;\n\n    // calculate the end size with an initial pass\n    var size = 0;\n    for (let i = 0; i < length; i++) {\n      let child = load<usize>(selfDataStart + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>("length_"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    var byteLength = <usize>size << usize(alignof<valueof<T>>());\n    var outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    var outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>("length_"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>("byteLength"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>("dataStart"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>("buffer"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    var resultOffset: usize = 0;\n    for (let i = 0; i < length; i++) { // for each child\n      let child = load<usize>(selfDataStart + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (child == 0) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = load<i32>(child, offsetof<T>("byteLength"));\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>("dataStart")),\n        <usize>childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; i++) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n',arraybuffer:'/// <reference path="./rt/index.d.ts" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from "./rt/common";\nimport { idof } from "./builtins";\nimport { E_INVALIDLENGTH } from "./util/error";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (value === null) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return "[object ArrayBuffer]";\n  }\n}\n',atomics:'import { ArrayBufferView } from "./arraybuffer";\nimport { E_INDEXOUTOFRANGE } from "./util/error";\n\nexport namespace Atomics {\n\n  // @ts-ignore: decorator\n  @inline\n  export function load<T extends ArrayBufferView>(array: T, index: i32): valueof<T> {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return atomic.load<valueof<T>>(\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset\n    );\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function store<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): void {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    atomic.store<valueof<T>>(\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\n      value\n    );\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function add<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return atomic.add<valueof<T>>(\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\n      value\n    );\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sub<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return atomic.sub<valueof<T>>(\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\n      value\n    );\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function and<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return atomic.and<valueof<T>>(\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\n      value\n    );\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function or<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return atomic.or<valueof<T>>(\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\n      value\n    );\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function xor<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return atomic.xor<valueof<T>>(\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\n      value\n    );\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function exchange<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return atomic.xchg<valueof<T>>(\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\n      value\n    );\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function compareExchange<T extends ArrayBufferView>(\n    array: T,\n    index: i32,\n    expectedValue: valueof<T>,\n    replacementValue: valueof<T>\n  ): valueof<T> {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return atomic.cmpxchg<valueof<T>>(\n      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,\n      expectedValue,\n      replacementValue\n    );\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function wait<T extends ArrayBufferView>(array: T, value: valueof<T>, timeout: i64 = -1): AtomicWaitResult {\n    return atomic.wait<valueof<T>>(changetype<usize>(array.buffer) + array.byteOffset, value, timeout);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function notify<T extends ArrayBufferView>(array: T, index: i32, count: i32 = -1): i32 {\n    const align = alignof<valueof<T>>();\n    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return atomic.notify(changetype<usize>(array.buffer) + (index << align) + array.byteOffset, count);\n  }\n\n  export function isLockFree(size: usize): bool {\n    return size == 1 || size == 2 || size == 4;\n  }\n}\n',"bindings/asyncify":"@unmanaged\nexport class StackDescriptor {\n  /** The index in linear memory of the start of the “asyncify stack”. */\n  stackStart: usize;\n  /** The index of the end of that stack region, which implies how big it is. */\n  stackEnd: usize;\n}\n\n/** Starts to unwind the call stack. */\nexport declare function start_unwind(data: StackDescriptor): void;\n/** Stops unwinding the call stack. */\nexport declare function stop_unwind(): void;\n/** Starts to rewind the call stack. */\nexport declare function start_rewind(data: StackDescriptor): void;\n/** Stops rewinding the call stack. */\nexport declare function stop_rewind(): void;\n","bindings/console":"export declare function assert(value: externref): void;\nexport declare function clear(): void;\nexport declare function error(value: externref): void;\nexport declare function info(value: externref): void;\nexport declare function log(value: externref): void;\nexport declare function time(label: externref): externref;\nexport declare function timeEnd(label: externref): void;\nexport declare function timeLog(label: externref): void;\nexport declare function trace(): void;\nexport declare function warn(value: externref): void;\n","bindings/Date":"export declare function UTC(\n  // NOTE: Using i32 below saves us a f64.convert_s instruction and moves the responsibility for\n  // converting the value to the WASM/JS boundary.\n  year: i32,\n  month: i32,\n  day: i32,\n  hour: i32,\n  minute: i32,\n  second: i32,\n  millisecond: f64\n): f64;\nexport declare function now(): f64;\n","bindings/Math":"export declare const E: f64;\nexport declare const LN2: f64;\nexport declare const LN10: f64;\nexport declare const LOG2E: f64;\nexport declare const LOG10E: f64;\nexport declare const PI: f64;\nexport declare const SQRT1_2: f64;\nexport declare const SQRT2: f64;\n\nexport declare function abs(x: f64): f64;\nexport declare function acos(x: f64): f64;\nexport declare function acosh(x: f64): f64;\nexport declare function asin(x: f64): f64;\nexport declare function asinh(x: f64): f64;\nexport declare function atan(x: f64): f64;\nexport declare function atan2(y: f64, x: f64): f64;\nexport declare function atanh(x: f64): f64;\nexport declare function cbrt(x: f64): f64;\nexport declare function ceil(x: f64): f64;\nexport declare function clz32(x: f64): f64;\nexport declare function cos(x: f64): f64;\nexport declare function cosh(x: f64): f64;\nexport declare function exp(x: f64): f64;\nexport declare function expm1(x: f64): f64;\nexport declare function floor(x: f64): f64;\nexport declare function fround(x: f64): f32;\nexport declare function hypot(value1: f64, value2: f64): f64; // TODO: rest\nexport declare function imul(a: f64, b: f64): f64;\nexport declare function log(x: f64): f64;\nexport declare function log10(x: f64): f64;\nexport declare function log1p(x: f64): f64;\nexport declare function log2(x: f64): f64;\nexport declare function max(value1: f64, value2: f64): f64; // TODO: rest\nexport declare function min(value1: f64, value2: f64): f64; // TODO: rest\nexport declare function pow(base: f64, exponent: f64): f64;\nexport declare function random(): f64;\nexport declare function round(x: f64): f64;\nexport declare function sign(x: f64): f64;\nexport declare function sin(x: f64): f64;\nexport declare function sinh(x: f64): f64;\nexport declare function sqrt(x: f64): f64;\nexport declare function tan(x: f64): f64;\nexport declare function tanh(x: f64): f64;\nexport declare function trunc(x: f64): f64;\n","bindings/Reflect":"export declare function get(target: externref, propertyKey: externref/* , receiver: externref */): externref;\nexport declare function has(target: externref, propertyKey: externref): bool;\nexport declare function set(target: externref, propertyKey: externref, value: externref/* , receiver: externref */): externref;\nexport declare function apply(target: externref, thisArgument: externref, argumentsList: externref): externref;\n","bindings/wasi_snapshot_preview1":'// Phase: wasi_snapshot_preview1\n// See: https://github.com/WebAssembly/WASI/tree/master/phases/snapshot/witx\n\n// helper types to be more explicit\ntype char = u8;\ntype ptr<T> = usize; // all pointers are usize\'d\ntype struct<T> = T;  // structs are references already in AS\n\n/** Read command-line argument data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_get(\n  /** Input: Pointer to a buffer to write the argument pointers. */\n  argv: ptr<ptr<char>>,\n  /** Input: Pointer to a buffer to write the argument string data. */\n  argv_buf: ptr<char>\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_sizes_get(\n  /** Output: Number of arguments. */\n  argc: ptr<usize>,\n  /** Output: Size of the argument string data. */\n  argv_buf_size: ptr<usize>\n): errno;\n\n/** Return the resolution of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_res_get(\n  /** Input: The clock for which to return the resolution. */\n  clock: clockid,\n  /** Output: The resolution of the clock. */\n  resolution: ptr<timestamp>\n): errno;\n\n/** Return the time value of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_time_get(\n  /** Input: Cock for which to return the time. */\n  clock: clockid,\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\n  precision: timestamp,\n  /** Output: Time value of the clock. */\n  time: ptr<timestamp>\n): errno;\n\n/** Read environment variable data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_get(\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\n  environ: ptr<usize>,\n  /** Input: Pointer to a buffer to write the environment variable string data. */\n  environ_buf: usize\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_sizes_get(\n  /** Output: The number of environment variables. */\n  environ_count: ptr<usize>,\n  /** Output: The size of the environment variable string data. */\n  environ_buf_size: ptr<usize>\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_advise(\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\n  fd: fd,\n  /** Input: The offset within the file to which the advisory applies. */\n  offset: filesize,\n  /** Input: The length of the region to which the advisory applies. */\n  len: filesize,\n  /** Input: The advice. */\n  advice: advice\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_allocate(\n  /** Input: The file descriptor for the file in which to allocate space. */\n  fd: fd,\n  /** Input: The offset at which to start the allocation. */\n  offset: filesize,\n  /** Input: The length of the area that is allocated. */\n  len: filesize\n): errno;\n\n/** Close a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_close(\n  /** Input: The file descriptor to close. */\n  fd: fd\n): errno;\n\n/** Synchronize the data of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_datasync(\n  /** Input: The file descriptor of the file to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Get the attributes of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file descriptor\'s attributes are stored. */\n  buf: struct<fdstat>\n): errno;\n\n/** Adjust the flags associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_flags(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the file descriptor flags. */\n  flags: fdflags\n): errno;\n\n/** Adjust the rights associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_rights(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_base: rights,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_inheriting: rights\n): errno;\n\n/** Return the attributes of an open file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file\'s attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the size of an open file. If this increases the file\'s size, the extra bytes are filled with zeros. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_size(\n  /** Input: A file descriptor for the file to adjust. */\n  fd: fd,\n  /** Input: The desired file size. */\n  size: filesize\n): errno;\n\n/** Adjust the timestamps of an open file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_times(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Read from a file descriptor, without using and updating the file descriptor\'s offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pread(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors in which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to read. */\n  offset: filesize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_get(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: The buffer where the description is stored. */\n  buf: struct<prestat>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_dir_name(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: Buffer into which to write the preopened directory name. */\n  path: ptr<char>,\n  /** Input: Length of the buffer into which to write the preopened directory name. */\n  path_len: usize\n): errno;\n\n/** Write to a file descriptor, without using and updating the file descriptor\'s offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pwrite(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to write. */\n  offset: filesize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/** Read from a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_read(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\n  iovs_len: usize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Read directory entries from a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_readdir(\n  /** Input: Directory from which to read the directory entries. */\n  fd: fd,\n  /** Input: Buffer where directory entries are stored. */\n  buf: ptr<struct<dirent>>,\n  /** Input: Length of the buffer where directory entries are stored. */\n  buf_len: usize,\n  /** Input: Location within the directory to start reading. */\n  cookie: dircookie,\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_renumber(\n  /** Input: The file descriptor to renumber. */\n  from: fd,\n  /** Input: The file descriptor to overwrite. */\n  to: fd\n): errno;\n\n/** Move the offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_seek(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The number of bytes to move. */\n  offset: filedelta,\n  /** Input: The base from which the offset is relative. */\n  whence: whence,\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Synchronize the data and metadata of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_sync(\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Return the current offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_tell(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Write to a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_write(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/* Create a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_create_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path at which to create the directory. */\n  path: ptr<char>,\n  /** Input: The path at which to create the directory. */\n  path_len: usize\n): errno;\n\n/** Return the attributes of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_get(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to inspect. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to inspect. */\n  path_len: usize,\n  /** Input: The buffer where the file\'s attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the timestamps of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_set_times(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to operate on. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to operate on. */\n  path_len: usize,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Create a hard link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_link(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  old_flags: lookupflags,\n  /** Input: The source path from which to link. */\n  old_path: ptr<char>,\n  /** Input: The source path from which to link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path at which to create the hard link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the hard link. */\n  new_path_len: usize\n): errno;\n\n/** Open a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_open(\n  /** Input: The working directory at which the resolution of the path starts. */\n  dirfd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  dirflags: lookupflags,\n  /** Input: The path of the file or directory to open. */\n  path: ptr<char>,\n  /** Input: The length of the path of the file or directory to open. */\n  path_len: usize,\n  /** Input: The method by which to open the file. */\n  oflags: oflags,\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\n  fs_rights_base: rights,\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\n  fs_rights_inheriting: rights,\n  /** Input: The initial flags of the file descriptor. */\n  fs_flags: fdflags,\n  /** Output: The file descriptor of the file that has been opened. */\n  fd: ptr<fd>\n): errno;\n\n/** Read the contents of a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_readlink(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path of the symbolic link from which to read. */\n  path: ptr<char>,\n  /** Input: The length of the path of the symbolic link from which to read. */\n  path_len: usize,\n  /** Input: The buffer to which to write the contents of the symbolic link. */\n  buf: ptr<char>,\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\n  buf_len: usize,\n  /** Output: The number of bytes placed in the buffer. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Remove a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_remove_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a directory to remove. */\n  path: ptr<char>,\n  /** Input: The length of the path to a directory to remove. */\n  path_len: usize\n): errno;\n\n/** Rename a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_rename(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: The source path of the file or directory to rename. */\n  old_path: ptr<char>,\n  /** Input: The length of the source path of the file or directory to rename. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path to which to rename the file or directory. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path to which to rename the file or directory. */\n  new_path_len: usize\n): errno;\n\n/** Create a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_symlink(\n  /** Input: The contents of the symbolic link. */\n  old_path: ptr<char>,\n  /** Input: The length of the contents of the symbolic link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The destination path at which to create the symbolic link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the symbolic link. */\n  new_path_len: usize\n): errno;\n\n/** Unlink a file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_unlink_file(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a file to unlink. */\n  path: ptr<char>,\n  /** Input: The length of the path to a file to unlink. */\n  path_len: usize\n): errno;\n\n/** Concurrently poll for the occurrence of a set of events. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function poll_oneoff(\n  /** Input: The events to which to subscribe. */\n  in_: ptr<struct<subscription>>,\n  /** Input: The events that have occurred. */\n  out: ptr<struct<event>>,\n  /** Input: Both the number of subscriptions and events. */\n  nsubscriptions: usize,\n  /** Output: The number of events stored. */\n  nevents: ptr<usize>\n): errno;\n\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_exit(\n  /** Input: The exit code returned by the process. */\n  rval: u32\n): void;\n\n/** Send a signal to the process of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_raise(\n  /** Input: The signal condition to trigger. */\n  sig: signal\n): errno;\n\n/** Write high-quality random data into a buffer. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function random_get(\n  /** Input: The buffer to fill with random data. */\n  buf: usize,\n  /** Input: The length of the buffer to fill with random data. */\n  buf_len: usize\n): errno;\n\n/** Temporarily yield execution of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sched_yield(): errno;\n\n/** Receive a message from a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_recv(\n  /** Input: The socket on which to receive data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  ri_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\n  ri_data_len: usize,\n  /** Input: Message flags. */\n  ri_flags: riflags,\n  /** Output: Number of bytes stored in `ri_data`. */\n  ro_datalen: ptr<usize>,\n  /** Output: Message flags. */\n  ro_flags: ptr<roflags>\n): errno;\n\n/** Send a message on a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_send(\n  /** Input: The socket on which to send data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to retrieve data */\n  si_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\n  si_data_len: usize,\n  /** Input: Message flags. */\n  si_flags: siflags,\n  /** Output: Number of bytes transmitted. */\n  so_datalen: ptr<usize>\n): errno;\n\n/** Shut down socket send and receive channels. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_shutdown(\n  /** Input: The socket on which to shutdown channels. */\n  sock: fd,\n  /** Input: Which channels on the socket to shut down. */\n  how: sdflags\n): errno;\n\n// === Types ======================================================================================\n\n/** File or memory access pattern advisory information. */\nexport namespace advice {\n  /** The application has no advice to give on its behavior with respect to the specified data. */\n  // @ts-ignore: decorator\n  @inline\n  export const NORMAL: advice = 0;\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEQUENTIAL : advice = 1;\n  /** The application expects to access the specified data in a random order. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANDOM: advice = 2;\n  /** The application expects to access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const WILLNEED: advice = 3;\n  /** The application expects that it will not access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const DONTNEED: advice = 4;\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOREUSE: advice = 5;\n}\nexport type advice = u8;\n\n/** Identifiers for clocks. */\nexport namespace clockid {\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\n  // @ts-ignore: decorator\n  @inline\n  export const REALTIME: clockid = 0;\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\n  // @ts-ignore: decorator\n  @inline\n  export const MONOTONIC: clockid = 1;\n  /** The CPU-time clock associated with the current process. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROCESS_CPUTIME_ID: clockid = 2;\n  /** The CPU-time clock associated with the current thread. */\n  // @ts-ignore: decorator\n  @inline\n  export const THREAD_CPUTIME_ID: clockid = 3;\n}\nexport type clockid = u32;\n\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\nexport type device = u64;\n\n/** A reference to the offset of a directory entry. The value 0 signifies the start of the directory. */\nexport type dircookie = u64;\n\n/** A directory entry. */\n@unmanaged export class dirent {\n  /** The offset of the next directory entry stored in this directory. */\n  next: dircookie;\n  /** The serial number of the file referred to by this directory entry. */\n  ino: inode;\n  /** The length of the name of the directory entry. */\n  namlen: u32;\n  /** The type of the file referred to by this directory entry. */\n  type: filetype;\n  private __padding0: u16;\n}\n\n/** Error codes returned by functions. */\nexport namespace errno {\n  /** No error occurred. System call completed successfully. */\n  // @ts-ignore: decorator\n  @inline\n  export const SUCCESS: errno = 0;\n  /** Argument list too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const TOOBIG: errno = 1;\n  /** Permission denied. */\n  // @ts-ignore: decorator\n  @inline\n  export const ACCES: errno = 2;\n  /** Address in use. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRINUSE: errno = 3;\n  /** Address not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRNOTAVAIL: errno = 4;\n  /** Address family not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const AFNOSUPPORT: errno = 5;\n  /** Resource unavailable, or operation would block. */\n  // @ts-ignore: decorator\n  @inline\n  export const AGAIN: errno = 6;\n  /** Connection already in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALREADY: errno = 7;\n  /** Bad file descriptor. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADF: errno = 8;\n  /** Bad message. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADMSG: errno = 9;\n  /** Device or resource busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUSY: errno = 10;\n  /** Operation canceled. */\n  // @ts-ignore: decorator\n  @inline\n  export const CANCELED: errno = 11;\n  /** No child processes. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHILD: errno = 12;\n  /** Connection aborted. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNABORTED: errno = 13;\n  /** Connection refused. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNREFUSED: errno = 14;\n  /** Connection reset. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNRESET: errno = 15;\n  /** Resource deadlock would occur. */\n  // @ts-ignore: decorator\n  @inline\n  export const DEADLK: errno = 16;\n  /** Destination address required. */\n  // @ts-ignore: decorator\n  @inline\n  export const DESTADDRREQ: errno = 17;\n  /** Mathematics argument out of domain of function. */\n  // @ts-ignore: decorator\n  @inline\n  export const DOM: errno = 18;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const DQUOT: errno = 19;\n  /** File exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXIST: errno = 20;\n  /** Bad address. */\n  // @ts-ignore: decorator\n  @inline\n  export const FAULT: errno = 21;\n  /** File too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const FBIG: errno = 22;\n  /** Host is unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const HOSTUNREACH: errno = 23;\n  /** Identifier removed. */\n  // @ts-ignore: decorator\n  @inline\n  export const IDRM: errno = 24;\n  /** Illegal byte sequence. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILSEQ: errno = 25;\n  /** Operation in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const INPROGRESS: errno = 26;\n  /** Interrupted function. */\n  // @ts-ignore: decorator\n  @inline\n  export const INTR: errno = 27;\n  /** Invalid argument. */\n  // @ts-ignore: decorator\n  @inline\n  export const INVAL: errno = 28;\n  /** I/O error. */\n  // @ts-ignore: decorator\n  @inline\n  export const IO: errno = 29;\n  /** Socket is connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISCONN: errno = 30;\n  /** Is a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISDIR: errno = 31;\n  /** Too many levels of symbolic links. */\n  // @ts-ignore: decorator\n  @inline\n  export const LOOP: errno = 32;\n  /** File descriptor value too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MFILE: errno = 33;\n  /** Too many links. */\n  // @ts-ignore: decorator\n  @inline\n  export const MLINK: errno = 34;\n  /** Message too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MSGSIZE: errno = 35;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const MULTIHOP: errno = 36;\n  /** Filename too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const NAMETOOLONG: errno = 37;\n  /** Network is down. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETDOWN: errno = 38;\n  /** Connection aborted by network. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETRESET: errno = 39;\n  /** Network unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETUNREACH: errno = 40;\n  /** Too many files open in system. */\n  // @ts-ignore: decorator\n  @inline\n  export const NFILE: errno = 41;\n  /** No buffer space available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOBUFS: errno = 42;\n  /** No such device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NODEV: errno = 43;\n  /** No such file or directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOENT: errno = 44;\n  /** Executable file format error. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOEXEC: errno = 45;\n  /** No locks available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLCK: errno = 46;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLINK: errno = 47;\n  /** Not enough space. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMEM: errno = 48;\n  /** No message of the desired type. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMSG: errno = 49;\n  /** Protocol not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOPROTOOPT: errno = 50;\n  /** No space left on device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSPC: errno = 51;\n  /** Function not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSYS: errno = 52;\n  /** The socket is not connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCONN: errno = 53;\n  /** Not a directory or a symbolic link to a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTDIR: errno = 54;\n  /** Directory not empty. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTEMPTY: errno = 55;\n  /** State not recoverable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTRECOVERABLE: errno = 56;\n  /** Not a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSOCK: errno = 57;\n  /** Not supported, or operation not supported on socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSUP: errno = 58;\n  /** Inappropriate I/O control operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTTY: errno = 59;\n  /** No such device or address. */\n  // @ts-ignore: decorator\n  @inline\n  export const NXIO: errno = 60;\n  /** Value too large to be stored in data type. */\n  // @ts-ignore: decorator\n  @inline\n  export const OVERFLOW: errno = 61;\n  /** Previous owner died. */\n  // @ts-ignore: decorator\n  @inline\n  export const OWNERDEAD: errno = 62;\n  /** Operation not permitted. */\n  // @ts-ignore: decorator\n  @inline\n  export const PERM: errno = 63;\n  /** Broken pipe. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: errno = 64;\n  /** Protocol error. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTO: errno = 65;\n  /** Protocol not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTONOSUPPORT: errno = 66;\n  /** Protocol wrong type for socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTOTYPE: errno = 67;\n  /** Result too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANGE: errno = 68;\n  /** Read-only file system. */\n  // @ts-ignore: decorator\n  @inline\n  export const ROFS: errno = 69;\n  /** Invalid seek. */\n  // @ts-ignore: decorator\n  @inline\n  export const SPIPE: errno = 70;\n  /** No such process. */\n  // @ts-ignore: decorator\n  @inline\n  export const SRCH: errno = 71;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const STALE: errno = 72;\n  /** Connection timed out. */\n  // @ts-ignore: decorator\n  @inline\n  export const TIMEDOUT: errno = 73;\n  /** Text file busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const TXTBSY: errno = 74;\n  /** Cross-device link. */\n  // @ts-ignore: decorator\n  @inline\n  export const XDEV: errno = 75;\n  /** Extension: Capabilities insufficient. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCAPABLE: errno = 76;\n}\nexport type errno = u16;\n\n/** Translates an error code to a string. */\nexport function errnoToString(err: errno): string {\n  switch (err) {\n    case errno.SUCCESS: return "SUCCESS";\n    case errno.TOOBIG: return "TOOBIG";\n    case errno.ACCES: return "ACCES";\n    case errno.ADDRINUSE: return "ADDRINUSE";\n    case errno.ADDRNOTAVAIL: return "ADDRNOTAVAIL";\n    case errno.AFNOSUPPORT: return "AFNOSUPPORT";\n    case errno.AGAIN: return "AGAIN";\n    case errno.ALREADY: return "ALREADY";\n    case errno.BADF: return "BADF";\n    case errno.BADMSG: return "BADMSG";\n    case errno.BUSY: return "BUSY";\n    case errno.CANCELED: return "CANCELED";\n    case errno.CHILD: return "CHILD";\n    case errno.CONNABORTED: return "CONNABORTED";\n    case errno.CONNREFUSED: return "CONNREFUSED";\n    case errno.CONNRESET: return "CONNRESET";\n    case errno.DEADLK: return "DEADLK";\n    case errno.DESTADDRREQ: return "DESTADDRREQ";\n    case errno.DOM: return "DOM";\n    case errno.DQUOT: return "DQUOT";\n    case errno.EXIST: return "EXIST";\n    case errno.FAULT: return "FAULT";\n    case errno.FBIG: return "FBIG";\n    case errno.HOSTUNREACH: return "HOSTUNREACH";\n    case errno.IDRM: return "IDRM";\n    case errno.ILSEQ: return "ILSEQ";\n    case errno.INPROGRESS: return "INPROGRESS";\n    case errno.INTR: return "INTR";\n    case errno.INVAL: return "INVAL";\n    case errno.IO: return "IO";\n    case errno.ISCONN: return "ISCONN";\n    case errno.ISDIR: return "ISDIR";\n    case errno.LOOP: return "LOOP";\n    case errno.MFILE: return "MFILE";\n    case errno.MLINK: return "MLINK";\n    case errno.MSGSIZE: return "MSGSIZE";\n    case errno.MULTIHOP: return "MULTIHOP";\n    case errno.NAMETOOLONG: return "NAMETOOLONG";\n    case errno.NETDOWN: return "NETDOWN";\n    case errno.NETRESET: return "NETRESET";\n    case errno.NETUNREACH: return "NETUNREACH";\n    case errno.NFILE: return "NFILE";\n    case errno.NOBUFS: return "NOBUFS";\n    case errno.NODEV: return "NODEV";\n    case errno.NOENT: return "NOENT";\n    case errno.NOEXEC: return "NOEXEC";\n    case errno.NOLCK: return "NOLCK";\n    case errno.NOLINK: return "NOLINK";\n    case errno.NOMEM: return "NOMEM";\n    case errno.NOMSG: return "NOMSG";\n    case errno.NOPROTOOPT: return "NOPROTOOPT";\n    case errno.NOSPC: return "NOSPC";\n    case errno.NOSYS: return "NOSYS";\n    case errno.NOTCONN: return "NOTCONN";\n    case errno.NOTDIR: return "NOTDIR";\n    case errno.NOTEMPTY: return "NOTEMPTY";\n    case errno.NOTRECOVERABLE: return "NOTRECOVERABLE";\n    case errno.NOTSOCK: return "NOTSOCK";\n    case errno.NOTSUP: return "NOTSUP";\n    case errno.NOTTY: return "NOTTY";\n    case errno.NXIO: return "NXIO";\n    case errno.OVERFLOW: return "OVERFLOW";\n    case errno.OWNERDEAD: return "OWNERDEAD";\n    case errno.PERM: return "PERM";\n    case errno.PIPE: return "PIPE";\n    case errno.PROTO: return "PROTO";\n    case errno.PROTONOSUPPORT: return "PROTONOSUPPORT";\n    case errno.PROTOTYPE: return "PROTOTYPE";\n    case errno.RANGE: return "RANGE";\n    case errno.ROFS: return "ROFS";\n    case errno.SPIPE: return "SPIPE";\n    case errno.SRCH: return "SRCH";\n    case errno.STALE: return "STALE";\n    case errno.TIMEDOUT: return "TIMEDOUT";\n    case errno.TXTBSY: return "TXTBSY";\n    case errno.XDEV: return "XDEV";\n    case errno.NOTCAPABLE: return "NOTCAPABLE";\n  }\n  return "UNKNOWN";\n}\n\n@unmanaged abstract class $event { // size=16/32\n  /** User-provided value that got attached to `subscription#userdata`. */\n  userdata: userdata;\n  /** If non-zero, an error that occurred while processing the subscription request. */\n  error: errno;\n  /** The type of the event that occurred. */\n  type: eventtype;\n\n  private __padding0: u16;\n}\n\n/** An event that occurred. */\n@unmanaged export abstract class event extends $event {\n  private __padding1: u64;\n  private __padding2: u64;\n}\n\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\n@unmanaged export class event_fd_readwrite extends $event {\n  /* The number of bytes available for reading or writing. */\n  nbytes: filesize;\n  /* The state of the file descriptor. */\n  flags: eventrwflags;\n\n  private __padding1: u32;\n}\n\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\nexport namespace eventrwflags {\n  /** The peer of this socket has closed or disconnected. */\n  // @ts-ignore: decorator\n  @inline\n  export const HANGUP: eventrwflags = 1;\n}\nexport type eventrwflags = u16;\n\n/** Type of a subscription to an event or its occurrence. */\nexport namespace eventtype {\n  /** The time value of clock has reached the timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const CLOCK: eventtype = 0;\n  /** File descriptor has data available for reading. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: eventtype = 1;\n  /** File descriptor has capacity available for writing */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: eventtype = 2;\n}\nexport type eventtype = u8;\n\n/** Exit code generated by a process when exiting. */\nexport type exitcode = u32;\n\n/** A file descriptor number. */\nexport type fd = u32;\n\n/** File descriptor flags. */\nexport namespace fdflags {\n  /** Append mode: Data written to the file is always appended to the file\'s end. */\n  // @ts-ignore: decorator\n  @inline\n  export const APPEND: fdflags = 1;\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\n  // @ts-ignore: decorator\n  @inline\n  export const DSYNC: fdflags = 2;\n  /** Non-blocking mode. */\n  // @ts-ignore: decorator\n  @inline\n  export const NONBLOCK: fdflags = 4;\n  /** Synchronized read I/O operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RSYNC: fdflags = 8;\n  /** Write according to synchronized I/O file integrity completion. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYNC: fdflags = 16;\n}\nexport type fdflags = u16;\n\n/** File descriptor attributes. */\n@unmanaged export class fdstat {\n  /** File type. */\n  filetype: filetype;\n  /** File descriptor flags. */\n  flags: fdflags;\n  /** Rights that apply to this file descriptor. */\n  rights_base: rights;\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\n  rights_inheriting: rights;\n}\n\n/** Relative offset within a file. */\nexport type filedelta = i64;\n\n/** Non-negative file size or length of a region within a file. */\nexport type filesize = u64;\n\n/** File attributes. */\n@unmanaged export class filestat {\n  /** Device ID of device containing the file. */\n  dev: device;\n  /** File serial number. */\n  ino: inode;\n  /** File type. */\n  filetype: filetype;\n  /** Number of hard links to the file. */\n  nlink: linkcount;\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\n  size: filesize;\n  /** Last data access timestamp. */\n  atim: timestamp;\n  /** Last data modification timestamp. */\n  mtim: timestamp;\n  /** Last file status change timestamp. */\n  ctim: timestamp;\n}\n\n/** The type of a file descriptor or file. */\nexport namespace filetype {\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\n  // @ts-ignore: decorator\n  @inline\n  export const UNKNOWN: filetype = 0;\n  /** The file descriptor or file refers to a block device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const BLOCK_DEVICE: filetype = 1;\n  /** The file descriptor or file refers to a character device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHARACTER_DEVICE: filetype = 2;\n  /** The file descriptor or file refers to a directory inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: filetype = 3;\n  /** The file descriptor or file refers to a regular file inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const REGULAR_FILE: filetype = 4;\n  /** The file descriptor or file refers to a datagram socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_DGRAM: filetype = 5;\n  /** The file descriptor or file refers to a byte-stream socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_STREAM: filetype = 6;\n  /** The file refers to a symbolic link inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMBOLIC_LINK: filetype = 7;\n}\nexport type filetype = u8;\n\n/** Which file time attributes to adjust. */\nexport namespace fstflags {\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM: fstflags = 1;\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM_NOW: fstflags = 2;\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM: fstflags = 4;\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM_NOW: fstflags = 8;\n}\nexport type fstflags = u16;\n\n/** File serial number that is unique within its file system. */\nexport type inode = u64;\n\n/** A region of memory for scatter/gather reads. */\n@unmanaged export class iovec {\n  /** The address of the buffer to be filled. */\n  buf: usize;\n  /** The length of the buffer to be filled. */\n  buf_len: usize;\n}\n\n/** Number of hard links to an inode. */\nexport type linkcount = u64;\n\n/** Flags determining the method of how paths are resolved. */\nexport namespace lookupflags {\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMLINK_FOLLOW: lookupflags = 1;\n}\nexport type lookupflags = u32;\n\n/** Open flags. */\nexport namespace oflags {\n  /** Create file if it does not exist. */\n  // @ts-ignore: decorator\n  @inline\n  export const CREAT: oflags = 1;\n  /** Fail if not a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: oflags = 2;\n  /** Fail if file already exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXCL: oflags = 4;\n  /** Truncate file to size 0. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRUNC: oflags = 8;\n}\nexport type oflags = u16;\n\n/** Identifiers for preopened capabilities. */\nexport namespace preopentype {\n  /** A pre-opened directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIR: preopentype = 0;\n}\nexport type preopentype = u8;\n\n@unmanaged abstract class $prestat { // WASM32: size=1/8, WASM64: size=1/16\n  /* The type of the pre-opened capability. */\n  type: preopentype;\n}\n\n/* Information about a pre-opened capability. */\n@unmanaged export abstract class prestat extends $prestat {\n  private __padding0: usize;\n}\n\n/** The contents of a $prestat when type is `preopentype.DIR`. */\n@unmanaged export class prestat_dir extends $prestat {\n  /** The length of the directory name for use with `fd_prestat_dir_name`. */\n  name_len: usize;\n}\n\n/** Flags provided to `sock_recv`. */\nexport namespace riflags {\n  /** Returns the message without removing it from the socket\'s receive queue. */\n  // @ts-ignore: decorator\n  @inline\n  export const PEEK: riflags = 1;\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\n  // @ts-ignore: decorator\n  @inline\n  export const WAITALL: riflags = 2;\n}\nexport type riflags = u16;\n\n/** File descriptor rights, determining which actions may be performed. */\nexport namespace rights {\n  /** The right to invoke `fd_datasync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_DATASYNC: rights = 1;\n  /** The right to invoke `fd_read` and `sock_recv`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: rights = 2;\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SEEK: rights = 4;\n  /** The right to invoke `fd_fdstat_set_flags`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\n  /** The right to invoke `fd_sync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SYNC: rights = 16;\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_TELL: rights = 32;\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: rights = 64;\n  /** The right to invoke `fd_advise`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ADVISE: rights = 128;\n  /** The right to invoke `fd_allocate`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ALLOCATE: rights = 256;\n  /** The right to invoke `path_create_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_DIRECTORY: rights = 512;\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_FILE: rights = 1024;\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_SOURCE: rights = 2048;\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_TARGET: rights = 4096;\n  /** The right to invoke `path_open`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_OPEN: rights = 8192;\n  /** The right to invoke `fd_readdir`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READDIR: rights = 16384;\n  /** The right to invoke `path_readlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_READLINK: rights = 32768;\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_SOURCE: rights = 65536;\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_TARGET: rights = 131072;\n  /** The right to invoke `path_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_GET: rights = 262144;\n  /** The right to change a file\'s size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\n  /** The right to invoke `path_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\n  /** The right to invoke `fd_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_GET: rights = 2097152;\n  /** The right to invoke `fd_filestat_set_size`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\n  /** The right to invoke `fd_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\n  /** The right to invoke `path_symlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\n  /** The right to invoke `path_remove_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\n  /** The right to invoke `path_unlink_file`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_UNLINK_FILE: rights = 67108864;\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\n  // @ts-ignore: decorator\n  @inline\n  export const POLL_FD_READWRITE: rights = 134217728;\n  /** The right to invoke `sock_shutdown`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCK_SHUTDOWN: rights = 268435456;\n}\nexport type rights = u64;\n\n/** Flags returned by `sock_recv`. */\nexport namespace roflags {\n  /** Message data has been truncated. */\n  // @ts-ignore: decorator\n  @inline\n  export const DATA_TRUNCATED: roflags = 1;\n}\nexport type roflags = u16;\n\n/** Which channels on a socket to shut down. */\nexport namespace sdflags {\n  /** Disables further receive operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RD: sdflags = 1;\n  /** Disables further send operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const WR: sdflags = 2;\n}\nexport type sdflags = u8;\n\n/** Flags provided to `sock_send`. */\nexport namespace siflags {\n  // As there are currently no flags defined, it must be set to zero.\n}\nexport type siflags = u16;\n\n/** Signal condition. */\nexport namespace signal {\n  /** Hangup. */\n  // @ts-ignore: decorator\n  @inline\n  export const HUP: signal = 1;\n  /** Terminate interrupt signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const INT: signal = 2;\n  /** Terminal quit signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const QUIT: signal = 3;\n  /** Illegal instruction. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILL: signal = 4;\n  /** Trace/breakpoint trap. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRAP: signal = 5;\n  /** Process abort signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABRT: signal = 6;\n  /** Access to an undefined portion of a memory object. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUS: signal = 7;\n  /** Erroneous arithmetic operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const FPE: signal = 8;\n  /** Kill. */\n  // @ts-ignore: decorator\n  @inline\n  export const KILL: signal = 9;\n  /** User-defined signal 1. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR1: signal = 10;\n  /** Invalid memory reference. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEGV: signal = 11;\n  /** User-defined signal 2. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR2: signal = 12;\n  /** Write on a pipe with no one to read it. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: signal = 13;\n  /** Alarm clock. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALRM: signal = 14;\n  /** Termination signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TERM: signal = 15;\n  /** Child process terminated, stopped, or continued. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHLD: signal = 16;\n  /** Continue executing, if stopped. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONT: signal = 17;\n  /** Stop executing. */\n  // @ts-ignore: decorator\n  @inline\n  export const STOP: signal = 18;\n  /** Terminal stop signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TSTP: signal = 19;\n  /** Background process attempting read. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTIN: signal = 20;\n  /** Background process attempting write. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTOU: signal = 21;\n  /** High bandwidth data is available at a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const URG: signal = 22;\n  /** CPU time limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XCPU: signal = 23;\n  /** File size limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XFSZ: signal = 24;\n  /** Virtual timer expired. */\n  // @ts-ignore: decorator\n  @inline\n  export const VTALRM: signal = 25;\n  // @ts-ignore: decorator\n  @inline\n  export const PROF: signal = 26;\n  // @ts-ignore: decorator\n  @inline\n  export const WINCH: signal = 27;\n  // @ts-ignore: decorator\n  @inline\n  export const POLL: signal = 28;\n  // @ts-ignore: decorator\n  @inline\n  export const PWR: signal = 29;\n  /** Bad system call. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYS: signal = 30;\n}\nexport type signal = u8;\n\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\nexport namespace subclockflags {\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABSTIME: subclockflags = 1;\n}\nexport type subclockflags = u16;\n\n@unmanaged abstract class $subscription { // size=16/48\n  /** User-provided value that is attached to the subscription. */\n  userdata: userdata;\n  /** The type of the event to which to subscribe. */\n  type: eventtype;\n\n  private __padding0: u32;\n}\n\n/** Subscription to an event. */\n@unmanaged export abstract class subscription extends $subscription {\n  private __padding1: u64;\n  private __padding2: u64;\n  private __padding3: u64;\n  private __padding4: u64;\n}\n\n/* Subscription to an event of type `eventtype.CLOCK`.**/\n@unmanaged export class subscription_clock extends $subscription {\n  /** The clock against which to compare the timestamp. */\n  clock_id: clockid;\n  /** The absolute or relative timestamp. */\n  timeout: timestamp;\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\n  precision: timestamp;\n  /** Flags specifying whether the timeout is absolute or relative. */\n  flags: subclockflags;\n\n  private __padding1: u32;\n}\n\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\n@unmanaged export class subscription_fd_readwrite extends $subscription {\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\n  file_descriptor: fd;\n\n  private __padding1: u64;\n  private __padding2: u64;\n  private __padding3: u64;\n}\n\n/** Timestamp in nanoseconds. */\nexport type timestamp = u64;\n\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\nexport type userdata = u64;\n\n/** The position relative to which to set the offset of the file descriptor. */\nexport namespace whence {\n  /** Seek relative to start-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET: whence = 0;\n  /** Seek relative to current position. */\n  // @ts-ignore: decorator\n  @inline\n  export const CUR: whence = 1;\n  /** Seek relative to end-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const END: whence = 2;\n}\n\nexport type whence = u8;\n',"bindings/wasi_unstable":"// Phase: wasi_unstable / wasi_snapshot_preview0\n// See: https://github.com/WebAssembly/WASI/tree/master/phases/old/snapshot_0/witx\n\n// helper types to be more explicit\ntype char = u8;\ntype ptr<T> = usize; // all pointers are usize'd\ntype struct<T> = T;  // structs are references already in AS\n\n/** Read command-line argument data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_get(\n  /** Input: Pointer to a buffer to write the argument pointers. */\n  argv: ptr<ptr<char>>,\n  /** Input: Pointer to a buffer to write the argument string data. */\n  argv_buf: ptr<char>\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_sizes_get(\n  /** Output: Number of arguments. */\n  argc: ptr<usize>,\n  /** Output: Size of the argument string data. */\n  argv_buf_size: ptr<usize>\n): errno;\n\n/** Return the resolution of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_res_get(\n  /** Input: The clock for which to return the resolution. */\n  clock: clockid,\n  /** Output: The resolution of the clock. */\n  resolution: ptr<timestamp>\n): errno;\n\n/** Return the time value of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_time_get(\n  /** Input: Cock for which to return the time. */\n  clock: clockid,\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\n  precision: timestamp,\n  /** Output: Time value of the clock. */\n  time: ptr<timestamp>\n): errno;\n\n/** Read environment variable data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_get(\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\n  environ: ptr<usize>,\n  /** Input: Pointer to a buffer to write the environment variable string data. */\n  environ_buf: usize\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_sizes_get(\n  /** Output: The number of environment variables. */\n  environ_count: ptr<usize>,\n  /** Output: The size of the environment variable string data. */\n  environ_buf_size: ptr<usize>\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_advise(\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\n  fd: fd,\n  /** Input: The offset within the file to which the advisory applies. */\n  offset: filesize,\n  /** Input: The length of the region to which the advisory applies. */\n  len: filesize,\n  /** Input: The advice. */\n  advice: advice\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_allocate(\n  /** Input: The file descriptor for the file in which to allocate space. */\n  fd: fd,\n  /** Input: The offset at which to start the allocation. */\n  offset: filesize,\n  /** Input: The length of the area that is allocated. */\n  len: filesize\n): errno;\n\n/** Close a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_close(\n  /** Input: The file descriptor to close. */\n  fd: fd\n): errno;\n\n/** Synchronize the data of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_datasync(\n  /** Input: The file descriptor of the file to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Get the attributes of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file descriptor's attributes are stored. */\n  buf: struct<fdstat>\n): errno;\n\n/** Adjust the flags associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_flags(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the file descriptor flags. */\n  flags: fdflags\n): errno;\n\n/** Adjust the rights associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_rights(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_base: rights,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_inheriting: rights\n): errno;\n\n/** Return the attributes of an open file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_size(\n  /** Input: A file descriptor for the file to adjust. */\n  fd: fd,\n  /** Input: The desired file size. */\n  size: filesize\n): errno;\n\n/** Adjust the timestamps of an open file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_times(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Read from a file descriptor, without using and updating the file descriptor's offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pread(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors in which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to read. */\n  offset: filesize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_get(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: The buffer where the description is stored. */\n  buf: struct<prestat>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_dir_name(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: Buffer into which to write the preopened directory name. */\n  path: ptr<char>,\n  /** Input: Length of the buffer into which to write the preopened directory name. */\n  path_len: usize\n): errno;\n\n/** Write to a file descriptor, without using and updating the file descriptor's offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pwrite(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to write. */\n  offset: filesize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/** Read from a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_read(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\n  iovs_len: usize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Read directory entries from a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_readdir(\n  /** Input: Directory from which to read the directory entries. */\n  fd: fd,\n  /** Input: Buffer where directory entries are stored. */\n  buf: ptr<struct<dirent>>,\n  /** Input: Length of the buffer where directory entries are stored. */\n  buf_len: usize,\n  /** Input: Location within the directory to start reading. */\n  cookie: dircookie,\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_renumber(\n  /** Input: The file descriptor to renumber. */\n  from: fd,\n  /** Input: The file descriptor to overwrite. */\n  to: fd\n): errno;\n\n/** Move the offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_seek(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The number of bytes to move. */\n  offset: filedelta,\n  /** Input: The base from which the offset is relative. */\n  whence: whence,\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Synchronize the data and metadata of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_sync(\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Return the current offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_tell(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Write to a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_write(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/* Create a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_create_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path at which to create the directory. */\n  path: ptr<char>,\n  /** Input: The path at which to create the directory. */\n  path_len: usize\n): errno;\n\n/** Return the attributes of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_get(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to inspect. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to inspect. */\n  path_len: usize,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the timestamps of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_set_times(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to operate on. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to operate on. */\n  path_len: usize,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Create a hard link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_link(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  old_flags: lookupflags,\n  /** Input: The source path from which to link. */\n  old_path: ptr<char>,\n  /** Input: The source path from which to link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path at which to create the hard link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the hard link. */\n  new_path_len: usize\n): errno;\n\n/** Open a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_open(\n  /** Input: The working directory at which the resolution of the path starts. */\n  dirfd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  dirflags: lookupflags,\n  /** Input: The path of the file or directory to open. */\n  path: ptr<char>,\n  /** Input: The length of the path of the file or directory to open. */\n  path_len: usize,\n  /** Input: The method by which to open the file. */\n  oflags: oflags,\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\n  fs_rights_base: rights,\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\n  fs_rights_inheriting: rights,\n  /** Input: The initial flags of the file descriptor. */\n  fs_flags: fdflags,\n  /** Output: The file descriptor of the file that has been opened. */\n  fd: ptr<fd>\n): errno;\n\n/** Read the contents of a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_readlink(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path of the symbolic link from which to read. */\n  path: ptr<char>,\n  /** Input: The length of the path of the symbolic link from which to read. */\n  path_len: usize,\n  /** Input: The buffer to which to write the contents of the symbolic link. */\n  buf: ptr<char>,\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\n  buf_len: usize,\n  /** Output: The number of bytes placed in the buffer. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Remove a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_remove_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a directory to remove. */\n  path: ptr<char>,\n  /** Input: The length of the path to a directory to remove. */\n  path_len: usize\n): errno;\n\n/** Rename a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_rename(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: The source path of the file or directory to rename. */\n  old_path: ptr<char>,\n  /** Input: The length of the source path of the file or directory to rename. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path to which to rename the file or directory. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path to which to rename the file or directory. */\n  new_path_len: usize\n): errno;\n\n/** Create a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_symlink(\n  /** Input: The contents of the symbolic link. */\n  old_path: ptr<char>,\n  /** Input: The length of the contents of the symbolic link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The destination path at which to create the symbolic link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the symbolic link. */\n  new_path_len: usize\n): errno;\n\n/** Unlink a file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_unlink_file(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a file to unlink. */\n  path: ptr<char>,\n  /** Input: The length of the path to a file to unlink. */\n  path_len: usize\n): errno;\n\n/** Concurrently poll for the occurrence of a set of events. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function poll_oneoff(\n  /** Input: The events to which to subscribe. */\n  in_: ptr<struct<subscription>>,\n  /** Input: The events that have occurred. */\n  out: ptr<struct<event>>,\n  /** Input: Both the number of subscriptions and events. */\n  nsubscriptions: usize,\n  /** Output: The number of events stored. */\n  nevents: ptr<usize>\n): errno;\n\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_exit(\n  /** Input: The exit code returned by the process. */\n  rval: u32\n): void;\n\n/** Send a signal to the process of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_raise(\n  /** Input: The signal condition to trigger. */\n  sig: signal\n): errno;\n\n/** Write high-quality random data into a buffer. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function random_get(\n  /** Input: The buffer to fill with random data. */\n  buf: usize,\n  /** Input: The length of the buffer to fill with random data. */\n  buf_len: usize\n): errno;\n\n/** Temporarily yield execution of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sched_yield(): errno;\n\n/** Receive a message from a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_recv(\n  /** Input: The socket on which to receive data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  ri_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\n  ri_data_len: usize,\n  /** Input: Message flags. */\n  ri_flags: riflags,\n  /** Output: Number of bytes stored in `ri_data`. */\n  ro_datalen: ptr<usize>,\n  /** Output: Message flags. */\n  ro_flags: ptr<roflags>\n): errno;\n\n/** Send a message on a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_send(\n  /** Input: The socket on which to send data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to retrieve data */\n  si_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\n  si_data_len: usize,\n  /** Input: Message flags. */\n  si_flags: siflags,\n  /** Output: Number of bytes transmitted. */\n  so_datalen: ptr<usize>\n): errno;\n\n/** Shut down socket send and receive channels. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_shutdown(\n  /** Input: The socket on which to shutdown channels. */\n  sock: fd,\n  /** Input: Which channels on the socket to shut down. */\n  how: sdflags\n): errno;\n\n// === Types ======================================================================================\n\n/** File or memory access pattern advisory information. */\nexport namespace advice {\n  /** The application has no advice to give on its behavior with respect to the specified data. */\n  // @ts-ignore: decorator\n  @inline\n  export const NORMAL: advice = 0;\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEQUENTIAL : advice = 1;\n  /** The application expects to access the specified data in a random order. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANDOM: advice = 2;\n  /** The application expects to access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const WILLNEED: advice = 3;\n  /** The application expects that it will not access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const DONTNEED: advice = 4;\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOREUSE: advice = 5;\n}\nexport type advice = u8;\n\n/** Identifiers for clocks. */\nexport namespace clockid {\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\n  // @ts-ignore: decorator\n  @inline\n  export const REALTIME: clockid = 0;\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\n  // @ts-ignore: decorator\n  @inline\n  export const MONOTONIC: clockid = 1;\n  /** The CPU-time clock associated with the current process. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROCESS_CPUTIME_ID: clockid = 2;\n  /** The CPU-time clock associated with the current thread. */\n  // @ts-ignore: decorator\n  @inline\n  export const THREAD_CPUTIME_ID: clockid = 3;\n}\nexport type clockid = u32;\n\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\nexport type device = u64;\n\n/** A reference to the offset of a directory entry. */\nexport type dircookie = u64;\n\n/** A directory entry. */\n@unmanaged export class dirent {\n  /** The offset of the next directory entry stored in this directory. */\n  next: dircookie;\n  /** The serial number of the file referred to by this directory entry. */\n  ino: inode;\n  /** The length of the name of the directory entry. */\n  namlen: u32;\n  /** The type of the file referred to by this directory entry. */\n  type: filetype;\n  private __padding0: u16;\n}\n\n/** Error codes returned by functions. */\nexport namespace errno {\n  /** No error occurred. System call completed successfully. */\n  // @ts-ignore: decorator\n  @inline\n  export const SUCCESS: errno = 0;\n  /** Argument list too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const TOOBIG: errno = 1;\n  /** Permission denied. */\n  // @ts-ignore: decorator\n  @inline\n  export const ACCES: errno = 2;\n  /** Address in use. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRINUSE: errno = 3;\n  /** Address not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRNOTAVAIL: errno = 4;\n  /** Address family not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const AFNOSUPPORT: errno = 5;\n  /** Resource unavailable, or operation would block. */\n  // @ts-ignore: decorator\n  @inline\n  export const AGAIN: errno = 6;\n  /** Connection already in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALREADY: errno = 7;\n  /** Bad file descriptor. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADF: errno = 8;\n  /** Bad message. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADMSG: errno = 9;\n  /** Device or resource busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUSY: errno = 10;\n  /** Operation canceled. */\n  // @ts-ignore: decorator\n  @inline\n  export const CANCELED: errno = 11;\n  /** No child processes. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHILD: errno = 12;\n  /** Connection aborted. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNABORTED: errno = 13;\n  /** Connection refused. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNREFUSED: errno = 14;\n  /** Connection reset. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNRESET: errno = 15;\n  /** Resource deadlock would occur. */\n  // @ts-ignore: decorator\n  @inline\n  export const DEADLK: errno = 16;\n  /** Destination address required. */\n  // @ts-ignore: decorator\n  @inline\n  export const DESTADDRREQ: errno = 17;\n  /** Mathematics argument out of domain of function. */\n  // @ts-ignore: decorator\n  @inline\n  export const DOM: errno = 18;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const DQUOT: errno = 19;\n  /** File exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXIST: errno = 20;\n  /** Bad address. */\n  // @ts-ignore: decorator\n  @inline\n  export const FAULT: errno = 21;\n  /** File too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const FBIG: errno = 22;\n  /** Host is unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const HOSTUNREACH: errno = 23;\n  /** Identifier removed. */\n  // @ts-ignore: decorator\n  @inline\n  export const IDRM: errno = 24;\n  /** Illegal byte sequence. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILSEQ: errno = 25;\n  /** Operation in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const INPROGRESS: errno = 26;\n  /** Interrupted function. */\n  // @ts-ignore: decorator\n  @inline\n  export const INTR: errno = 27;\n  /** Invalid argument. */\n  // @ts-ignore: decorator\n  @inline\n  export const INVAL: errno = 28;\n  /** I/O error. */\n  // @ts-ignore: decorator\n  @inline\n  export const IO: errno = 29;\n  /** Socket is connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISCONN: errno = 30;\n  /** Is a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISDIR: errno = 31;\n  /** Too many levels of symbolic links. */\n  // @ts-ignore: decorator\n  @inline\n  export const LOOP: errno = 32;\n  /** File descriptor value too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MFILE: errno = 33;\n  /** Too many links. */\n  // @ts-ignore: decorator\n  @inline\n  export const MLINK: errno = 34;\n  /** Message too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MSGSIZE: errno = 35;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const MULTIHOP: errno = 36;\n  /** Filename too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const NAMETOOLONG: errno = 37;\n  /** Network is down. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETDOWN: errno = 38;\n  /** Connection aborted by network. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETRESET: errno = 39;\n  /** Network unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETUNREACH: errno = 40;\n  /** Too many files open in system. */\n  // @ts-ignore: decorator\n  @inline\n  export const NFILE: errno = 41;\n  /** No buffer space available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOBUFS: errno = 42;\n  /** No such device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NODEV: errno = 43;\n  /** No such file or directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOENT: errno = 44;\n  /** Executable file format error. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOEXEC: errno = 45;\n  /** No locks available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLCK: errno = 46;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLINK: errno = 47;\n  /** Not enough space. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMEM: errno = 48;\n  /** No message of the desired type. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMSG: errno = 49;\n  /** Protocol not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOPROTOOPT: errno = 50;\n  /** No space left on device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSPC: errno = 51;\n  /** Function not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSYS: errno = 52;\n  /** The socket is not connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCONN: errno = 53;\n  /** Not a directory or a symbolic link to a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTDIR: errno = 54;\n  /** Directory not empty. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTEMPTY: errno = 55;\n  /** State not recoverable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTRECOVERABLE: errno = 56;\n  /** Not a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSOCK: errno = 57;\n  /** Not supported, or operation not supported on socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSUP: errno = 58;\n  /** Inappropriate I/O control operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTTY: errno = 59;\n  /** No such device or address. */\n  // @ts-ignore: decorator\n  @inline\n  export const NXIO: errno = 60;\n  /** Value too large to be stored in data type. */\n  // @ts-ignore: decorator\n  @inline\n  export const OVERFLOW: errno = 61;\n  /** Previous owner died. */\n  // @ts-ignore: decorator\n  @inline\n  export const OWNERDEAD: errno = 62;\n  /** Operation not permitted. */\n  // @ts-ignore: decorator\n  @inline\n  export const PERM: errno = 63;\n  /** Broken pipe. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: errno = 64;\n  /** Protocol error. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTO: errno = 65;\n  /** Protocol not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTONOSUPPORT: errno = 66;\n  /** Protocol wrong type for socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTOTYPE: errno = 67;\n  /** Result too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANGE: errno = 68;\n  /** Read-only file system. */\n  // @ts-ignore: decorator\n  @inline\n  export const ROFS: errno = 69;\n  /** Invalid seek. */\n  // @ts-ignore: decorator\n  @inline\n  export const SPIPE: errno = 70;\n  /** No such process. */\n  // @ts-ignore: decorator\n  @inline\n  export const SRCH: errno = 71;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const STALE: errno = 72;\n  /** Connection timed out. */\n  // @ts-ignore: decorator\n  @inline\n  export const TIMEDOUT: errno = 73;\n  /** Text file busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const TXTBSY: errno = 74;\n  /** Cross-device link. */\n  // @ts-ignore: decorator\n  @inline\n  export const XDEV: errno = 75;\n  /** Extension: Capabilities insufficient. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCAPABLE: errno = 76;\n}\nexport type errno = u16;\n\n/** An event that occurred. */\n@unmanaged export abstract class event {\n  /** User-provided value that got attached to `subscription#userdata`. */\n  userdata: userdata;\n  /** If non-zero, an error that occurred while processing the subscription request. */\n  error: errno;\n  /* The type of the event that occurred. */\n  type: eventtype;\n  private __padding0: u16;\n}\n\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\n@unmanaged export class rwevent extends event {\n  /* The number of bytes available for reading or writing. */\n  nbytes: filesize;\n  /* The state of the file descriptor. */\n  flags: eventrwflags;\n  private __padding1: u32;\n}\n\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\nexport namespace eventrwflags {\n  /** The peer of this socket has closed or disconnected. */\n  // @ts-ignore: decorator\n  @inline\n  export const HANGUP: eventrwflags = 1;\n}\nexport type eventrwflags = u16;\n\n/** Type of a subscription to an event or its occurrence. */\nexport namespace eventtype {\n  /** The time value of clock has reached the timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const CLOCK: eventtype = 0;\n  /** File descriptor has data available for reading. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: eventtype = 1;\n  /** File descriptor has capacity available for writing */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: eventtype = 2;\n}\nexport type eventtype = u8;\n\n/** Exit code generated by a process when exiting. */\nexport type exitcode = u32;\n\n/** A file descriptor number. */\nexport type fd = u32;\n\n/** File descriptor flags. */\nexport namespace fdflags {\n  /** Append mode: Data written to the file is always appended to the file's end. */\n  // @ts-ignore: decorator\n  @inline\n  export const APPEND: fdflags = 1;\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\n  // @ts-ignore: decorator\n  @inline\n  export const DSYNC: fdflags = 2;\n  /** Non-blocking mode. */\n  // @ts-ignore: decorator\n  @inline\n  export const NONBLOCK: fdflags = 4;\n  /** Synchronized read I/O operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RSYNC: fdflags = 8;\n  /** Write according to synchronized I/O file integrity completion. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYNC: fdflags = 16;\n}\nexport type fdflags = u16;\n\n/** File descriptor attributes. */\n@unmanaged export class fdstat {\n  /** File type. */\n  filetype: filetype;\n  /** File descriptor flags. */\n  flags: fdflags;\n  /** Rights that apply to this file descriptor. */\n  rights_base: rights;\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\n  rights_inheriting: rights;\n}\n\n/** Relative offset within a file. */\nexport type filedelta = i64;\n\n/** Non-negative file size or length of a region within a file. */\nexport type filesize = u64;\n\n/** File attributes. */\n@unmanaged export class filestat {\n  /** Device ID of device containing the file. */\n  dev: device;\n  /** File serial number. */\n  ino: inode;\n  /** File type. */\n  filetype: filetype;\n  /** Number of hard links to the file. */\n  nlink: linkcount;\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\n  size: filesize;\n  /** Last data access timestamp. */\n  atim: timestamp;\n  /** Last data modification timestamp. */\n  mtim: timestamp;\n  /** Last file status change timestamp. */\n  ctim: timestamp;\n}\n\n/** The type of a file descriptor or file. */\nexport namespace filetype {\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\n  // @ts-ignore: decorator\n  @inline\n  export const UNKNOWN: filetype = 0;\n  /** The file descriptor or file refers to a block device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const BLOCK_DEVICE: filetype = 1;\n  /** The file descriptor or file refers to a character device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHARACTER_DEVICE: filetype = 2;\n  /** The file descriptor or file refers to a directory inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: filetype = 3;\n  /** The file descriptor or file refers to a regular file inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const REGULAR_FILE: filetype = 4;\n  /** The file descriptor or file refers to a datagram socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_DGRAM: filetype = 5;\n  /** The file descriptor or file refers to a byte-stream socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_STREAM: filetype = 6;\n  /** The file refers to a symbolic link inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMBOLIC_LINK: filetype = 7;\n}\nexport type filetype = u8;\n\n/** Which file time attributes to adjust. */\nexport namespace fstflags {\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM: fstflags = 1;\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM_NOW: fstflags = 2;\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM: fstflags = 4;\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM_NOW: fstflags = 8;\n}\nexport type fstflags = u16;\n\n/** File serial number that is unique within its file system. */\nexport type inode = u64;\n\n/** A region of memory for scatter/gather reads. */\n@unmanaged export class iovec {\n  /** The address of the buffer to be filled. */\n  buf: usize;\n  /** The length of the buffer to be filled. */\n  buf_len: usize;\n}\n\n/** Number of hard links to an inode. */\nexport type linkcount = u32;\n\n/** Flags determining the method of how paths are resolved. */\nexport namespace lookupflags {\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMLINK_FOLLOW: lookupflags = 1;\n}\nexport type lookupflags = u32;\n\n/** Open flags. */\nexport namespace oflags {\n  /** Create file if it does not exist. */\n  // @ts-ignore: decorator\n  @inline\n  export const CREAT: oflags = 1;\n  /** Fail if not a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: oflags = 2;\n  /** Fail if file already exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXCL: oflags = 4;\n  /** Truncate file to size 0. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRUNC: oflags = 8;\n}\nexport type oflags = u16;\n\n// TODO: undocumented\nexport namespace preopentype {\n  // @ts-ignore: decorator\n  @inline\n  export const DIR: preopentype = 0;\n}\nexport type preopentype = u8;\n\n// TODO: undocumented\nexport abstract class prestat {\n  type: preopentype;\n}\n\n// TODO: undocumented\nexport class dirprestat extends prestat {\n  name_len: usize;\n}\n\n/** Flags provided to `sock_recv`. */\nexport namespace riflags {\n  /** Returns the message without removing it from the socket's receive queue. */\n  // @ts-ignore: decorator\n  @inline\n  export const PEEK: riflags = 1;\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\n  // @ts-ignore: decorator\n  @inline\n  export const WAITALL: riflags = 2;\n}\nexport type riflags = u16;\n\n/** File descriptor rights, determining which actions may be performed. */\nexport namespace rights {\n  /** The right to invoke `fd_datasync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_DATASYNC: rights = 1;\n  /** The right to invoke `fd_read` and `sock_recv`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: rights = 2;\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SEEK: rights = 4;\n  /** The right to invoke `fd_fdstat_set_flags`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\n  /** The right to invoke `fd_sync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SYNC: rights = 16;\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_TELL: rights = 32;\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: rights = 64;\n  /** The right to invoke `fd_advise`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ADVISE: rights = 128;\n  /** The right to invoke `fd_allocate`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ALLOCATE: rights = 256;\n  /** The right to invoke `path_create_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_DIRECTORY: rights = 512;\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_FILE: rights = 1024;\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_SOURCE: rights = 2048;\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_TARGET: rights = 4096;\n  /** The right to invoke `path_open`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_OPEN: rights = 8192;\n  /** The right to invoke `fd_readdir`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READDIR: rights = 16384;\n  /** The right to invoke `path_readlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_READLINK: rights = 32768;\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_SOURCE: rights = 65536;\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_TARGET: rights = 131072;\n  /** The right to invoke `path_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_GET: rights = 262144;\n  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\n  /** The right to invoke `path_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\n  /** The right to invoke `fd_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_GET: rights = 2097152;\n  /** The right to invoke `fd_filestat_set_size`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\n  /** The right to invoke `fd_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\n  /** The right to invoke `path_symlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\n  /** The right to invoke `path_remove_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\n  /** The right to invoke `path_unlink_file`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_UNLINK_FILE: rights = 67108864;\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\n  // @ts-ignore: decorator\n  @inline\n  export const POLL_FD_READWRITE: rights = 134217728;\n  /** The right to invoke `sock_shutdown`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCK_SHUTDOWN: rights = 268435456;\n}\nexport type rights = u64;\n\n/** Flags returned by `sock_recv`. */\nexport namespace roflags {\n  /** Message data has been truncated. */\n  // @ts-ignore: decorator\n  @inline\n  export const DATA_TRUNCATED: roflags = 1;\n}\nexport type roflags = u16;\n\n/** Which channels on a socket to shut down. */\nexport namespace sdflags {\n  /** Disables further receive operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RD: sdflags = 1;\n  /** Disables further send operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const WR: sdflags = 2;\n}\nexport type sdflags = u8;\n\n/** Flags provided to `sock_send`. */\nexport namespace siflags {\n  // As there are currently no flags defined, it must be set to zero.\n}\nexport type siflags = u16;\n\n/** Signal condition. */\nexport namespace signal {\n  /** Hangup. */\n  // @ts-ignore: decorator\n  @inline\n  export const HUP: signal = 1;\n  /** Terminate interrupt signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const INT: signal = 2;\n  /** Terminal quit signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const QUIT: signal = 3;\n  /** Illegal instruction. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILL: signal = 4;\n  /** Trace/breakpoint trap. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRAP: signal = 5;\n  /** Process abort signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABRT: signal = 6;\n  /** Access to an undefined portion of a memory object. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUS: signal = 7;\n  /** Erroneous arithmetic operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const FPE: signal = 8;\n  /** Kill. */\n  // @ts-ignore: decorator\n  @inline\n  export const KILL: signal = 9;\n  /** User-defined signal 1. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR1: signal = 10;\n  /** Invalid memory reference. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEGV: signal = 11;\n  /** User-defined signal 2. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR2: signal = 12;\n  /** Write on a pipe with no one to read it. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: signal = 13;\n  /** Alarm clock. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALRM: signal = 14;\n  /** Termination signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TERM: signal = 15;\n  /** Child process terminated, stopped, or continued. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHLD: signal = 16;\n  /** Continue executing, if stopped. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONT: signal = 17;\n  /** Stop executing. */\n  // @ts-ignore: decorator\n  @inline\n  export const STOP: signal = 18;\n  /** Terminal stop signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TSTP: signal = 19;\n  /** Background process attempting read. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTIN: signal = 20;\n  /** Background process attempting write. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTOU: signal = 21;\n  /** High bandwidth data is available at a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const URG: signal = 22;\n  /** CPU time limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XCPU: signal = 23;\n  /** File size limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XFSZ: signal = 24;\n  /** Virtual timer expired. */\n  // @ts-ignore: decorator\n  @inline\n  export const VTALRM: signal = 25;\n  // @ts-ignore: decorator\n  @inline\n  export const PROF: signal = 26;\n  // @ts-ignore: decorator\n  @inline\n  export const WINCH: signal = 27;\n  // @ts-ignore: decorator\n  @inline\n  export const POLL: signal = 28;\n  // @ts-ignore: decorator\n  @inline\n  export const PWR: signal = 29;\n  /** Bad system call. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYS: signal = 30;\n}\nexport type signal = u8;\n\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\nexport namespace subclockflags {\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABSTIME: subclockflags = 1;\n}\nexport type subclockflags = u16;\n\n/** Subscription to an event. */\n@unmanaged export abstract class subscription {\n  /** User-provided value that is attached to the subscription. */\n  userdata: userdata;\n  /** The type of the event to which to subscribe. */\n  type: eventtype;\n  private __padding0: u32;\n}\n\n/* Subscription to an event of type `eventtype.CLOCK`.**/\n@unmanaged export class clocksubscription extends subscription {\n  /** The user-defined unique identifier of the clock. */\n  identifier: userdata;\n  /** The clock against which to compare the timestamp. */\n  clock_id: clockid;\n  /** The absolute or relative timestamp. */\n  timeout: timestamp;\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\n  precision: timestamp;\n  /** Flags specifying whether the timeout is absolute or relative. */\n  flags: subclockflags;\n  private __padding1: u32;\n}\n\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\n@unmanaged export class fdsubscription extends subscription {\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\n  fd: fd;\n}\n\n/** Timestamp in nanoseconds. */\nexport type timestamp = u64;\n\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\nexport type userdata = u64;\n\n/** The position relative to which to set the offset of the file descriptor. */\nexport namespace whence {\n  /** Seek relative to current position. */\n  // @ts-ignore: decorator\n  @inline\n  export const CUR: whence = 0;\n  /** Seek relative to end-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const END: whence = 1;\n  /** Seek relative to start-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET: whence = 2;\n}\nexport type whence = u8;","bindings/wasi":'export * from "./wasi_snapshot_preview1";\n',builtins:'type auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): boolean;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128; // except i64\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma<T>(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms<T>(v1: v128, v2: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\nexport namespace v8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v16x8 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v32x4 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v64x2 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external("env", "abort")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external("env", "trace")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external("env", "seed")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n',compat:"export type ReturnType<T> = returnof<T>;\n",console:'import {\n  process\n} from "./process";\n\n// @ts-ignore: decorator\n@lazy var timers = new Map<string,u64>();\n\nexport namespace console {\n\n  export function assert<T>(condition: T, message: string): void {\n    if (!condition) {\n      let stderr = process.stderr;\n      stderr.write("Assertion failed: ");\n      stderr.write(message);\n      stderr.write("\\n");\n    }\n  }\n\n  export function log(message: string): void {\n    var stdout = process.stdout;\n    stdout.write(message);\n    stdout.write("\\n");\n  }\n\n  export function debug(message: string): void {\n    var stdout = process.stdout;\n    stdout.write("Debug: ");\n    stdout.write(message);\n    stdout.write("\\n");\n  }\n\n  export function info(message: string): void {\n    var stdout = process.stdout;\n    stdout.write("Info: ");\n    stdout.write(message);\n    stdout.write("\\n");\n  }\n\n  export function warn(message: string): void {\n    var stdout = process.stdout;\n    stdout.write("Warning: ");\n    stdout.write(message);\n    stdout.write("\\n");\n  }\n\n  export function error(message: string): void {\n    var stdout = process.stdout;\n    stdout.write("Error: ");\n    stdout.write(message);\n    stdout.write("\\n");\n  }\n\n  export function time(label: string): void {\n    var stdout = process.stdout;\n    if (timers.has(label)) {\n      stdout.write("Warning: Label \'");\n      stdout.write(label);\n      stdout.write("\' already exists for console.time()\\n");\n      return;\n    }\n    timers.set(label, process.hrtime());\n  }\n\n  export function timeLog(label: string): void {\n    var stdout = process.stdout;\n    if (!timers.has(label)) {\n      stdout.write("Warning: No such label \'");\n      stdout.write(label);\n      stdout.write("\' for console.timeLog()\\n");\n      return;\n    }\n    timeLogImpl(label);\n  }\n\n  export function timeEnd(label: string): void {\n    var stdout = process.stdout;\n    if (!timers.has(label)) {\n      stdout.write("Warning: No such label \'");\n      stdout.write(label);\n      stdout.write("\' for console.timeEnd()\\n");\n      return;\n    }\n    timeLogImpl(label);\n    timers.delete(label);\n  }\n}\n\nfunction timeLogImpl(label: string): void {\n  var start = changetype<u64>(timers.get(label));\n  var end = process.hrtime();\n  var nanos = end - start;\n  var millis = nanos / 1000000;\n  var millisStr = millis.toString();\n  var stdout = process.stdout;\n  stdout.write(label);\n  stdout.write(": ");\n  stdout.write(millisStr);\n  stdout.write("ms\\n");\n  // __dispose(changetype<usize>(millisStr));\n}\n',crypto:'import {\n  errnoToString,\n  random_get\n} from "bindings/wasi_snapshot_preview1";\n\nexport namespace crypto {\n  export function getRandomValues(array: Uint8Array): void {\n    var err = random_get(changetype<usize>(array.buffer) + <usize>array.byteOffset, <usize>array.byteLength);\n    if (err) throw new Error(errnoToString(err));\n  }\n}\n',dataview:'import { BLOCK_MAXSIZE } from "./rt/common";\nimport { ArrayBuffer } from "./arraybuffer";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from "./util/error";\n\n// TODO: there is probably a smarter way to check byteOffset for accesses larger than 1 byte\n\nexport class DataView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  constructor(\n    buffer: ArrayBuffer,\n    byteOffset: i32 = 0,\n    byteLength: i32 = buffer.byteLength\n  ) {\n    if (\n      i32(<u32>byteLength > <u32>BLOCK_MAXSIZE) |\n      i32(<u32>byteOffset + byteLength > <u32>buffer.byteLength)\n    ) throw new RangeError(E_INVALIDLENGTH);\n    this.buffer = buffer; // links\n    var dataStart = changetype<usize>(buffer) + <usize>byteOffset;\n    this.dataStart = dataStart;\n    this.byteLength = byteLength;\n  }\n\n  getFloat32(byteOffset: i32, littleEndian: bool = false): f32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f32>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f32>(bswap<u32>(load<u32>(this.dataStart + <usize>byteOffset)));\n  }\n\n  getFloat64(byteOffset: i32, littleEndian: bool = false): f64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f64>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f64>(bswap<u64>(load<u64>(this.dataStart + <usize>byteOffset)));\n  }\n\n  getInt8(byteOffset: i32): i8 {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getInt16(byteOffset: i32, littleEndian: bool = false): i16 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: i16 = load<i16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<i16>(result);\n  }\n\n  getInt32(byteOffset: i32, littleEndian: bool = false): i32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: i32 = load<i32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<i32>(result);\n  }\n\n  getUint8(byteOffset: i32): u8 {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getUint16(byteOffset: i32, littleEndian: bool = false): u16 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: u16 = load<u16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u16>(result);\n  }\n\n  getUint32(byteOffset: i32, littleEndian: bool = false): u32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: u32 = load<u32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u32>(result);\n  }\n\n  setFloat32(byteOffset: i32, value: f32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f32>(this.dataStart + <usize>byteOffset, value);\n    else store<u32>(this.dataStart + <usize>byteOffset, bswap<u32>(reinterpret<u32>(value)));\n  }\n\n  setFloat64(byteOffset: i32, value: f64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f64>(this.dataStart + <usize>byteOffset, value);\n    else store<u64>(this.dataStart + <usize>byteOffset, bswap<u64>(reinterpret<u64>(value)));\n  }\n\n  setInt8(byteOffset: i32, value: i8): void {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setInt16(byteOffset: i32, value: i16, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<i16>(value));\n  }\n\n  setInt32(byteOffset: i32, value: i32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<i32>(value));\n  }\n\n  setUint8(byteOffset: i32, value: u8): void {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setUint16(byteOffset: i32, value: u16, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\n  }\n\n  setUint32(byteOffset: i32, value: u32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\n  }\n\n  // Non-standard additions that make sense in WebAssembly, but won\'t work in JS:\n\n  getInt64(byteOffset: i32, littleEndian: bool = false): i64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: i64 = load<i64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<i64>(result);\n  }\n\n  getUint64(byteOffset: i32, littleEndian: bool = false): u64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result = load<u64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u64>(result);\n  }\n\n  setInt64(byteOffset: i32, value: i64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<i64>(value));\n  }\n\n  setUint64(byteOffset: i32, value: u64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\n  }\n\n  toString(): string {\n    return "[object DataView]";\n  }\n}\n',date:'import {\n  UTC as Date_UTC,\n  now as Date_now\n} from "./bindings/Date";\n\nexport class Date {\n\n  @inline static UTC(\n    year: i32,\n    month: i32 = 0,\n    day: i32 = 1,\n    hour: i32 = 0,\n    minute: i32 = 0,\n    second: i32 = 0,\n    millisecond: i64 = 0\n  ): i64 {\n    return <i64>Date_UTC(year, month, day, hour, minute, second, <f64>millisecond);\n  }\n\n  @inline static now(): i64 {\n    return <i64>Date_now();\n  }\n\n  private value: i64;\n\n  constructor(value: i64) {\n    this.value = value;\n  }\n\n  getTime(): i64 {\n    return this.value;\n  }\n\n  setTime(value: i64): i64 {\n    this.value = value;\n    return value;\n  }\n}\n',diagnostics:"// @ts-ignore: decorator\n@builtin\nexport declare function ERROR(message?: string): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function WARNING(message?: string): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function INFO(message?: string): void;\n",error:'export class Error {\n\n  name: string  = "Error";\n  stack: string = ""; // TODO\n\n  constructor(\n    public message: string = ""\n  ) {}\n\n  toString(): string {\n    var message = this.message;\n    return message.length\n      ? this.name + ": " + message\n      : this.name;\n  }\n}\n\nexport class RangeError extends Error {\n  constructor(message: string = "") {\n    super(message);\n    this.name = "RangeError";\n  }\n}\n\nexport class TypeError extends Error {\n  constructor(message: string = "") {\n    super(message);\n    this.name = "TypeError";\n  }\n}\n\nexport class SyntaxError extends Error {\n  constructor(message: string = "") {\n    super(message);\n    this.name = "SyntaxError";\n  }\n}\n',function:'type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>("_index"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return "";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return "function() { [native code] }";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n',iterator:"export abstract class Iterable<T> {\n  // ?\n}\n\n@final\nexport abstract class Iterator<T> {\n\n  // private constructor(iterable: Iterable<T>) {\n  // }\n\n  // TODO: these need to evaluate the classId at the respective reference in order to obtain the\n  // next value, i.e. arrays work differently than maps. we'd then have:\n  //\n  // ╒═══════════════════ Iterator layout (32-bit) ══════════════════╕\n  //    3                   2                   1\n  //  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n  // ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n  // │                             index                             │\n  // ├─────────────────────────────────────────────────────────┬───┬─┤\n  // │                           reference                     │ 0 │D│\n  // └─────────────────────────────────────────────────────────┴───┴─┘\n  // D: Done flag\n\n  // get value(this: u64): T {\n  //   ?\n  // }\n\n  // next(this: u64): Iterator<T> {\n  //   ?\n  // }\n\n  done(this: u64): bool {\n    return <bool>(this & 1);\n  }\n}\n",map:'/// <reference path="./rt/index.d.ts" />\n\nimport { HASH } from "./util/hash";\nimport { E_KEYNOTFOUND } from "./util/error";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  @operator("[]")\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator("[]=")\n  set(key: K, value: V): this {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var keys = new Array<K>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        keys[length++] = entry.key;\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<V>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.value;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return "[object Map]";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n',math:'import * as JSMath from "./bindings/Math";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from "./util/math";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from "./builtins";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy var rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of π/2 * |x|\n *\n * y = π/4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of π/4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  var shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  var lo = umuldi(p1, q1);\n  var hi = res128_hi;\n\n  var ahi = hi >> 11;\n  var alo = lo >> 11 | hi << 53;\n  var blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  var magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  var offset = (magnitude >> 52) - 1045;\n  var shift  = offset & 63;\n  var tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  var s0: u64, s1: u64, s2: u64;\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 / π with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  var significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2π)\n  var blo = umuldi(s1, significand);\n  var bhi = res128_hi;\n\n  var ahi = s0 * significand;\n  var clo = (s2 >> 32) * (significand >> 32);\n  var plo = blo + clo;\n  var phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  var rlo = plo << 2;\n  var rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  var slo = <i64>rhi >> 63;\n  var shi = slo >> 1;\n  var q   = (<i64>phi >> 62) - slo;\n\n  var shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  var signbit = (u ^ rhi) & 0x8000000000000000;\n  var coeff = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const pio2_1  = reinterpret<f64>(0x3FF921FB54400000); // 1.57079632673412561417e+00\n  const pio2_1t = reinterpret<f64>(0x3DD0B4611A626331); // 6.07710050650619224932e-11\n  const pio2_2  = reinterpret<f64>(0x3DD0B4611A600000); // 6.07710050630396597660e-11\n  const pio2_2t = reinterpret<f64>(0x3BA3198A2E037073); // 2.02226624879595063154e-21\n  const pio2_3  = reinterpret<f64>(0x3BA3198A2E000000); // 2.02226624871116645580e-21\n  const pio2_3t = reinterpret<f64>(0x397B839A252049C1); // 8.47842766036889956997e-32\n  const invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  var ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  var q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const S1 = reinterpret<f64>(0xBFC5555555555549); // -1.66666666666666324348e-01\n  const S2 = reinterpret<f64>(0x3F8111111110F8A6); //  8.33333333332248946124e-03\n  const S3 = reinterpret<f64>(0xBF2A01A019C161D5); // -1.98412698298579493134e-04\n  const S4 = reinterpret<f64>(0x3EC71DE357B1FE7D); //  2.75573137070700676789e-06\n  const S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB); // -2.50507602534068634195e-08\n  const S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  var z = x * x;\n  var w = z * z;\n  var r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  var v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const C1 = reinterpret<f64>(0x3FA555555555554C); //  4.16666666666666019037e-02\n  const C2 = reinterpret<f64>(0xBF56C16C16C15177); // -1.38888888888741095749e-03\n  const C3 = reinterpret<f64>(0x3EFA01A019CB1590); //  2.48015872894767294178e-05\n  const C4 = reinterpret<f64>(0xBE927E4F809C52AD); // -2.75573143513906633035e-07\n  const C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4); //  2.08757232129817482790e-09\n  const C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  var z = x * x;\n  var w = z * z;\n  var r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  var hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const T0  = reinterpret<f64>(0x3FD5555555555563); //  3.33333333333334091986e-01\n  const T1  = reinterpret<f64>(0x3FC111111110FE7A); //  1.33333333333201242699e-01\n  const T2  = reinterpret<f64>(0x3FABA1BA1BB341FE); //  5.39682539762260521377e-02\n  const T3  = reinterpret<f64>(0x3F9664F48406D637); //  2.18694882948595424599e-02\n  const T4  = reinterpret<f64>(0x3F8226E3E96E8493); //  8.86323982359930005737e-03\n  const T5  = reinterpret<f64>(0x3F6D6D22C9560328); //  3.59207910759131235356e-03\n  const T6  = reinterpret<f64>(0x3F57DBC8FEE08315); //  1.45620945432529025516e-03\n  const T7  = reinterpret<f64>(0x3F4344D8F2F26501); //  5.88041240820264096874e-04\n  const T8  = reinterpret<f64>(0x3F3026F71A8D1068); //  2.46463134818469906812e-04\n  const T9  = reinterpret<f64>(0x3F147E88A03792A6); //  7.81794442939557092300e-05\n  const T10 = reinterpret<f64>(0x3F12B80F32F0A7E9); //  7.14072491382608190305e-05\n  const T11 = reinterpret<f64>(0xBEF375CBDB605373); // -1.85586374855275456654e-05\n  const T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const one    = reinterpret<f64>(0x3FF0000000000000); // 1.00000000000000000000e+00\n  const pio4   = reinterpret<f64>(0x3FE921FB54442D18); // 7.85398163397448278999e-01\n  const pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  var z: f64, r: f64, v: f64, w: f64, s: f64;\n  var hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  var ix = hx & 0x7FFFFFFF; // high word of |x|\n  var big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  var a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, u >> 63);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy var random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy var random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    var s: f64, w: f64, z: f64;\n    if (hx >> 31) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    var c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z);\n    var r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var lx = <u32>u;\n    u = reinterpret<u64>(y);\n    var iy = <u32>(u >> 32);\n    var ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    var z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    var t = reinterpret<f64>(u);\n    var r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    var s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);\n      let hx = <u32>(reinterpret<u64>(x) >> 32);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\n    var k = 0, sign_ = <i32>(u >> 63);\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    var c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    var hfx = 0.5 * x;\n    var hxs = x * hfx;\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    var hxq = hxs * hxs;\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    var twopk = reinterpret<f64>(u);\n    var y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    var ex = <i32>(ux >> 52);\n    var ey = <i32>(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    var z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    var c = x * SPLIT;\n    var h = x - c + c;\n    var l = x - h;\n    var hx = x * x;\n    var lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    var hy = y * y;\n    var ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000);\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31)    return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln10hi;\n    var dk = <f64>k;\n    var y = dk * log10_2hi;\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 1;\n    var c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = <u32>(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = <i32>(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000);\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += <i32>(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with "stdlib call simplify" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n      let u_ = reinterpret<u64>(x);\n      let hx = <i32>(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = <i32>(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = <u32>(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = <u32>(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    random_seeded = true;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    assert(\n      random_state0_64 != 0 && random_state1_64 != 0 &&\n      random_state0_32 != 0 && random_state1_32 != 0\n    );\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    var s1 = random_state0_64;\n    var s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    var r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f64): f64 {\n    return builtin_copysign<f64>(builtin_floor<f64>(x + 0.5), x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return <bool>(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    var absx = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(absx);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(absx, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    var u = reinterpret<u64>(x);\n    var ix = <i32>(u >> 32);\n    var sign = ix >>> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    var n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n    var y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler\'s optimization pass.\n      // It could be apply for any x % C_pot, where "C_pot" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = ux >> 63;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u64>-1 >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    var shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    var uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= <u64>-1 >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    var q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3FE921FB) {  // |x| ~<= π/4\n      if (ix < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n    var s = sin_kern(y0, y1, 1);\n    var c = cos_kern(y0, y1);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n  var p = z * (pS0 + z * (pS1 + z * pS2));\n  var q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n\n  var offset = (u >> 23) - 152;\n  var shift  = <u64>(offset & 63);\n  var tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  var product = mantissa * hi + (mantissa * lo >> 32);\n  var r: i64 = product << 2;\n  var q = <i32>((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const pi2hi = reinterpret<f64>(0x3FF921FB50000000); // 1.57079631090164184570\n  const pi2lo = reinterpret<f64>(0x3E5110B4611A6263); // 1.58932547735281966916e-8\n  const _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { // π * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  var q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const S1 = reinterpret<f64>(0xBFC5555554CBAC77); // -0x15555554cbac77.0p-55\n  const S2 = reinterpret<f64>(0x3F811110896EFBB2); //  0x111110896efbb2.0p-59\n  const S3 = reinterpret<f64>(0xBF2A00F9E2CAE774); // -0x1a00f9e2cae774.0p-65\n  const S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  var z = x * x;\n  var w = z * z;\n  var r = S3 + z * S4;\n  var s = z * x;\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81); // -0x1ffffffd0c5e81.0p-54\n  const C1 = reinterpret<f64>(0x3FA55553E1053A42); //  0x155553e1053a42.0p-57\n  const C2 = reinterpret<f64>(0xBF56C087E80F1E27); // -0x16c087e80f1e27.0p-62\n  const C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  var z = x * x;\n  var w = z * z;\n  var r = C2 + z * C3;\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n\n  const T0 = reinterpret<f64>(0x3FD5554D3418C99F); // 0x15554d3418c99f.0p-54\n  const T1 = reinterpret<f64>(0x3FC112FD38999F72); // 0x1112fd38999f72.0p-55\n  const T2 = reinterpret<f64>(0x3FAB54C91D865AFE); // 0x1b54c91d865afe.0p-57\n  const T3 = reinterpret<f64>(0x3F991DF3908C33CE); // 0x191df3908c33ce.0p-58\n  const T4 = reinterpret<f64>(0x3F685DADFCECF44E); // 0x185dadfcecf44e.0p-61\n  const T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  var z = x * x;\n  var r = T4 + z * T5;\n  var t = T2 + z * T3;\n  var w = z * z;\n  var s = z * x;\n  var u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return <f32>(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  var i = reinterpret<i64>(x);\n  var exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  var xx = x * x;\n  var y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  var n = nearest(x);\n  x -= n;\n  var xx = x * x;\n  var y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    var z: f32, w: f32, s: f32;\n    if (hx >> 31) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\n    var c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) {\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (a < 0x3F800000 + (12 << 23)) return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var sx = x;\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z); // sic\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = reinterpret<u32>(x);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\n    var s2 = w * (aT1 + w * aT3);\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    var u = reinterpret<u32>(x);\n    var y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var ix = reinterpret<u32>(x);\n    var iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    var z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    var t = <f64>reinterpret<f32>(u);\n    var r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const c1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const c2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {  // |x| ~<= 5π/4\n        if (ix > 0x4016CBE3) { // |x|  ~> 3π/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ix <= 0x40E231D5) {  // |x| ~<= 9π/4\n        if (ix > 0x40AFEDDF) { // |x|  ~> 7π/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000);\n      let hx = reinterpret<u32>(x);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign_) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f32>(0x42B17180), //  8.8721679688e+01f\n      ln2_hi      = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo      = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2      = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1          = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2          = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f    = reinterpret<f32>(0x7F000000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    var sign_ = <i32>(u >> 31);\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) {\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    var c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    var hfx: f32 = 0.5 * x;\n    var hxs: f32 = x * hfx;\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    var twopk = reinterpret<f32>(u);\n    var y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    var z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      if (u < 0x00800000 || <bool>(u >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (u >> 31) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += <u32>(<i32>u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) {\n      return x;\n    } else if (ix == 0x3F800000) {\n      return 0;\n    }\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    ix = reinterpret<u32>(hi);\n    ix &= 0xFFFFF000;\n    hi = reinterpret<f32>(ix);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n    var ix = reinterpret<u32>(x);\n    var c: f32 = 0, f: f32 = 0;\n    var k: i32 = 1;\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = <i32>(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n      let ix = reinterpret<u32>(x);\n      let k: i32 = 0;\n      if (ix < 0x00800000 || <bool>(ix >> 31)) {\n        if (ix << 1 == 0) return -1 / (x * x);\n        if (ix >> 31) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ix = reinterpret<u32>(x);\n      } else if (ix >= 0x7F800000) {\n        return x;\n      } else if (ix == 0x3F800000) {\n        return 0;\n      }\n      ix += 0x3F800000 - 0x3F3504F3;\n      k += <i32>(ix >> 23) - 0x7F;\n      ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ix);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with "stdlib call simplify" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = uy >> 31 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = uy >> 31 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    var s0 = random_state0_32;\n    var s1 = random_state1_32;\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f32): f32 {\n    return builtin_copysign<f32>(builtin_floor<f32>(x + 0.5), x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var absx = reinterpret<f32>(u);\n    var h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(absx);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(absx, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const t1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const t2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // argument reduction\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    var t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n    var y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler\'s optimization pass.\n      // It could be apply for any x % C_pot, where "C_pot" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sm = ux & 0x80000000;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    var shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = <i32>(ux >> 31);\n    var uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= <u32>-1 >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    var q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3π/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    var s = sin_kernf(y);\n    var c = cos_kernf(y);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  var out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  var out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n',memory:'import { memcmp, memmove, memset } from "./util/memory";\nimport { E_NOTIMPLEMENTED } from "./util/error";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if "bulk-memory" isn\'t enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if "bulk-memory" isn\'t enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare var __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n',number:'import { itoa32, utoa32, itoa64, utoa64, dtoa } from "./util/number";\nimport { strtol } from "./util/string";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? "true" : "false";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n',object:"export class Object {\n  static is<T>(value1: T, value2: T): bool {\n    if (isFloat<T>()) {\n      if (value1 == value2) {\n        // 0 === -0, but they are not identical\n        if (sizeof<T>() == 8) {\n          // @ts-ignore: typecast\n          return reinterpret<u64>(value1) == reinterpret<u64>(value2);\n        } else {\n          // @ts-ignore: typecast\n          return reinterpret<u32>(value1) == reinterpret<u32>(value2);\n        }\n      }\n      // NaN !== NaN, but they are identical.\n      // @ts-ignore: typecast\n      return bool(i32(isNaN(value1)) & i32(isNaN(value2)));\n    }\n    // For references, strings, integers and booleans\n    return value1 == value2;\n  }\n}\n",polyfills:"export function bswap<T extends number>(value: T): T {\n  if (isInteger<T>()) {\n    if (sizeof<T>() == 2) {\n      return <T>((value << 8) | ((value >> 8) & <T>0x00FF));\n    }\n    if (sizeof<T>() == 4) {\n      return <T>(\n        rotl<u32>(<u32>value & 0xFF00FF00, 8) |\n        rotr<u32>(<u32>value & 0x00FF00FF, 8)\n      );\n    }\n    if (sizeof<T>() == 8) {\n      let a = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\n      let b = (<u64>value & 0x00FF00FF00FF00FF) << 8;\n      let v = a | b;\n\n      a = (v >> 16) & 0x0000FFFF0000FFFF;\n      b = (v & 0x0000FFFF0000FFFF) << 16;\n\n      return <T>rotr<u64>(a | b, 32);\n    }\n    return value;\n  }\n  assert(false);\n  return value;\n}\n\nexport function bswap16<T extends number>(value: T): T {\n  if (isInteger<T>() && sizeof<T>() <= 4) {\n    if (sizeof<T>() == 2) {\n      return <T>((value << 8) | ((value >> 8) & <T>0x00FF));\n    } else if (sizeof<T>() == 4) {\n      return <T>(((value << 8) & <T>0xFF00) | ((value >> 8) & <T>0x00FF) | (value & <T>0xFFFF0000));\n    }\n    return value;\n  }\n  assert(false);\n  return value;\n}\n",process:'import {\n  args_get,\n  args_sizes_get,\n  environ_get,\n  environ_sizes_get,\n  proc_exit,\n  fd_write,\n  fd_close,\n  fd_read,\n  clock_time_get,\n  clockid,\n  errnoToString,\n  fd\n} from "bindings/wasi_snapshot_preview1";\n\nimport {\n  E_INDEXOUTOFRANGE\n} from "util/error";\n\n// @ts-ignore: decorator\n@lazy const iobuf = memory.data(4 * sizeof<usize>());\n\nexport namespace process {\n\n  // @ts-ignore: decorator\n  @lazy export const arch = sizeof<usize>() == 4 ? "wasm32" : "wasm64";\n\n  // @ts-ignore: decorator\n  @lazy export const platform = "wasm";\n\n  // @ts-ignore: decorator\n  @lazy export const argv = lazyArgv();\n\n  // @ts-ignore: decorator\n  @lazy export const env = lazyEnv();\n\n  // @ts-ignore: decorator\n  @lazy export var exitCode = 0;\n\n  export function exit(code: i32 = exitCode): void {\n    proc_exit(code);\n  }\n\n  // @ts-ignore: decorator\n  @lazy export const stdin = changetype<ReadableStream>(0);\n  // @ts-ignore: decorator\n  @lazy export const stdout = changetype<WritableStream>(1);\n  // @ts-ignore: decorator\n  @lazy export const stderr = changetype<WritableStream>(2);\n\n  export function time(): i64 {\n    var err = clock_time_get(clockid.REALTIME, 1000000, iobuf);\n    if (err) throw new Error(errnoToString(err));\n    return load<u64>(iobuf) / 1000000;\n  }\n\n  export function hrtime(): u64 {\n    var err = clock_time_get(clockid.MONOTONIC, 0, iobuf);\n    if (err) throw new Error(errnoToString(err));\n    return load<u64>(iobuf);\n  }\n}\n\nfunction lazyArgv(): string[] {\n  var err = args_sizes_get(iobuf, iobuf + sizeof<usize>());\n  if (err) throw new Error(errnoToString(err));\n  var count = load<usize>(iobuf);\n  var ptrsSize = count * sizeof<usize>();\n  var dataSize = load<usize>(iobuf, sizeof<usize>());\n  var bufSize = ptrsSize + dataSize;\n  var buf = __alloc(bufSize);\n  err = args_get(buf, buf + ptrsSize);\n  if (err) throw new Error(errnoToString(err));\n  var count32 = <i32>count;\n  var argv = new Array<string>(count32);\n  for (let i = 0; i < count32; ++i) {\n    let ptr = load<usize>(buf + i * sizeof<usize>());\n    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);\n    argv[i] = str;\n  }\n  __free(buf);\n  return argv;\n}\n\nfunction lazyEnv(): Map<string,string> {\n  var err = environ_sizes_get(iobuf, iobuf + 4);\n  if (err) throw new Error(errnoToString(err));\n  var count = load<usize>(iobuf);\n  var ptrsSize = count * sizeof<usize>();\n  var dataSize = load<usize>(iobuf, sizeof<usize>());\n  var bufSize = ptrsSize + dataSize;\n  var buf = __alloc(bufSize);\n  err = environ_get(buf, buf + ptrsSize);\n  if (err) throw new Error(errnoToString(err));\n  var env = new Map<string,string>();\n  for (let i: usize = 0; i < count; ++i) {\n    let ptr = load<usize>(buf + i * sizeof<usize>());\n    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);\n    let pos = str.indexOf("=");\n    if (~pos) {\n      env.set(str.substring(0, pos), str.substring(pos + 1));\n      // __dispose(changetype<usize>(str));\n    } else {\n      env.set(str, "");\n    }\n  }\n  __free(buf);\n  return env;\n}\n\n@unmanaged\nabstract class Stream {\n  close(): void {\n    var err = fd_close(<u32>changetype<usize>(this));\n    if (err) throw new Error(errnoToString(err));\n  }\n}\n\n@unmanaged\nabstract class WritableStream extends Stream {\n  write<T>(data: T): void {\n    if (isString<T>()) {\n      writeString(<u32>changetype<usize>(this), changetype<string>(data));\n    } else if (data instanceof ArrayBuffer) {\n      writeBuffer(<u32>changetype<usize>(this), data);\n    } else {\n      ERROR("String or ArrayBuffer expected");\n    }\n  }\n}\n\n@unmanaged\nabstract class ReadableStream extends Stream {\n  read(buffer: ArrayBuffer, offset: isize = 0): i32 {\n    var end = <usize>buffer.byteLength;\n    if (offset < 0 || offset > end) {\n      throw new Error(E_INDEXOUTOFRANGE);\n    }\n    store<usize>(iobuf, changetype<usize>(buffer) + offset);\n    store<usize>(iobuf, end - offset, sizeof<usize>());\n    var err = fd_read(<u32>changetype<usize>(this), iobuf, 1, iobuf + 2 * sizeof<usize>());\n    if (err) throw new Error(errnoToString(err));\n    return <i32>load<isize>(iobuf, 2 * sizeof<usize>());\n  }\n}\n\nfunction writeBuffer(fd: fd, data: ArrayBuffer): void {\n  store<usize>(iobuf, changetype<usize>(data));\n  store<usize>(iobuf, data.byteLength, sizeof<usize>());\n  var err = fd_write(<u32>fd, iobuf, 1, iobuf + 2 * sizeof<usize>());\n  if (err) throw new Error(errnoToString(err));\n}\n\nfunction writeString(fd: fd, data: string): void {\n  var char2 = -1;\n  var char3 = -1;\n  var char4 = -1;\n  switch (data.length) {\n    case 4: { // "null"\n      char4 = <i32>load<u16>(changetype<usize>(data), 6);\n      if (char4 >= 0x80) break;\n    }\n    case 3: { // "ms\\n"\n      char3 = <i32>load<u16>(changetype<usize>(data), 4);\n      if (char3 >= 0x80) break;\n    }\n    case 2: { // "\\r\\n"\n      char2 = <i32>load<u16>(changetype<usize>(data), 2);\n      if (char2 >= 0x80) break;\n    }\n    case 1: { // "\\n"\n      let char1 = <i32>load<u16>(changetype<usize>(data));\n      if (char1 >= 0x80) break;\n      store<usize>(iobuf, iobuf + 2 * sizeof<usize>());\n      store<usize>(iobuf, <i32>1 + i32(char2 != -1) + i32(char3 != -1) + i32(char4 != -1), sizeof<usize>());\n      store<u32>(iobuf, char1 | char2 << 8 | char3 << 16 | char4 << 24, 2 * sizeof<usize>());\n      let err = fd_write(<u32>fd, iobuf, 1, iobuf + 3 * sizeof<usize>());\n      if (err) throw new Error(errnoToString(err));\n    }\n    case 0: return;\n  }\n  var utf8len = <usize>String.UTF8.byteLength(data);\n  var utf8buf = __alloc(utf8len);\n  assert(String.UTF8.encodeUnsafe(changetype<usize>(data), data.length, utf8buf) == utf8len);\n  store<usize>(iobuf, utf8buf);\n  store<usize>(iobuf, utf8len, sizeof<usize>());\n  var err = fd_write(<u32>fd, iobuf, 1, iobuf + 2 * sizeof<usize>());\n  __free(utf8buf);\n  if (err) throw new Error(errnoToString(err));\n}\n',reference:"@unmanaged\nabstract class Ref {\n}\n\n@final @unmanaged\nexport abstract class Funcref extends Ref {\n}\n\n@final @unmanaged\nexport abstract class Externref extends Ref {\n}\n\n@final @unmanaged\nexport abstract class Exnref extends Ref {\n}\n\n@final @unmanaged\nexport abstract class Anyref extends Ref {\n}\n",regexp:'export class RegExp {\n\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\n  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\n  test(search: string): bool { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [], STRING)\n  toString(): string { throw new Error("unreachable"); }\n\n}\n',rt:'import { Typeinfo, TypeinfoFlags } from "./shared/typeinfo";\nimport { E_INDEXOUTOFRANGE } from "./util/error";\nimport { OBJECT, TOTAL_OVERHEAD } from "./rt/common";\nimport { ArrayBufferView } from "./arraybuffer";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\n  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\n  var rttiBase = __rtti_base;\n  if (id <= load<u32>(rttiBase)) {\n    do if (id == classId) return true;\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  var array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>("buffer"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>("dataStart"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>("byteLength"));\n  store<i32>(array, length, offsetof<i32[]>("length_"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n',"rt/common":"// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","rt/index-incremental":'import "rt/tlsf";\nimport "rt/itcms";\n',"rt/index-minimal":'import "rt/tlsf";\nimport "rt/tcms";\n',"rt/index-stub":'import "rt/stub";\n',"rt/itcms":'import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from "./common";\nimport { onvisit, oncollect, oninterrupt, onyield } from "./rtrace";\nimport { TypeinfoFlags } from "../shared/typeinfo";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from "../util/error";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le\'s μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy var state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var iter: Object; // null\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object\'s data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object\'s color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object\'s color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    var rtId = this.rtId;\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    var prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  var ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  var obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  var ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  var newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  var child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier "backward". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier "forward". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered \'black\' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn\'t missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace("GC (full) at", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace("GC (full) done at cur/max", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means "interrupt each 1024 bytes allocated". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means "run at double the speed of allocations". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means "wait for memory to double before kicking in again". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of objects for the next scheduled GC step. */\n// @ts-ignore: decorator\n@lazy var threshold: usize = GRANULARITY;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace("GC (auto) at", 1, total);\n  var budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace("└ GC (auto) done at cur/max", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace("└ GC (auto) ongoing at", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n',"rt/rtrace":'import { BLOCK } from "./common";\n\nexport declare function oninit(heapBase: usize): void;\n\n// Memory Allocator\nexport declare function onalloc(block: BLOCK): void;\nexport declare function onresize(block: BLOCK, oldSizeInclOverhead: usize): void;\nexport declare function onmove(oldBlock: BLOCK, newBlock: BLOCK): void;\nexport declare function onfree(block: BLOCK): void;\n\n// Garbage collector\nexport declare function onvisit(block: BLOCK): bool;\nexport declare function oncollect(total: usize): void;\nexport declare function oninterrupt(total: usize): void;\nexport declare function onyield(total: usize): void;\n',"rt/stub":'import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from "./common";\nimport { E_ALLOCATION_TOO_LARGE } from "../util/error";\n\n// === A minimal runtime stub ===\n\n// @ts-ignore: decorator\n@lazy var startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n// @ts-ignore: decorator\n@lazy var offset: usize = startOffset;\n\nfunction maybeGrowMemory(newOffset: usize): void {\n  // assumes newOffset is aligned\n  var pagesBefore = memory.size();\n  var maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;\n  if (newOffset > maxOffset) {\n    let pagesNeeded = <i32>(((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newOffset;\n}\n\n// @ts-ignore: decorator\n@inline function computeSize(size: usize): usize {\n  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var block = changetype<BLOCK>(offset);\n  var ptr = offset + BLOCK_OVERHEAD;\n  var payloadSize = computeSize(size);\n  maybeGrowMemory(ptr + payloadSize);\n  block.mmInfo = payloadSize;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ptr: usize, size: usize): usize {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  var actualSize = block.mmInfo;\n  var isLast = ptr + actualSize == offset;\n  var payloadSize = computeSize(size);\n  if (size > actualSize) {\n    if (isLast) { // last block: grow\n      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n      maybeGrowMemory(ptr + payloadSize);\n      block.mmInfo = payloadSize;\n    } else { // copy to new block at least double the size\n      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));\n      memory.copy(newPtr, ptr, actualSize);\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\n    }\n  } else if (isLast) { // last block: shrink\n    offset = ptr + payloadSize;\n    block.mmInfo = payloadSize;\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ptr: usize): void {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  if (ptr + block.mmInfo == offset) { // last block: discard\n    offset = changetype<usize>(block);\n  }\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __new(size: usize, id: u32): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var ptr = __alloc(OBJECT_OVERHEAD + size);\n  var object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);\n  object.gcInfo = 0;\n  object.gcInfo2 = 0;\n  object.rtId = id;\n  object.rtSize = <u32>size;\n  return ptr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __renew(oldPtr: usize, size: usize): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);\n  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;\n  return newPtr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  // nop\n}\n',"rt/tcms":'import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE } from "./common";\nimport { onvisit, oncollect } from "./rtrace";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from "../util/error";\n\n// === TCMS: A Two-Color Mark & Sweep garbage collector ===\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unreachable                                     │\n// │ BLACK*      │ Reachable                                       │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object\'s data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object\'s color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object\'s color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white);\n  total += obj.size;\n  return changetype<usize>(obj) + TOTAL_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  if (oldPtr < __heap_base) { // move to heap for simplicity\n    let newPtr = __new(size, oldObj.rtId);\n    memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n    return newPtr;\n  }\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  total -= oldObj.size;\n  var newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size) + OBJECT_OVERHEAD;\n  var newObj = changetype<Object>(newPtr - TOTAL_OVERHEAD);\n  newObj.rtSize = <u32>size;\n\n  // Replace with new object\n  newObj.next.prev = newObj;\n  newObj.prev.next = newObj;\n\n  total += newObj.size;\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.unlink(); // from fromSpace\n    obj.linkTo(toSpace, i32(!white));\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  obj.unlink(); // from pinSpace\n  obj.linkTo(fromSpace, white);\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace("GC at", 1, total);\n\n  // Mark roots (add to toSpace)\n  __visit_globals(VISIT_SCAN);\n\n  // Mark direct members of pinned objects (add to toSpace)\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\n    iter = iter.next;\n  }\n\n  // Mark what\'s reachable from toSpace\n  var black = i32(!white);\n  var to = toSpace;\n  iter = to.next;\n  while (iter != to) {\n    if (DEBUG) assert(iter.color == black);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\n    iter = iter.next;\n  }\n\n  // Sweep what\'s left in fromSpace\n  var from = fromSpace;\n  iter = from.next;\n  while (iter != from) {\n    if (DEBUG) assert(iter.color == white);\n    let newNext = iter.next;\n    if (changetype<usize>(iter) < __heap_base) {\n      iter.nextWithColor = 0; // may become linked again\n      iter.prev = changetype<Object>(0);\n    } else {\n      total -= iter.size;\n      if (isDefined(__finalize)) __finalize(changetype<usize>(iter) + TOTAL_OVERHEAD);\n      __free(changetype<usize>(iter) + BLOCK_OVERHEAD);\n    }\n    iter = newNext;\n  }\n  from.nextWithColor = changetype<usize>(from);\n  from.prev = from;\n\n  // Flip spaces and colors\n  fromSpace = to;\n  toSpace = from;\n  white = black;\n\n  if (TRACE) trace("GC done at", 1, total);\n  if (RTRACE) oncollect(total);\n}\n',"rt/tlsf":"import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, right);\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\n      right = GETRIGHT(block);\n      rightInfo = right.mmInfo;\n      // 'back' is set below\n    }\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, left);\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\n      block = left;\n      // 'back' is set below\n    }\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size >= BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  var root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  var memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n  var blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\n      // is immediately split though. does this trigger any assertions / issues?\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  var newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n",set:'/// <reference path="./rt/index.d.ts" />\n\nimport { HASH } from "./util/hash";\n\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a set entry. */\n@unmanaged class SetEntry<K> {\n  key: K;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<T>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\n  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<T>(): usize {\n  const align = ENTRY_ALIGN<T>();\n  const size = (offsetof<SetEntry<T>>() + align) & ~align;\n  return size;\n}\n\nexport class Set<T> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, SetEntry<K>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: T, hashCode: u32): SetEntry<T> | null {\n    var entry = load<SetEntry<T>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  @operator("[]")\n  has(key: T): bool {\n    return this.find(key, HASH<T>(key)) !== null;\n  }\n\n  add(key: T): this {\n    var hashCode = HASH<T>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (!entry) {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());\n      entry.key = key;\n      if (isManaged<T>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  @operator("[]=")\n  private __set(key: T, value: bool): void {\n    if (value) this.add(key);\n    else this.delete(key);\n  }\n\n  delete(key: T): bool {\n    var entry = this.find(key, HASH<T>(key)); // unmanaged!\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<T>();\n      }\n      oldPtr += ENTRY_SIZE<T>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  values(): T[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<T>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.key;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return "[object Set]";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<T>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n      while (cur < end) {\n        let entry = changetype<SetEntry<T>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          let val = changetype<usize>(entry.key);\n          if (isNullable<T>()) {\n            if (val) __visit(val, cookie);\n          } else __visit(val, cookie);\n        }\n        cur += ENTRY_SIZE<T>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n',"shared/feature":'// This file is shared with the compiler and must remain portable\n\n/** Indicates specific features to activate. */\nexport const enum Feature {\n  /** No additional features. */\n  NONE = 0,\n  /** Sign extension operations. */\n  SIGN_EXTENSION = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\n  /** Mutable global imports and exports. */\n  MUTABLE_GLOBALS = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\n  /** Non-trapping float to integer operations. */\n  NONTRAPPING_F2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  /** Bulk memory operations. */\n  BULK_MEMORY = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\n  /** SIMD types and operations. */\n  SIMD = 1 << 4, // see: https://github.com/WebAssembly/simd\n  /** Threading and atomic operations. */\n  THREADS = 1 << 5, // see: https://github.com/WebAssembly/threads\n  /** Exception handling operations. */\n  EXCEPTION_HANDLING = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\n  /** Tail call operations. */\n  TAIL_CALLS = 1 << 7, // see: https://github.com/WebAssembly/tail-call\n  /** Reference types. */\n  REFERENCE_TYPES = 1 << 8, // see: https://github.com/WebAssembly/reference-types\n  /** Multi value types. */\n  MULTI_VALUE = 1 << 9, // see: https://github.com/WebAssembly/multi-value\n  /** Garbage collection. */\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\n  /** Memory64. */\n  MEMORY64 = 1 << 11 // see: https://github.com/WebAssembly/memory64\n}\n\n/** Gets the name of the specified feature one would specify on the command line. */\nexport function featureToString(feature: Feature): string {\n  switch (feature) {\n    case Feature.SIGN_EXTENSION: return "sign-extension";\n    case Feature.MUTABLE_GLOBALS: return "mutable-globals";\n    case Feature.NONTRAPPING_F2I: return "nontrapping-f2i";\n    case Feature.BULK_MEMORY: return "bulk-memory";\n    case Feature.SIMD: return "simd";\n    case Feature.THREADS: return "threads";\n    case Feature.EXCEPTION_HANDLING: return "exception-handling";\n    case Feature.TAIL_CALLS: return "tail-calls";\n    case Feature.REFERENCE_TYPES: return "reference-types";\n    case Feature.MULTI_VALUE: return "multi-value";\n    case Feature.GC: return "gc";\n    case Feature.MEMORY64: return "memory64";\n  }\n  assert(false);\n  return "";\n}\n',"shared/target":"// This file is shared with the compiler and must remain portable\n\n/** Compilation target. */\nexport enum Target {\n  /** Portable. */\n  JS = 0,\n  /** WebAssembly with 32-bit pointers. */\n  WASM32 = 1,\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\n  WASM64 = 2,\n}\n","shared/typeinfo":"// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n",staticarray:'/// <reference path="./rt/index.d.ts" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from "./rt/common";\nimport { idof } from "./builtins";\nimport { Array } from "./array";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from "./util/error";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from "./util/string";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    var length = source.length;\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    var sourceLen = source.length;\n    var otherLen = select(0, other.length, other === null);\n    var outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<StaticArray<T>>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n    var outStart = changetype<usize>(out);\n    var sourceSize = <usize>sourceLen << alignof<T>();\n    if (isManaged<T>()) {\n      for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(source) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += sourceSize;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(other) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(source), sourceSize);\n      memory.copy(outStart + sourceSize, changetype<usize>(other), <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    var length = source.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var sliceSize = <usize>length << alignof<T>();\n    var slice = changetype<StaticArray<T>>(__new(sliceSize, idof<StaticArray<T>>()));\n    var sourcePtr = changetype<usize>(source) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off: usize = 0;\n      while (off < sliceSize) {\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(slice) + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(changetype<usize>(slice), sourcePtr, sliceSize);\n    }\n    return slice;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    memory.fill(changetype<usize>(out), 0, outSize);\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    var len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator("[]") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator("{}") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator("[]=") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator("{}=") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    var length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length;\n    var otherLen = select(0, other.length, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = changetype<usize>(this);\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(this), thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = changetype<usize>(this) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  join(separator: string = ","): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR("unspported element type");\n    return <string>unreachable();\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n',string:'/// <reference path="./rt/index.d.ts" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from "./rt/common";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from "./util/string";\nimport { SPECIALS_UPPER, casemap, bsearch } from "./util/casemap";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from "./util/error";\nimport { idof } from "./builtins";\nimport { Array } from "./array";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    var length = units.length;\n    var out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    var ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var hasSur = code > 0xFFFF;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = (code >>> 10) | 0xD800;\n      store<u32>(changetype<usize>(out), lo | (hi << 16));\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    var len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator("[]") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>("");\n    var out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator("+") private static __concat(left: String, right: String): String {\n    return select<String>(left, changetype<String>("null"), left !== null).concat(right);\n  }\n\n  concat(other: String): String {\n    if (other === null) other = changetype<String>("null");\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>("");\n    var out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    if (search === null) return false;\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator("==") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix("!")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator("!=")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(">") private static __gt(left: String | null, right: String | null): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(">=") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator("<") private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator("<=") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (other === this) return 0; // compare pointers\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // "" == ""\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    if (search === null) search = changetype<String>("null");\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>("");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>("");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>("");\n    if (!offset && size == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>("");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>("");\n    if (size == originalSize) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = " "): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = " "): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can\'t handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>("");\n    if (count == 1) return this;\n    var out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var thisLen: usize = this.length;\n    var searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    var replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: \'abc\'.replaceAll(\'\', \'-\') -> \'-a-b-c-\'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    var out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>("");\n    var out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (separator === null) return [this];\n    var length: isize = this.length;\n    var sepLen = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>("")); // static ""\n      return result;\n    }\n    var result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(""));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn\'t do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>("")); // static ""\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // \'Σ\'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    var specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    var specialsLen = SPECIALS_UPPER.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false): usize {\n      var strEnd = str + (<usize>len << 1);\n      var bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && str + 2 < strEnd) {\n            let c2 = <u32>load<u16>(str, 2);\n            if ((c2 & 0xFC00) == 0xDC00) {\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n              let b0 = c1 >> 18 | 240;\n              let b1 = c1 >> 12 & 63 | 128;\n              let b2 = c1 >> 6  & 63 | 128;\n              let b3 = c1       & 63 | 128;\n              store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n              bufOff += 4; str += 4;\n              continue;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      var strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      var size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n',symbol:'import { Map } from "./map";\n\n// @ts-ignore: decorator\n@lazy var stringToId: Map<string, usize>;\n\n// @ts-ignore: decorator\n@lazy var idToString: Map<usize, string>;\n\n// @ts-ignore: decorator\n@lazy var nextId: usize = 12; // Symbol.unscopables + 1\n\n@unmanaged @final abstract class _Symbol {\n\n  // TODO: all of the following default symbols are unused currently yet add to\n  // binary size if #toString becomes compiled. Ultimately we\'ll most likely want\n  // to remove the unsupported ones and only keep what\'s actually supported.\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly hasInstance: symbol = changetype<symbol>(1);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly isConcatSpreadable: symbol = changetype<symbol>(2);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly isRegExp: symbol = changetype<symbol>(3);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly iterator: symbol = changetype<symbol>(3);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly match: symbol = changetype<symbol>(4);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly replace: symbol = changetype<symbol>(5);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly search: symbol = changetype<symbol>(6);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly species: symbol = changetype<symbol>(7);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly split: symbol = changetype<symbol>(8);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly toPrimitive: symbol = changetype<symbol>(9);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly toStringTag: symbol = changetype<symbol>(10);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly unscopables: symbol = changetype<symbol>(11);\n\n  static for(key: string): symbol {\n    if (!stringToId) { stringToId = new Map(); idToString = new Map(); }\n    else if (stringToId.has(key)) return changetype<symbol>(stringToId.get(key));\n    var id = nextId++;\n    if (!id) unreachable(); // out of ids\n    stringToId.set(key, id);\n    idToString.set(id, key);\n    return changetype<symbol>(id);\n  }\n\n  static keyFor(sym: symbol): string | null {\n    return idToString !== null && idToString.has(changetype<usize>(sym))\n      ? idToString.get(changetype<usize>(sym))\n      : null;\n  }\n\n  toString(): string {\n    var id = changetype<usize>(this);\n    var str = "";\n    switch (<u32>id) {\n      case 1:  { str = "hasInstance"; break; }\n      case 2:  { str = "isConcatSpreadable"; break; }\n      case 3:  { str = "isRegExp"; break; }\n      case 4:  { str = "match"; break; }\n      case 5:  { str = "replace"; break; }\n      case 6:  { str = "search"; break; }\n      case 7:  { str = "species"; break; }\n      case 8:  { str = "split"; break; }\n      case 9:  { str = "toPrimitive"; break; }\n      case 10: { str = "toStringTag"; break; }\n      case 11: { str = "unscopables"; break; }\n      default: {\n        if (idToString !== null && idToString.has(id)) str = idToString.get(id);\n        break;\n      }\n    }\n    return "Symbol(" + str + ")";\n  }\n}\n\nexport function Symbol(description: string | null = null): symbol {\n  var id = nextId++;\n  if (!id) unreachable(); // out of ids\n  return changetype<symbol>(id);\n}\n\nexport type Symbol = _Symbol;\n\n// @ts-ignore: nolib\nexport type symbol = _Symbol;\n',table:'import { E_NOTIMPLEMENTED } from "./util/error";\n\nexport namespace table {\n\n  export function copy(dst: u32, src: u32, n: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  export function drop(elementIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n}\n',typedarray:'import { COMPARATOR, SORT as SORT_IMPL } from "./util/sort";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from "./util/error";\nimport { joinIntegerArray, joinFloatArray } from "./util/string";\nimport { idof } from "./builtins";\nimport { ArrayBufferView } from "./arraybuffer";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator("[]")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    return SORT<Int8Array, i8>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i8>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int8Array, i8, U, valueof<U>>(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator("[]")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    return SORT<Uint8Array, u8>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8Array, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator("[]")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(fn: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    return SORT<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8ClampedArray, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator("[]")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    var len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    return SORT<Int16Array, i16>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i16>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int16Array, i16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator("[]")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    var len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    return SORT<Uint16Array, u16>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u16>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint16Array, u16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator("[]")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    var len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    return SORT<Int32Array, i32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i32>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int32Array, i32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator("[]")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    var len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    return SORT<Uint32Array, u32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u32>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint32Array, u32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator("[]")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    var len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    return SORT<Int64Array, i64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i64>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int64Array, i64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator("[]")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    var len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    return SORT<Uint64Array, u64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u64>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint64Array, u64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator("[]")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    var len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    return SORT<Float32Array, f32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f32>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float32Array, f32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator("[]")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator("{}")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator("{}=")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    var len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    return SORT<Float64Array, f64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f64>(this);\n  }\n\n  join(separator: string = ","): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float64Array, f64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var dataStart = array.dataStart;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(dataStart + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(dataStart + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SORT<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var len = array.length;\n  if (len <= 1) return array;\n  var base = array.dataStart;\n  if (len == 2) {\n    let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n    let b: T = load<T>(base); // b = arr[0]\n    if (comparator(a, b) < 0) {\n      store<T>(base, b, sizeof<T>()); // arr[1] = b\n      store<T>(base, a); // arr[0] = a\n    }\n    return array;\n  }\n  SORT_IMPL<T>(base, len, comparator);\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  var slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>("buffer"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>("dataStart"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>("byteLength"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  var dataStart = array.dataStart;\n\n  end   = min<i32>(end, len);\n  var to    = target < 0 ? max(len + target, 0) : min(target, len);\n  var from  = start < 0 ? max(len + start, 0) : min(start, len);\n  var last  = end < 0 ? max(len + end, 0) : min(end, len);\n  var count = min(last - from, len - to);\n\n  memory.copy(\n    dataStart + (<usize>to << alignof<T>()),\n    dataStart + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var len = array.length;\n  var dataStart = array.dataStart;\n\n  var byteLength = len << alignof<T>();\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>("buffer"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>("dataStart"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  var len = array.length;\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  var dataStart  = array.dataStart;\n  var j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  var byteLength = j << alignof<T>();\n  var data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>("buffer"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>("dataStart"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let length: isize = array.length;\n    if (length == 0 || index >= length) return false;\n    if (index < 0) index = max(length + index, 0);\n    let dataStart = array.dataStart;\n    while (index < length) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0 || index >= length) return -1;\n  if (index < 0) index = max(length + index, 0);\n  var dataStart = array.dataStart;\n  while (index < length) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0) return -1;\n  if (index < 0) index = length + index; // no need to clamp\n  else if (index >= length) index = length - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {\n  var dataStart = array.dataStart;\n  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {\n    let frontPtr = dataStart + (front << alignof<T>());\n    let backPtr = dataStart + (back << alignof<T>());\n    let temp = load<T>(frontPtr);\n    store<T>(frontPtr, load<T>(backPtr));\n    store<T>(backPtr, temp);\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  length: i32 = -1\n): TArray {\n  var byteLength: i32;\n  var bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (length < 0) {\n    if (length == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = length << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>("buffer"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>("dataStart"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<TArray extends ArrayBufferView, T, UArray extends ArrayBufferView, U>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<U>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n\n  // Uncaught RangeError: offset is out of bounds\n  if (offset < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n  if (source.length + offset > target.length) throw new RangeError(E_INDEXOUTOFRANGE);\n\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (isInteger<T>() == isInteger<U>() && alignof<T>() == alignof<U>() &&\n    !(target instanceof Uint8ClampedArray && isSigned<U>())) {\n    memory.copy(\n      target.dataStart + (<usize>offset << alignof<T>()),\n      source.dataStart,\n      source.byteLength\n    );\n  } else {\n    let targetDataStart = target.dataStart + (<usize>offset << alignof<T>());\n    let sourceDataStart = source.dataStart;\n    let count = source.length;\n    for (let i = 0; i < count; i++) {\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<U>()) {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          store<T>(\n            targetDataStart + (<usize>i << alignof<T>()),\n            isFinite<U>(value) ? <T>max<U>(0, min<U>(255, value)) : <T>0\n          );\n        } else {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          if (!isSigned<U>()) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              min<U>(255, value)\n            );\n          } else if (sizeof<T>() <= 4) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value)\n            );\n          } else {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value)\n            );\n          }\n        }\n        // if U is a float, then casting float to int must include a finite check\n      } else if (isFloat<U>() && !isFloat<T>()) {\n        let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n        // @ts-ignore: cast to T is valid for numeric types here\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), isFinite<U>(value) ? <T>value : 0);\n      } else if (isFloat<T>() && !isFloat<U>()) {\n        // @ts-ignore: In this case the <T> conversion is required\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), <T>load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      } else {\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      }\n    }\n  }\n}\n',"util/casemap":"// Total tables size: ~5 kb (usually compressed to ~4 kb)\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/casemap.h\n\n// @ts-ignore: decorator\n@lazy @inline const TAB = memory.data<u8>([\n  7, 8, 9, 10, 11, 12, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  13, 6, 6, 14, 6, 6, 6, 6, 6, 6, 6, 6, 15, 16, 17, 18,\n  6, 19, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 20, 21, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 22, 23, 6, 6, 6, 24, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 25,\n  6, 6, 6, 6, 26, 6, 6, 6, 6, 6, 6, 6, 27, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 28, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 29, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36,\n  43, 43, 43, 43, 43, 43, 43, 43, 1, 0, 84, 86, 86, 86, 86, 86,\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 43, 43, 43, 43, 43, 43,\n  43, 7, 43, 43, 91, 86, 86, 86, 86, 86, 86, 86, 74, 86, 86, 5,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  36, 80, 121, 49, 80, 49, 80, 49, 56, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 78, 49, 2, 78, 13, 13, 78, 3,\n  78, 0, 36, 110, 0, 78, 49, 38, 110, 81, 78, 36, 80, 78, 57, 20,\n  129, 27, 29, 29, 83, 49, 80, 49, 80, 13, 49, 80, 49, 80, 49, 80,\n  27, 83, 36, 80, 49, 2, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123,\n  20, 121, 92, 123, 92, 123, 92, 45, 43, 73, 3, 72, 3, 120, 92, 123,\n  20, 0, 150, 10, 1, 43, 40, 6, 6, 0, 42, 6, 42, 42, 43, 7,\n  187, 181, 43, 30, 0, 43, 7, 43, 43, 43, 1, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 205, 70, 205, 43, 0, 37, 43, 7, 1, 6, 1, 85, 86, 86, 86,\n  86, 86, 85, 86, 86, 2, 36, 129, 129, 129, 129, 129, 21, 129, 129, 129,\n  0, 0, 43, 0, 178, 209, 178, 209, 178, 209, 178, 209, 0, 0, 205, 204,\n  1, 0, 215, 215, 215, 215, 215, 131, 129, 129, 129, 129, 129, 129, 129, 129,\n  129, 129, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 28, 0, 0, 0,\n  0, 0, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 2, 0, 0,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 78, 49, 80, 49, 80, 78, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 2, 135, 166, 135, 166, 135, 166, 135, 166,\n  135, 166, 135, 166, 135, 166, 135, 166, 42, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  12, 0, 12, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 7, 42, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 86, 86, 108, 129, 21, 0, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 7, 108, 3, 65, 43, 43, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 86, 86, 86, 44, 86, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 12, 108, 0, 0, 0, 0, 0, 6,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 86, 122, 158, 38, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 1, 43, 43, 79, 86,\n  86, 44, 43, 127, 86, 86, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\n  86, 44, 43, 127, 86, 86, 129, 55, 117, 91, 123, 92, 43, 43, 79, 86,\n  86, 2, 172, 4, 0, 0, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\n  86, 44, 43, 43, 86, 86, 50, 19, 129, 87, 0, 111, 129, 126, 201, 215,\n  126, 45, 129, 129, 14, 126, 57, 127, 111, 87, 0, 129, 129, 126, 21, 0,\n  126, 3, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 43,\n  36, 43, 151, 43, 43, 43, 43, 43, 43, 43, 43, 43, 42, 43, 43, 43,\n  43, 43, 86, 86, 86, 86, 86, 128, 129, 129, 129, 129, 57, 187, 42, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 1, 129, 129, 129, 129, 129, 129, 129, 129,\n  129, 129, 129, 129, 129, 129, 129, 201, 172, 172, 172, 172, 172, 172, 172, 172,\n  172, 172, 172, 172, 172, 172, 172, 208, 13, 0, 78, 49, 2, 180, 193, 193,\n  215, 215, 36, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 215, 215, 83, 193, 71, 212, 215, 215, 215, 5, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 1, 0, 1, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 13, 0, 0, 0, 0, 0, 36, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 121, 92, 123, 92, 123, 79, 123, 92, 123, 92, 123,\n  92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 45,\n  43, 43, 121, 20, 92, 123, 92, 45, 121, 42, 92, 39, 92, 123, 92, 123,\n  92, 123, 164, 0, 10, 180, 92, 123, 92, 123, 79, 3, 120, 56, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 79, 45, 43, 43, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 72, 86, 86, 86, 86,\n  86, 86, 86, 86, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 85, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 36, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 7, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 0,\n  0, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 86, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 86, 86,\n  86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 85,\n  86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const RULES = memory.data<i32>([\n  0x0, 0x2001, -0x2000, 0x1dbf00, 0x2e700, 0x7900,\n  0x2402, 0x101, -0x100, 0x0, 0x201, -0x200,\n  -0xc6ff, -0xe800, -0x78ff, -0x12c00, 0xc300, 0xd201,\n  0xce01, 0xcd01, 0x4f01, 0xca01, 0xcb01, 0xcf01,\n  0x6100, 0xd301, 0xd101, 0xa300, 0xd501, 0x8200,\n  0xd601, 0xda01, 0xd901, 0xdb01, 0x3800, 0x3,\n  -0x4f00, -0x60ff, -0x37ff, 0x242802, 0x0, 0x101,\n  -0x100, -0xcd00, -0xda00, -0x81ff, 0x2a2b01, -0xa2ff,\n  0x2a2801, 0x2a3f00, -0xc2ff, 0x4501, 0x4701, 0x2a1f00,\n  0x2a1c00, 0x2a1e00, -0xd200, -0xce00, -0xca00, -0xcb00,\n  0xa54f00, 0xa54b00, -0xcf00, 0xa52800, 0xa54400, -0xd100,\n  -0xd300, 0x29f700, 0xa54100, 0x29fd00, -0xd500, -0xd600,\n  0x29e700, 0xa54300, 0xa52a00, -0x4500, -0xd900, -0x4700,\n  -0xdb00, 0xa51500, 0xa51200, 0x4c2402, 0x0, 0x2001,\n  -0x2000, 0x101, -0x100, 0x5400, 0x7401, 0x2601,\n  0x2501, 0x4001, 0x3f01, -0x2600, -0x2500, -0x1f00,\n  -0x4000, -0x3f00, 0x801, -0x3e00, -0x3900, -0x2f00,\n  -0x3600, -0x800, -0x5600, -0x5000, 0x700, -0x7400,\n  -0x3bff, -0x6000, -0x6ff, 0x701a02, 0x101, -0x100,\n  0x2001, -0x2000, 0x5001, 0xf01, -0xf00, 0x0,\n  0x3001, -0x3000, 0x101, -0x100, 0x0, 0xbc000,\n  0x1c6001, 0x0, 0x97d001, 0x801, -0x800, 0x8a0502,\n  0x0, -0xbbfff, -0x186200, 0x89c200, -0x182500, -0x186e00,\n  -0x186d00, -0x186400, -0x186300, -0x185c00, 0x0, 0x8a3800,\n  0x8a0400, 0xee600, 0x101, -0x100, 0x0, -0x3b00,\n  -0x1dbeff, 0x8f1d02, 0x800, -0x7ff, 0x0, 0x5600,\n  -0x55ff, 0x4a00, 0x6400, 0x8000, 0x7000, 0x7e00,\n  0x900, -0x49ff, -0x8ff, -0x1c2500, -0x63ff, -0x6fff,\n  -0x7fff, -0x7dff, 0xac0502, 0x0, 0x1001, -0x1000,\n  0x1c01, 0x101, -0x1d5cff, -0x20beff, -0x2045ff, -0x1c00,\n  0xb10b02, 0x101, -0x100, 0x3001, -0x3000, 0x0,\n  -0x29f6ff, -0xee5ff, -0x29e6ff, -0x2a2b00, -0x2a2800, -0x2a1bff,\n  -0x29fcff, -0x2a1eff, -0x2a1dff, -0x2a3eff, 0x0, -0x1c6000,\n  0x0, 0x101, -0x100, 0xbc0c02, 0x0, 0x101,\n  -0x100, -0xa543ff, 0x3a001, -0x8a03ff, -0xa527ff, 0x3000,\n  -0xa54eff, -0xa54aff, -0xa540ff, -0xa511ff, -0xa529ff, -0xa514ff,\n  -0x2fff, -0xa542ff, -0x8a37ff, 0x0, -0x97d000, -0x3a000,\n  0x0, 0x2001, -0x2000, 0x0, 0x2801, -0x2800,\n  0x0, 0x4001, -0x4000, 0x0, 0x2001, -0x2000,\n  0x0, 0x2001, -0x2000, 0x0, 0x2201, -0x2200\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const RULE_BASES = memory.data<u8>([\n  0, 6, 39, 81, 111, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  124, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 131, 142, 146, 151,\n  0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 196, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 198, 201, 0, 0, 0, 219, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222,\n  0, 0, 0, 0, 225, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const EXCEPTIONS = memory.data<u8>([\n  48, 12,  49, 13,  120, 14,  127, 15,\n  128, 16,  129, 17,  134, 18,  137, 19,\n  138, 19,  142, 20,  143, 21,  144, 22,\n  147, 19,  148, 23,  149, 24,  150, 25,\n  151, 26,  154, 27,  156, 25,  157, 28,\n  158, 29,  159, 30,  166, 31,  169, 31,\n  174, 31,  177, 32,  178, 32,  183, 33,\n  191, 34,  197, 35,  200, 35,  203, 35,\n  221, 36,  242, 35,  246, 37,  247, 38,\n  32, 45,  58, 46,  61, 47,  62, 48,\n  63, 49,  64, 49,  67, 50,  68, 51,\n  69, 52,  80, 53,  81, 54,  82, 55,\n  83, 56,  84, 57,  89, 58,  91, 59,\n  92, 60,  97, 61,  99, 62,  101, 63,\n  102, 64,  104, 65,  105, 66,  106, 64,\n  107, 67,  108, 68,  111, 66,  113, 69,\n  114, 70,  117, 71,  125, 72,  130, 73,\n  135, 74,  137, 75,  138, 76,  139, 76,\n  140, 77,  146, 78,  157, 79,  158, 80,\n  69, 87,  123, 29,  124, 29,  125, 29,\n  127, 88,  134, 89,  136, 90,  137, 90,\n  138, 90,  140, 91,  142, 92,  143, 92,\n  172, 93,  173, 94,  174, 94,  175, 94,\n  194, 95,  204, 96,  205, 97,  206, 97,\n  207, 98,  208, 99,  209, 100,  213, 101,\n  214, 102,  215, 103,  240, 104,  241, 105,\n  242, 106,  243, 107,  244, 108,  245, 109,\n  249, 110,  253, 45,  254, 45,  255, 45,\n  80, 105,  81, 105,  82, 105,  83, 105,\n  84, 105,  85, 105,  86, 105,  87, 105,\n  88, 105,  89, 105,  90, 105,  91, 105,\n  92, 105,  93, 105,  94, 105,  95, 105,\n  130, 0,  131, 0,  132, 0,  133, 0,\n  134, 0,  135, 0,  136, 0,  137, 0,\n  192, 117,  207, 118,  128, 137,  129, 138,\n  130, 139,  133, 140,  134, 141,  112, 157,\n  113, 157,  118, 158,  119, 158,  120, 159,\n  121, 159,  122, 160,  123, 160,  124, 161,\n  125, 161,  179, 162,  186, 163,  187, 163,\n  188, 164,  190, 165,  195, 162,  204, 164,\n  218, 166,  219, 166,  229, 106,  234, 167,\n  235, 167,  236, 110,  243, 162,  248, 168,\n  249, 168,  250, 169,  251, 169,  252, 164,\n  38, 176,  42, 177,  43, 178,  78,  179,\n  132,  8,  98, 186,  99, 187,  100, 188,\n  101, 189,  102, 190,  109, 191,  110, 192,\n  111, 193,  112, 194,  126, 195,  127, 195,\n  125, 207,  141, 208,  148, 209,  171, 210,\n  172, 211,  173, 212,  176, 213,  177, 214,\n  178, 215,  196, 216,  197, 217,  198, 218\n]);\n\n/* Special Case Mappings\n * See: https://unicode.org/Public/UNIDATA/SpecialCasing.txt\n */\n\n/*\n@lazy @inline\nconst SPECIALS_LOWER: StaticArray<u16> = [\n  0x0130,  0x0069, 0x0307, 0x0000,\n];\n*/\n\n// @ts-ignore: decorator\n@lazy @inlne\nexport const SPECIALS_UPPER: StaticArray<u16> = [\n  // String#toUpperCase needs .length\n  0x00DF,  0x0053, 0x0053, 0x0000,\n  0x0149,  0x02BC, 0x004E, 0x0000,\n  0x01F0,  0x004A, 0x030C, 0x0000,\n  0x0390,  0x0399, 0x0308, 0x0301,\n  0x03B0,  0x03A5, 0x0308, 0x0301,\n  0x0587,  0x0535, 0x0552, 0x0000,\n  0x1E96,  0x0048, 0x0331, 0x0000,\n  0x1E97,  0x0054, 0x0308, 0x0000,\n  0x1E98,  0x0057, 0x030A, 0x0000,\n  0x1E99,  0x0059, 0x030A, 0x0000,\n  0x1E9A,  0x0041, 0x02BE, 0x0000,\n  0x1F50,  0x03A5, 0x0313, 0x0000,\n  0x1F52,  0x03A5, 0x0313, 0x0300,\n  0x1F54,  0x03A5, 0x0313, 0x0301,\n  0x1F56,  0x03A5, 0x0313, 0x0342,\n  0x1F80,  0x1F08, 0x0399, 0x0000,\n  0x1F81,  0x1F09, 0x0399, 0x0000,\n  0x1F82,  0x1F0A, 0x0399, 0x0000,\n  0x1F83,  0x1F0B, 0x0399, 0x0000,\n  0x1F84,  0x1F0C, 0x0399, 0x0000,\n  0x1F85,  0x1F0D, 0x0399, 0x0000,\n  0x1F86,  0x1F0E, 0x0399, 0x0000,\n  0x1F87,  0x1F0F, 0x0399, 0x0000,\n  0x1F88,  0x1F08, 0x0399, 0x0000,\n  0x1F89,  0x1F09, 0x0399, 0x0000,\n  0x1F8A,  0x1F0A, 0x0399, 0x0000,\n  0x1F8B,  0x1F0B, 0x0399, 0x0000,\n  0x1F8C,  0x1F0C, 0x0399, 0x0000,\n  0x1F8D,  0x1F0D, 0x0399, 0x0000,\n  0x1F8E,  0x1F0E, 0x0399, 0x0000,\n  0x1F8F,  0x1F0F, 0x0399, 0x0000,\n  0x1F90,  0x1F28, 0x0399, 0x0000,\n  0x1F91,  0x1F29, 0x0399, 0x0000,\n  0x1F92,  0x1F2A, 0x0399, 0x0000,\n  0x1F93,  0x1F2B, 0x0399, 0x0000,\n  0x1F94,  0x1F2C, 0x0399, 0x0000,\n  0x1F95,  0x1F2D, 0x0399, 0x0000,\n  0x1F96,  0x1F2E, 0x0399, 0x0000,\n  0x1F97,  0x1F2F, 0x0399, 0x0000,\n  0x1F98,  0x1F28, 0x0399, 0x0000,\n  0x1F99,  0x1F29, 0x0399, 0x0000,\n  0x1F9A,  0x1F2A, 0x0399, 0x0000,\n  0x1F9B,  0x1F2B, 0x0399, 0x0000,\n  0x1F9C,  0x1F2C, 0x0399, 0x0000,\n  0x1F9D,  0x1F2D, 0x0399, 0x0000,\n  0x1F9E,  0x1F2E, 0x0399, 0x0000,\n  0x1F9F,  0x1F2F, 0x0399, 0x0000,\n  0x1FA0,  0x1F68, 0x0399, 0x0000,\n  0x1FA1,  0x1F69, 0x0399, 0x0000,\n  0x1FA2,  0x1F6A, 0x0399, 0x0000,\n  0x1FA3,  0x1F6B, 0x0399, 0x0000,\n  0x1FA4,  0x1F6C, 0x0399, 0x0000,\n  0x1FA5,  0x1F6D, 0x0399, 0x0000,\n  0x1FA6,  0x1F6E, 0x0399, 0x0000,\n  0x1FA7,  0x1F6F, 0x0399, 0x0000,\n  0x1FA8,  0x1F68, 0x0399, 0x0000,\n  0x1FA9,  0x1F69, 0x0399, 0x0000,\n  0x1FAA,  0x1F6A, 0x0399, 0x0000,\n  0x1FAB,  0x1F6B, 0x0399, 0x0000,\n  0x1FAC,  0x1F6C, 0x0399, 0x0000,\n  0x1FAD,  0x1F6D, 0x0399, 0x0000,\n  0x1FAE,  0x1F6E, 0x0399, 0x0000,\n  0x1FAF,  0x1F6F, 0x0399, 0x0000,\n  0x1FB2,  0x1FBA, 0x0399, 0x0000,\n  0x1FB3,  0x0391, 0x0399, 0x0000,\n  0x1FB4,  0x0386, 0x0399, 0x0000,\n  0x1FB6,  0x0391, 0x0342, 0x0000,\n  0x1FB7,  0x0391, 0x0342, 0x0399,\n  0x1FBC,  0x0391, 0x0399, 0x0000,\n  0x1FC2,  0x1FCA, 0x0399, 0x0000,\n  0x1FC3,  0x0397, 0x0399, 0x0000,\n  0x1FC4,  0x0389, 0x0399, 0x0000,\n  0x1FC6,  0x0397, 0x0342, 0x0000,\n  0x1FC7,  0x0397, 0x0342, 0x0399,\n  0x1FCC,  0x0397, 0x0399, 0x0000,\n  0x1FD2,  0x0399, 0x0308, 0x0300,\n  0x1FD3,  0x0399, 0x0308, 0x0301,\n  0x1FD6,  0x0399, 0x0342, 0x0000,\n  0x1FD7,  0x0399, 0x0308, 0x0342,\n  0x1FE2,  0x03A5, 0x0308, 0x0300,\n  0x1FE3,  0x03A5, 0x0308, 0x0301,\n  0x1FE4,  0x03A1, 0x0313, 0x0000,\n  0x1FE6,  0x03A5, 0x0342, 0x0000,\n  0x1FE7,  0x03A5, 0x0308, 0x0342,\n  0x1FF2,  0x1FFA, 0x0399, 0x0000,\n  0x1FF3,  0x03A9, 0x0399, 0x0000,\n  0x1FF4,  0x038F, 0x0399, 0x0000,\n  0x1FF6,  0x03A9, 0x0342, 0x0000,\n  0x1FF7,  0x03A9, 0x0342, 0x0399,\n  0x1FFC,  0x03A9, 0x0399, 0x0000,\n  0xFB00,  0x0046, 0x0046, 0x0000,\n  0xFB01,  0x0046, 0x0049, 0x0000,\n  0xFB02,  0x0046, 0x004C, 0x0000,\n  0xFB03,  0x0046, 0x0046, 0x0049,\n  0xFB04,  0x0046, 0x0046, 0x004C,\n  0xFB05,  0x0053, 0x0054, 0x0000,\n  0xFB06,  0x0053, 0x0054, 0x0000,\n  0xFB13,  0x0544, 0x0546, 0x0000,\n  0xFB14,  0x0544, 0x0535, 0x0000,\n  0xFB15,  0x0544, 0x053B, 0x0000,\n  0xFB16,  0x054E, 0x0546, 0x0000,\n  0xFB17,  0x0544, 0x053D, 0x0000\n];\n\n// @ts-ignore: decorator\n@lazy @inline const MT = memory.data<i32>([\n  2048, 342, 57\n]);\n\n// Special binary search routine for Special Casing Tables\n// @ts-ignore: decorator\n@inline\nexport function bsearch(key: u32, ptr: usize, max: i32): i32 {\n  var min = 0;\n  while (min <= max) {\n    let mid = (min + max) >>> 3 << 2;\n    let cmp = load<u16>(ptr + (mid << alignof<u16>())) - key;\n    if (cmp == 0) return mid; // found\n    else if (cmp >>> 31) min = mid + 4; // < 0\n    else max = mid - 4; // > 0\n  }\n  return -1; // not found\n}\n\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/towctrans.c\nexport function casemap(c: u32, dir: i32): i32 {\n  // if (c >= 0x20000) return c;\n  var c0 = c as i32;\n  var b = c >> 8;\n  c &= 255;\n\n  var x = c / 3;\n  var y = c % 3;\n\n  /* lookup entry in two-level base-6 table */\n  // v = tab[(tab[b] as i32) * 86 + x] as u32;\n  var v = <usize>load<u8>(TAB + <usize>load<u8>(TAB + b) * 86 + x);\n  // v = (v * mt[y] >> 11) % 6;\n  v = (v * load<i32>(MT + (y << alignof<i32>())) >> 11) % 6;\n  /* use the bit vector out of the tables as an index into\n   * a block-specific set of rules and decode the rule into\n   * a type and a case-mapping delta. */\n  // r = rules[(ruleBases[b] as u32) + v];\n  var r = load<i32>(RULES + ((<usize>load<u8>(RULE_BASES + b) + v) << alignof<i32>()));\n  var rt: u32 = r & 255;\n  var rd: i32 = r >> 8;\n  /* rules 0/1 are simple lower/upper case with a delta.\n   * apply according to desired mapping direction. */\n  if (rt < 2) return c0 + (rd & -(rt ^ dir));\n  /* binary search. endpoints of the binary search for\n   * this block are stored in the rule delta field. */\n  var xn: u32 = rd & 0xff;\n  var xb: u32 = rd >>> 8;\n  while (xn) {\n    let h = xn >> 1;\n    // let t = exceptions[(xb + h) * 2 + 0] as u32;\n    let t = <u32>load<u8>(EXCEPTIONS + (xb + h) * 2, 0);\n    if (t == c) {\n      // r = rules[exceptions[(xb + h) * 2 + 1]];\n      r = load<i32>(RULES + <usize>(load<u8>(EXCEPTIONS + (xb + h) * 2, 1) << alignof<i32>()));\n      rt = r & 255;\n      rd = r >> 8;\n      if (rt < 2) return c0 + (rd & -(rt ^ dir));\n      /* Hard-coded for the four exceptional titlecase */\n      return c0 + 1 - (dir << 1); // (dir ? -1 : 1);\n    } else if (t > c) {\n      xn = h;\n    } else {\n      xb += h;\n      xn -= h;\n    }\n  }\n  return c0;\n}\n","util/error":'// Common error messages for use accross the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = "Index out of range";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = "Invalid length";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = "Illegal generic type";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = "Array is empty";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = "Element type must be nullable if array is holey";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = "Not implemented";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = "Key does not exist";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = "Allocation too large";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = "Object already pinned";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = "Object is not pinned";\n',"util/hash":"export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (key === null) return XXH32_SEED;\n\n  var h: u32 = key.length << 1;\n  var len: usize = h;\n  var pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  var end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","util/math":"//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  var kd = xd + shift;\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  var z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  var kd = <f64>(z + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = z - (kd - shift);\n  var s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  var top  = tmp & 0xFF800000;\n  var iz   = ux - top;\n  var k    = <i32>tmp >> 23;\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y  = A1 * r + A2;\n  var p  = A3 * r + y0;\n  var r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ux - 0x3F330000;\n  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  var k   = <i32>tmp >> 23;\n  var iz  = ux - (tmp & 0x1FF << 23);\n\n  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  var z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  var r = z * invc - 1;\n  var y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  var r2 = r * r;\n  var y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  var e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  var top  = tmp & 0xFF800000;\n  var uz   = ux - top;\n  var k    = <i32>(<i32>top >> 23);\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y = A0 * r + A1;\n  var p = A2 * r + A3;\n  var q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  var kd = <f64>(xd + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  var signBias: u32 = 0;\n  var ix = reinterpret<u32>(x);\n  var iy = reinterpret<u32>(y);\n  var ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return iy >> 31 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (ix >> 31) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  var logx = log2f_inline(ix);\n  var ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  var scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  var y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7FF);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      return select<f64>(0, Infinity, ux >> 63);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  var z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // var kd = z + shift;\n  // var ki = reinterpret<u64>(kd) >> 16;\n  // var kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  var kd = z + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  var r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  var scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  var y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7ff);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (!(ux >> 63)) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  var kd = x + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  var r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  var top = <u32>(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & 0xFFF0000000000000);\n\n  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n  var kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  var r   = (z - chi - clo) * invc;\n  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  var rlo = r - rhi;\n  var t1  = rhi * InvLn2hi;\n  var t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  var t3 = kd + logc;\n  var hi = t3 + t1;\n  var lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  var top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  var r = (z - chi - clo) * invc;\n  // #endif\n  var kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  var w  = kd * Ln2hi + logc;\n  var hi = w + r;\n  var lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  var e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy var log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ix - 0x3fE6955500000000;\n  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  var k   = <i64>tmp >> 52;\n  var iz  = ix - (tmp & u64(0xFFF) << 52);\n  var z   = reinterpret<f64>(iz);\n  var kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  var zlo = z - zhi;\n  var rhi = zhi * invc - 1.0;\n  var rlo = zlo * invc;\n  var r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  var t1  = kd * Ln2hi + logc;\n  var t2  = t1 + r;\n  var lo1 = kd * Ln2lo + logctail;\n  var lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var ar  = A0 * r; // A[0] = -0.5\n  var ar2 = r * ar;\n  var ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  var arhi  = A0  * rhi;\n  var arhi2 = rhi * arhi;\n  var hi    = t2  + arhi2;\n  var lo3   = rlo * (ar + arhi);\n  var lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  var lo = lo1 + lo2 + lo3 + lo4 + p;\n  var y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var abstop: u32;\n  var ki: u64, top: u64, sbits: u64;\n  var idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  var ux = reinterpret<u64>(x);\n  abstop = <u32>(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = <usize>((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var sign_bias: u32 = 0;\n  var ix = reinterpret<u64>(x);\n  var iy = reinterpret<u64>(y);\n  var topx = ix >> 52;\n  var topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return iy >> 63 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (ix >> 63) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  var hi = log_inline(ix);\n  var lo = log_tail;\n  var ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  var ylo = y - yhi;\n  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  var llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","util/memory":"export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n - 4;\n    store<u8>(dest, c);\n    store<u8>(dend, c, 3);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend, c, 2);\n    store<u8>(dend, c, 1);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n - 28;\n    store<u32>(dest, c32);\n    store<u32>(dend, c32, 24);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend, c32, 16);\n    store<u32>(dend, c32, 20);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend, c32);\n    store<u32>(dend, c32, 4);\n    store<u32>(dend, c32, 8);\n    store<u32>(dend, c32, 12);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","util/number":'/// <reference path="../rt/index.d.ts" />\n\nimport { idof } from "../builtins";\nimport { CharCode } from "./string";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  "00", "01", "02", "03", "04", "05", "06", "07", "08", "09",\n  "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",\n  "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",\n  "30", "31", "32", "33", "34", "35", "36", "37", "38", "39",\n  "40", "41", "42", "43", "44", "45", "46", "47", "48", "49",\n  "50", "51", "52", "53", "54", "55", "56", "57", "58", "59",\n  "60", "61", "62", "63", "64", "65", "66", "67", "68", "69",\n  "70", "71", "72", "73", "74", "75", "76", "77", "78", "79",\n  "80", "81", "82", "83", "84", "85", "86", "87", "88", "89",\n  "90", "91", "92", "93", "94", "95", "96", "97", "98", "99"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = "0123456789abcdefghijklmnopqrstuvwxyz";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  var b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  var base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError("toString() radix argument must be between 2 and 36");\n  }\n  if (!value) return "0";\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError("toString() radix argument must be between 2 and 36");\n  }\n  if (!value) return "0";\n\n  var sign = value >>> 31;\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError("toString() radix argument must be between 2 and 36");\n  }\n  if (!value) return "0";\n  var out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError("toString() radix argument must be between 2 and 36");\n  }\n  if (!value) return "0";\n\n  var sign = u32(value >>> 63);\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy var _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp, exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n\n  var p1 = u32(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return "0.0";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return "NaN";\n    return select<String>("-Infinity", "Infinity", value < 0);\n  }\n  var size = dtoa_core(dtoa_buf, value) << 1;\n  var result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  var sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      value = changetype<T>(-value);\n      store<u16>(buffer, CharCode.MINUS);\n    }\n  }\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  var decimals = sign;\n  if (sizeof<T>() <= 4) {\n    decimals += decimalCount32(value);\n    utoa32_dec_core(buffer, value, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals += decimalCount32(val32);\n      utoa32_dec_core(buffer, val32, decimals);\n    } else {\n      decimals += decimalCount64High(value);\n      utoa64_dec_core(buffer, value, decimals);\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n',"util/sort":'import { compareImpl } from "./string";\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): (a: T, b: T) => i32 {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a: T, b: T): i32 => (i32(a) - i32(b));\n    } else {\n      return (a: T, b: T): i32 => (i32(a > b) - i32(a < b));\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a: T, b: T): i32 => {\n        var ia = reinterpret<i32>(f32(a));\n        var ib = reinterpret<i32>(f32(b));\n        ia ^= (ia >> 31) >>> 1;\n        ib ^= (ib >> 31) >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a: T, b: T): i32 => {\n        var ia = reinterpret<i64>(f64(a));\n        var ib = reinterpret<i64>(f64(b));\n        ia ^= (ia >> 63) >>> 1;\n        ib ^= (ib >> 63) >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a: T, b: T): i32 => {\n      if (a === b || a === null || b === null) return 0;\n      var alen = changetype<string>(a).length;\n      var blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(changetype<string>(a), 0, changetype<string>(b), 0, <usize>min(alen, blen));\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a: T, b: T): i32 => (i32(a > b) - i32(a < b));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function SORT<T>(\n  dataStart: usize,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  if (isReference<T>()) {\n    // TODO replace this to faster stable sort (TimSort) when it implemented\n    insertionSort<T>(dataStart, length, comparator);\n  } else {\n    if (length < 256) {\n      insertionSort<T>(dataStart, length, comparator);\n    } else {\n      weakHeapSort<T>(dataStart, length, comparator);\n    }\n  }\n}\n\nfunction insertionSort<T>(\n  dataStart: usize,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  for (let i = 0; i < length; i++) {\n    let a: T = load<T>(dataStart + (<usize>i << alignof<T>())); // a = arr[i]\n    let j = i - 1;\n    while (j >= 0) {\n      let b: T = load<T>(dataStart + (<usize>j << alignof<T>())); // b = arr[j]\n      if (comparator(a, b) < 0) {\n        store<T>(dataStart + (<usize>(j-- + 1) << alignof<T>()), b); // arr[j + 1] = b\n      } else break;\n    }\n    store<T>(dataStart + (<usize>(j + 1) << alignof<T>()), a); // arr[j + 1] = a\n  }\n}\n\nfunction weakHeapSort<T>(\n  dataStart: usize,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  const shift32 = alignof<u32>();\n\n  var bitsetSize = (<usize>length + 31) >> 5 << shift32;\n  var bitset = __alloc(bitsetSize); // indexed in 32-bit chunks below\n  memory.fill(bitset, 0, bitsetSize);\n\n  // see: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.21.1863&rep=rep1&type=pdf\n\n  for (let i = length - 1; i > 0; i--) {\n    let j = i;\n    while ((j & 1) == (load<u32>(bitset + (<usize>j >> 6 << shift32)) >> (j >> 1 & 31) & 1)) j >>= 1;\n\n    let p = j >> 1;\n    let a: T = load<T>(dataStart + (<usize>p << alignof<T>())); // a = arr[p]\n    let b: T = load<T>(dataStart + (<usize>i << alignof<T>())); // b = arr[i]\n    if (comparator(a, b) < 0) {\n      store<u32>(\n        bitset + (<usize>i >> 5 << shift32),\n        load<u32>(bitset + (<usize>i >> 5 << shift32)) ^ (1 << (i & 31))\n      );\n      store<T>(dataStart + (<usize>i << alignof<T>()), a); // arr[i] = a\n      store<T>(dataStart + (<usize>p << alignof<T>()), b); // arr[p] = b\n    }\n  }\n\n  for (let i = length - 1; i >= 2; i--) {\n    let a: T = load<T>(dataStart); // a = arr[0]\n    store<T>(dataStart, load<T>(dataStart + (<usize>i << alignof<T>()))); // arr[0] = arr[i]\n    store<T>(dataStart + (<usize>i << alignof<T>()), a); // arr[i] = a\n\n    let x = 1, y: i32;\n    while ((y = (x << 1) + ((load<u32>(bitset + (<usize>x >> 5 << shift32)) >> (x & 31)) & 1)) < i) x = y;\n\n    while (x > 0) {\n      a = load<T>(dataStart); // a = arr[0]\n      let b: T = load<T>(dataStart + (<usize>x << alignof<T>())); // b = arr[x]\n\n      if (comparator(a, b) < 0) {\n        store<u32>(\n          bitset + (<usize>x >> 5 << shift32),\n          load<u32>(bitset + (<usize>x >> 5 << shift32)) ^ (1 << (x & 31))\n        );\n        store<T>(dataStart + (<usize>x << alignof<T>()), a); // arr[x] = a\n        store<T>(dataStart, b); // arr[0] = b\n      }\n      x >>= 1;\n    }\n  }\n\n  __free(bitset);\n\n  var t: T = load<T>(dataStart, sizeof<T>()); // t = arr[1]\n  store<T>(dataStart, load<T>(dataStart), sizeof<T>()); // arr[1] = arr[0]\n  store<T>(dataStart, t); // arr[0] = t\n}\n',"util/string":'import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from "./number";\nimport { ipow32 } from "../math";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can\'t be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    // @ts-ignore: cast\n    return ((c | 0x80) == 0xA0) | (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  var found = false;\n  var pos = index;\n  var minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  var maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  var c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  var sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt("0xFF", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (!num) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse \'-\' or \'+\'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return "";\n  if (!lastIndex) return select("true", "false", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len("false")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select("true", "false", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select("true", "false", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return "";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return "";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return "";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || "";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    // @ts-ignore: type\n    if (value !== null) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (value !== null) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (value !== null) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return "";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value !== null ? value.toString() : "";\n  }\n  var result = "";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value !== null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value !== null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is \'e\' or \'E\'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy var __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n',vector:"/** Vector abstraction. */\n@final @unmanaged\nexport abstract class V128 {\n}\n","wasi/index":"import {\n  proc_exit,\n  fd_write,\n  iovec,\n  random_get\n} from \"bindings/wasi\";\n\nimport {\n  MAX_DOUBLE_LENGTH,\n  decimalCount32,\n  dtoa_buffered\n} from \"util/number\";\n\n// @ts-ignore: decorator\n@global @inline const ASC_WASI = true; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nfunction abort( // eslint-disable-line @typescript-eslint/no-unused-vars\n  message: string | null = null,\n  fileName: string | null = null,\n  lineNumber: u32 = 0,\n  columnNumber: u32 = 0\n): void {\n  // 0: iov.buf\n  // 4: iov.buf_len\n  // 8: len\n  // 12: buf...\n  const iovPtr: usize = 0;\n  const lenPtr: usize = iovPtr + offsetof<iovec>();\n  const bufPtr: usize = lenPtr + sizeof<usize>();\n  changetype<iovec>(iovPtr).buf = bufPtr;\n  var ptr = bufPtr;\n  store<u64>(ptr, 0x203A74726F6261); ptr += 7; // 'abort: '\n  if (message !== null) {\n    ptr += String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, ptr);\n  }\n  store<u32>(ptr, 0x206E6920); ptr += 4; // ' in '\n  if (fileName !== null) {\n    ptr += String.UTF8.encodeUnsafe(changetype<usize>(fileName), fileName.length, ptr);\n  }\n  store<u8>(ptr++, 0x28); // (\n  var len = decimalCount32(lineNumber); ptr += len;\n  do {\n    let t = lineNumber / 10;\n    store<u8>(--ptr, 0x30 + lineNumber % 10);\n    lineNumber = t;\n  } while (lineNumber); ptr += len;\n  store<u8>(ptr++, 0x3A); // :\n  len = decimalCount32(columnNumber); ptr += len;\n  do {\n    let t = columnNumber / 10;\n    store<u8>(--ptr, 0x30 + columnNumber % 10);\n    columnNumber = t;\n  } while (columnNumber); ptr += len;\n  store<u16>(ptr, 0x0A29); ptr += 2; // )\\n\n  changetype<iovec>(iovPtr).buf_len = ptr - bufPtr;\n  fd_write(2, iovPtr, 1, lenPtr);\n  proc_exit(255);\n}\n\nfunction trace( // eslint-disable-line @typescript-eslint/no-unused-vars\n  message: string,\n  n: i32 = 0,\n  a0: f64 = 0,\n  a1: f64 = 0,\n  a2: f64 = 0,\n  a3: f64 = 0,\n  a4: f64 = 0\n): void {\n  // 0: iov.buf\n  // 4: iov.buf_len\n  // 8: len\n  // 12: buf...\n  var iovPtr = __alloc(offsetof<iovec>() + sizeof<usize>() + 1 + <usize>(max(String.UTF8.byteLength(message), MAX_DOUBLE_LENGTH << 1)));\n  var lenPtr = iovPtr + offsetof<iovec>();\n  var bufPtr = lenPtr + sizeof<usize>();\n  changetype<iovec>(iovPtr).buf = bufPtr;\n  store<u64>(bufPtr, 0x203A6563617274); // 'trace: '\n  changetype<iovec>(iovPtr).buf_len = 7;\n  fd_write(2, iovPtr, 1, lenPtr);\n  changetype<iovec>(iovPtr).buf_len = String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, bufPtr);\n  fd_write(2, iovPtr, 1, lenPtr);\n  if (n) {\n    store<u8>(bufPtr++, 0x20); // space\n    changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a0), bufPtr);\n    fd_write(2, iovPtr, 1, lenPtr);\n    if (n > 1) {\n      changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a1), bufPtr);\n      fd_write(2, iovPtr, 1, lenPtr);\n      if (n > 2) {\n        changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a2), bufPtr);\n        fd_write(2, iovPtr, 1, lenPtr);\n        if (n > 3) {\n          changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a3), bufPtr);\n          fd_write(2, iovPtr, 1, lenPtr);\n          if (n > 4) {\n            changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a4), bufPtr);\n            fd_write(2, iovPtr, 1, lenPtr);\n          }\n        }\n      }\n    }\n    --bufPtr;\n  }\n  store<u8>(bufPtr, 0x0A); // \\n\n  changetype<iovec>(iovPtr).buf_len = 1;\n  fd_write(2, iovPtr, 1, lenPtr);\n  __free(iovPtr);\n}\n\nfunction seed(): f64 { // eslint-disable-line @typescript-eslint/no-unused-vars\n  var temp = load<u64>(0);\n  var rand: u64;\n  do {\n    random_get(0, 8); // to be sure\n    rand = load<u64>(0);\n  } while (!rand);\n  store<u64>(0, temp);\n  return reinterpret<f64>(rand);\n}\n\nexport * from \"bindings/wasi\";\n"}:(()=>{const e=i.join(".","..","std","assembly"),n={};return p.files(e,m.re_except_d).forEach((t=>{n[t.replace(m.re,"")]=r.readFileSync(i.join(e,t),"utf8")})),n})(),n.definitionFiles=n.isBundle?{assembly:'/**\n * Environment definitions for compiling AssemblyScript to WebAssembly using asc.\n * @module std/assembly\n *//***/\n\n/// <reference no-default-lib="true"/>\n\n// Types\n\n/** An 8-bit signed integer. */\ndeclare type i8 = number;\n/** A 16-bit signed integer. */\ndeclare type i16 = number;\n/** A 32-bit signed integer. */\ndeclare type i32 = number;\n/** A 64-bit signed integer. */\ndeclare type i64 = number;\n/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */\ndeclare type isize = number;\n/** An 8-bit unsigned integer. */\ndeclare type u8 = number;\n/** A 16-bit unsigned integer. */\ndeclare type u16 = number;\n/** A 32-bit unsigned integer. */\ndeclare type u32 = number;\n/** A 64-bit unsigned integer. */\ndeclare type u64 = number;\n/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */\ndeclare type usize = number;\n/** A 1-bit unsigned integer. */\ndeclare type bool = boolean | number;\n/** A 32-bit float. */\ndeclare type f32 = number;\n/** A 64-bit float. */\ndeclare type f64 = number;\n/** A 128-bit vector. */\ndeclare type v128 = object;\n/** Function reference. */\ndeclare type funcref = object | null;\n/** External reference. */\ndeclare type externref = object | null;\n/** Exception reference. */\ndeclare type exnref = object | null;\n/** Any reference. */\ndeclare type anyref = object | null;\n\n// Compiler hints\n\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\ndeclare const ASC_TARGET: i32;\n/** Provided noAssert option. */\ndeclare const ASC_NO_ASSERT: bool;\n/** Provided memoryBase option. */\ndeclare const ASC_MEMORY_BASE: i32;\n/** Provided tableBase option. */\ndeclare const ASC_TABLE_BASE: i32;\n/** Provided optimizeLevel option. */\ndeclare const ASC_OPTIMIZE_LEVEL: i32;\n/** Provided shrinkLevel option. */\ndeclare const ASC_SHRINK_LEVEL: i32;\n/** Provided lowMemoryLimit option. */\ndeclare const ASC_LOW_MEMORY_LIMIT: i32;\n/** Provided noExportRuntime option. */\ndeclare const ASC_NO_EXPORT_RUNTIME: i32;\n/** Whether the sign extension feature is enabled. */\ndeclare const ASC_FEATURE_SIGN_EXTENSION: bool;\n/** Whether the mutable globals feature is enabled. */\ndeclare const ASC_FEATURE_MUTABLE_GLOBALS: bool;\n/** Whether the non-trapping float-to-int feature is enabled. */\ndeclare const ASC_FEATURE_NONTRAPPING_F2I: bool;\n/** Whether the bulk memory feature is enabled. */\ndeclare const ASC_FEATURE_BULK_MEMORY: bool;\n/** Whether the SIMD feature is enabled. */\ndeclare const ASC_FEATURE_SIMD: bool;\n/** Whether the threads feature is enabled. */\ndeclare const ASC_FEATURE_THREADS: bool;\n/** Whether the exception handling feature is enabled. */\ndeclare const ASC_FEATURE_EXCEPTION_HANDLING: bool;\n/** Whether the tail calls feature is enabled. */\ndeclare const ASC_FEATURE_TAIL_CALLS: bool;\n/** Whether the reference types feature is enabled. */\ndeclare const ASC_FEATURE_REFERENCE_TYPES: bool;\n/** Whether the multi value types feature is enabled. */\ndeclare const ASC_FEATURE_MULTI_VALUE: bool;\n/** Whether the garbage collection feature is enabled. */\ndeclare const ASC_FEATURE_GC: bool;\n/** Whether the memory64 feature is enabled. */\ndeclare const ASC_FEATURE_MEMORY64: bool;\n\n// Builtins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */\ndeclare function popcnt<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */\ndeclare function rotl<T = i32 | i64>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */\ndeclare function rotr<T = i32 | i64>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | i64 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */\ndeclare function reinterpret<T = i32 | i64 | f32 | f64>(value: number): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Computes the sum of two integers or floats. */\ndeclare function add<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Computes the difference of two integers or floats. */\ndeclare function sub<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Computes the product of two integers or floats. */\ndeclare function mul<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Computes the quotient of two integers or floats. */\ndeclare function div<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */\ndeclare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */\ndeclare function store<T>(ptr: usize, value: T, immOffset?: usize, immAlign?: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression. */\ndeclare function unreachable(): never;\n\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\ndeclare const NaN: f32 | f64;\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\ndeclare const Infinity: f32 | f64;\n/** Data end offset. */\ndeclare const __data_end: usize;\n/** Stack pointer offset. */\ndeclare var __stack_pointer: usize;\n/** Heap base offset. */\ndeclare const __heap_base: usize;\n/** Determines the byte size of the specified underlying core type. Compiles to a constant. */\ndeclare function sizeof<T>(): usize;\n/** Determines the alignment (log2) of the specified underlying core type. Compiles to a constant. */\ndeclare function alignof<T>(): usize;\n/** Determines the end offset of the given class type. Compiles to a constant. */\ndeclare function offsetof<T>(): usize;\n/** Determines the offset of the specified field within the given class type. Compiles to a constant. */\ndeclare function offsetof<T>(fieldName: keyof T | string): usize;\n/** Determines the offset of the specified field within the given class type. Returns the class type\'s end offset if field name has been omitted. Compiles to a constant. */\ndeclare function offsetof<T>(fieldName?: string): usize;\n/** Determines the name of a given type. */\ndeclare function nameof<T>(value?: T): string;\n/** Determines the unique runtime id of a class type. Compiles to a constant. */\ndeclare function idof<T>(): u32;\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\ndeclare function unchecked<T>(value: T): T;\n/** Emits a `call_indirect` instruction, calling the specified function in the function table by index with the specified arguments. Does result in a runtime error if the arguments do not match the called function. */\ndeclare function call_indirect<T>(index: u32, ...args: unknown[]): T;\n/** Instantiates a new instance of `T` using the specified constructor arguments. */\ndeclare function instantiate<T>(...args: any[]): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Tests if the specified type *or* expression is of an integer type and not a reference. Compiles to a constant. */\ndeclare function isInteger<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression is of a float type. Compiles to a constant. */\ndeclare function isFloat<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression is of a boolean type. */\ndeclare function isBoolean<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression can represent negative numbers. Compiles to a constant. */\ndeclare function isSigned<T>(value?: any): value is number;\n/** Tests if the specified type *or* expression is of a reference type. Compiles to a constant. */\ndeclare function isReference<T>(value?: any): value is object | string;\n/** Tests if the specified type *or* expression can be used as a string. Compiles to a constant. */\ndeclare function isString<T>(value?: any): value is string | String;\n/** Tests if the specified type *or* expression can be used as an array. Compiles to a constant. */\ndeclare function isArray<T>(value?: any): value is Array<any>;\n/** Tests if the specified type *or* expression can be used as an array like object. Compiles to a constant. */\ndeclare function isArrayLike<T>(value?: any): value is ArrayLike<any>;\n/** Tests if the specified type *or* expression is of a function type. Compiles to a constant. */\ndeclare function isFunction<T>(value?: any): value is (...args: any) => any;\n/** Tests if the specified type *or* expression is of a nullable reference type. Compiles to a constant. */\ndeclare function isNullable<T>(value?: any): bool;\n/** Tests if the specified expression resolves to a defined element. Compiles to a constant. */\ndeclare function isDefined(expression: any): bool;\n/** Tests if the specified expression evaluates to a constant value. Compiles to a constant. */\ndeclare function isConstant(expression: any): bool;\n/** Tests if the specified type *or* expression is of a managed type. Compiles to a constant. */\ndeclare function isManaged<T>(value?: any): bool;\n/** Tests if the specified type is void. Compiles to a constant. */\ndeclare function isVoid<T>(): bool;\n/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses a string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n/** Returns the 64-bit floating-point remainder of `x/y`. */\ndeclare function fmod(x: f64, y: f64): f64;\n/** Returns the 32-bit floating-point remainder of `x/y`. */\ndeclare function fmodf(x: f32, y: f32): f32;\n/** Returns the number of parameters in the given function signature type. */\ndeclare function lengthof<T extends (...args: any[]) => any>(func?: T): i32;\n\n/** Atomic operations. */\ndeclare namespace atomic {\n  /** Atomically loads an integer value from memory and returns it. */\n  export function load<T>(ptr: usize, immOffset?: usize): T;\n  /** Atomically stores an integer value to memory. */\n  export function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n  /** Atomically adds an integer value in memory. */\n  export function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically subtracts an integer value in memory. */\n  export function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically performs a bitwise AND operation on an integer value in memory. */\n  export function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically performs a bitwise OR operation on an integer value in memory. */\n  export function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically performs a bitwise XOR operation on an integer value in memory. */\n  export function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically exchanges an integer value in memory. */\n  export function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n  /** Atomically compares and exchanges an integer value in memory if the condition is met. */\n  export function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n  /** Performs a wait operation on an address in memory suspending this agent if the integer condition is met. */\n  export function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n  /** Performs a notify operation on an address in memory waking up suspended agents. */\n  export function notify(ptr: usize, count: i32): i32;\n  /** Performs a fence operation, preserving synchronization guarantees of higher level languages. */\n  export function fence(): void;\n}\n\n/** Describes the result of an atomic wait operation. */\ndeclare enum AtomicWaitResult {\n  /** Woken by another agent. */\n  OK,\n  /** Loaded value did not match the expected value. */\n  NOT_EQUAL,\n  /** Not woken before the timeout expired. */\n  TIMED_OUT\n}\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: any): i8;\ndeclare namespace i8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i8;\n  /** Largest representable value. */\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: any): i8;\ndeclare namespace i16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i16;\n  /** Largest representable value. */\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: any): i32;\ndeclare namespace i32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i32;\n  /** Largest representable value. */\n  export const MAX_VALUE: i32;\n  /** Loads an 8-bit signed integer value from memory and returns it as a 32-bit integer. */\n  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */\n  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Loads a 16-bit signed integer value from memory and returns it as a 32-bit integer. */\n  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */\n  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Loads a 32-bit integer value from memory. */\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n  /** Stores a 32-bit integer value to memory as an 8-bit integer. */\n  export function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 32-bit integer value to memory as a 16-bit integer. */\n  export function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 32-bit integer value to memory. */\n  export function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  /** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\n  export function clz(value: i32): i32;\n  /** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */\n  export function ctz(value: i32): i32;\n  /** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */\n  export function popcnt(value: i32): i32;\n  /** Performs the sign-agnostic rotate left operation on a 32-bit integer. */\n  export function rotl(value: i32, shift: i32): i32;\n  /** Performs the sign-agnostic rotate right operation on a 32-bit integer. */\n  export function rotr(value: i32, shift: i32): i32;\n  /** Reinterprets the bits of the specified 32-bit float as a 32-bit integer. */\n  export function reinterpret_f32(value: f32): i32;\n  /** Computes the sum of two 32-bit integers. */\n  export function add(left: i32, right: i32): i32;\n  /** Computes the difference of two 32-bit integers. */\n  export function sub(left: i32, right: i32): i32;\n  /** Computes the product of two 32-bit integers. */\n  export function mul(left: i32, right: i32): i32;\n  /** Computes the signed quotient of two 32-bit integers. */\n  export function div_s(left: i32, right: i32): i32;\n  /** Computes the unsigned quotient of two 32-bit integers. */\n  export function div_u(left: i32, right: i32): i32;\n  /** Atomic 32-bit integer operations. */\n  export namespace atomic {\n    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */\n    export function load8_u(ptr: usize, immOffset?: usize): i32;\n    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */\n    export function load16_u(ptr: usize, immOffset?: usize): i32;\n    /** Atomically loads a 32-bit integer value from memory and returns it. */\n    export function load(ptr: usize, immOffset?: usize): i32;\n    /** Atomically stores a 32-bit integer value to memory as an 8-bit integer. */\n    export function store8(ptr: usize, value: i32, immOffset?: usize): void;\n    /** Atomically stores a 32-bit integer value to memory as a 16-bit integer. */\n    export function store16(ptr: usize, value: i32, immOffset?: usize): void;\n    /** Atomically stores a 32-bit integer value to memory. */\n    export function store(ptr: usize, value: i32, immOffset?: usize): void;\n    /** Performs a wait operation on a 32-bit integer value in memory suspending this agent if the condition is met. */\n    export function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n    /** Atomic 32-bit integer read-modify-write operations on 8-bit values. */\n    export namespace rmw8 {\n      /** Atomically adds an 8-bit unsigned integer value in memory. */\n      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically subtracts an 8-bit unsigned integer value in memory. */\n      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise AND operation an 8-bit unsigned integer value in memory. */\n      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise OR operation an 8-bit unsigned integer value in memory. */\n      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise XOR operation an 8-bit unsigned integer value in memory. */\n      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically exchanges an 8-bit unsigned integer value in memory. */\n      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    /** Atomic 32-bit integer read-modify-write operations on 16-bit values. */\n    export namespace rmw16 {\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\n      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\n      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise AND operation a 16-bit unsigned integer value in memory. */\n      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise OR operation a 16-bit unsigned integer value in memory. */\n      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise XOR operation a 16-bit unsigned integer value in memory. */\n      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically exchanges a 16-bit unsigned integer value in memory. */\n      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    /** Atomic 32-bit integer read-modify-write operations. */\n    export namespace rmw {\n      /** Atomically adds a 32-bit integer value in memory. */\n      export function add(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically subtracts a 32-bit integer value in memory. */\n      export function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise AND operation a 32-bit integer value in memory. */\n      export function and(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise OR operation a 32-bit integer value in memory. */\n      export function or(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically performs a bitwise XOR operation a 32-bit integer value in memory. */\n      export function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically exchanges a 32-bit integer value in memory. */\n      export function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n      /** Atomically compares and exchanges a 32-bit integer value in memory if the condition is met. */\n      export function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n/** Converts any other numeric value to a 64-bit signed integer. */\ndeclare function i64(value: any): i64;\ndeclare namespace i64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i64;\n  /** Largest representable value. */\n  export const MAX_VALUE: i64;\n  /** Loads an 8-bit signed integer value from memory and returns it as a 64-bit integer. */\n  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 16-bit signed integer value from memory and returns it as a 64-bit integer. */\n  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 32-bit signed integer value from memory and returns it as a 64-bit integer. */\n  export function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n  export function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Loads a 64-bit unsigned integer value from memory. */\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n  /** Stores a 64-bit integer value to memory as an 8-bit integer. */\n  export function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 64-bit integer value to memory as a 16-bit integer. */\n  export function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 64-bit integer value to memory as a 32-bit integer. */\n  export function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  /** Stores a 64-bit integer value to memory. */\n  export function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  /** Performs the sign-agnostic count leading zero bits operation on a 64-bit integer. All zero bits are considered leading if the value is zero. */\n  export function clz(value: i64): i64;\n  /** Performs the sign-agnostic count tailing zero bits operation on a 64-bit integer. All zero bits are considered trailing if the value is zero. */\n  export function ctz(value: i64): i64;\n  /** Performs the sign-agnostic count number of one bits operation on a 64-bit integer. */\n  export function popcnt(value: i64): i64;\n  /** Performs the sign-agnostic rotate left operation on a 64-bit integer. */\n  export function rotl(value: i64, shift: i64): i64;\n  /** Performs the sign-agnostic rotate right operation on a 64-bit integer. */\n  export function rotr(value: i64, shift: i64): i64;\n  /** Reinterprets the bits of the specified 64-bit float as a 64-bit integer. */\n  export function reinterpret_f64(value: f64): i64;\n  /** Computes the sum of two 64-bit integers. */\n  export function add(left: i64, right: i64): i64;\n  /** Computes the difference of two 64-bit integers. */\n  export function sub(left: i64, right: i64): i64;\n  /** Computes the product of two 64-bit integers. */\n  export function mul(left: i64, right: i64): i64;\n  /** Computes the signed quotient of two 64-bit integers. */\n  export function div_s(left: i64, right: i64): i64;\n  /** Computes the unsigned quotient of two 64-bit integers. */\n  export function div_u(left: i64, right: i64): i64;\n  /** Atomic 64-bit integer operations. */\n  export namespace atomic {\n    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n    export function load8_u(ptr: usize, immOffset?: usize): i64;\n    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n    export function load16_u(ptr: usize, immOffset?: usize): i64;\n    /** Atomically loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */\n    export function load32_u(ptr: usize, immOffset?: usize): i64;\n    /** Atomically loads a 64-bit integer value from memory and returns it. */\n    export function load(ptr: usize, immOffset?: usize): i64;\n    /** Atomically stores a 64-bit integer value to memory as an 8-bit integer. */\n    export function store8(ptr: usize, value: i64, immOffset?: usize): void;\n    /** Atomically stores a 64-bit integer value to memory as a 16-bit integer. */\n    export function store16(ptr: usize, value: i64, immOffset?: usize): void;\n    /** Atomically stores a 64-bit integer value to memory as a 32-bit integer. */\n    export function store32(ptr: usize, value: i64, immOffset?: usize): void;\n    /** Atomically stores a 64-bit integer value to memory. */\n    export function store(ptr: usize, value: i64, immOffset?: usize): void;\n    /** Performs a wait operation on a 64-bit integer value in memory suspending this agent if the condition is met. */\n    export function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n    /** Atomic 64-bit integer read-modify-write operations on 8-bit values. */\n    export namespace rmw8 {\n      /** Atomically adds an 8-bit unsigned integer value in memory. */\n      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically subtracts an 8-bit unsigned integer value in memory. */\n      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise AND operation on an 8-bit unsigned integer value in memory. */\n      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise OR operation on an 8-bit unsigned integer value in memory. */\n      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise XOR operation on an 8-bit unsigned integer value in memory. */\n      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically exchanges an 8-bit unsigned integer value in memory. */\n      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    /** Atomic 64-bit integer read-modify-write operations on 16-bit values. */\n    export namespace rmw16 {\n      /** Atomically adds a 16-bit unsigned integer value in memory. */\n      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically subtracts a 16-bit unsigned integer value in memory. */\n      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise AND operation on a 16-bit unsigned integer value in memory. */\n      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise OR operation on a 16-bit unsigned integer value in memory. */\n      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise XOR operation on a 16-bit unsigned integer value in memory. */\n      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically exchanges a 16-bit unsigned integer value in memory. */\n      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    /** Atomic 64-bit integer read-modify-write operations on 32-bit values. */\n    export namespace rmw32 {\n      /** Atomically adds a 32-bit unsigned integer value in memory. */\n      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically subtracts a 32-bit unsigned integer value in memory. */\n      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise AND operation on a 32-bit unsigned integer value in memory. */\n      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise OR operation on a 32-bit unsigned integer value in memory. */\n      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise XOR operation on a 32-bit unsigned integer value in memory. */\n      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically exchanges a 32-bit unsigned integer value in memory. */\n      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically compares and exchanges a 32-bit unsigned integer value in memory if the condition is met. */\n      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    /** Atomic 64-bit integer read-modify-write operations. */\n    export namespace rmw {\n      /** Atomically adds a 64-bit integer value in memory. */\n      export function add(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically subtracts a 64-bit integer value in memory. */\n      export function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise AND operation on a 64-bit integer value in memory. */\n      export function and(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise OR operation on a 64-bit integer value in memory. */\n      export function or(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically performs a bitwise XOR operation on a 64-bit integer value in memory. */\n      export function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically exchanges a 64-bit integer value in memory. */\n      export function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n      /** Atomically compares and exchanges a 64-bit integer value in memory if the condition is met. */\n      export function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare var isize: typeof i32 | typeof i64;\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: any): i8;\ndeclare namespace u8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u8;\n  /** Largest representable value. */\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: any): i8;\ndeclare namespace u16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u16;\n  /** Largest representable value. */\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: any): i32;\ndeclare namespace u32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u32;\n  /** Largest representable value. */\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 64-bit unsigned integer. */\ndeclare function u64(value: any): i64;\ndeclare namespace u64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u64;\n  /** Largest representable value. */\n  export const MAX_VALUE: u64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare var usize: typeof u32 | typeof u64;\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: any): bool;\ndeclare namespace bool {\n  /** Smallest representable value. */\n  export const MIN_VALUE: bool;\n  /** Largest representable value. */\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: any): f32;\ndeclare namespace f32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f32;\n  /** Largest representable value. */\n  export const MAX_VALUE: f32;\n  /** Smallest normalized positive value. */\n  export const MIN_NORMAL_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Positive infinity value. */\n  export const POSITIVE_INFINITY: f32;\n  /** Negative infinity value. */\n  export const NEGATIVE_INFINITY: f32;\n  /** Not a number value. */\n  export const NaN: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n  /** Loads a 32-bit float from memory. */\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n  /** Stores a 32-bit float to memory. */\n  export function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n  /** Computes the sum of two 32-bit floats. */\n  export function add(left: f32, right: f32): f32;\n  /** Computes the difference of two 32-bit floats. */\n  export function sub(left: f32, right: f32): f32;\n  /** Computes the product of two 32-bit floats. */\n  export function mul(left: f32, right: f32): f32;\n  /** Computes the quotient of two 32-bit floats. */\n  export function div(left: f32, right: f32): f32;\n  /** Computes the absolute value of a 32-bit float. */\n  export function abs(value: f32): f32;\n  /** Determines the maximum of two 32-bit floats. If either operand is `NaN`, returns `NaN`. */\n  export function max(left: f32, right: f32): f32;\n  /** Determines the minimum of two 32-bit floats. If either operand is `NaN`, returns `NaN`. */\n  export function min(left: f32, right: f32): f32;\n  /** Performs the ceiling operation on a 32-bit float. */\n  export function ceil(value: f32): f32;\n  /** Composes a 32-bit float from the magnitude of `x` and the sign of `y`. */\n  export function copysign(x: f32, y: f32): f32;\n  /** Performs the floor operation on a 32-bit float. */\n  export function floor(value: f32): f32;\n  /** Rounds to the nearest integer tied to even of a 32-bit float. */\n  export function nearest(value: f32): f32;\n  /** Reinterprets the bits of the specified 32-bit integer as a 32-bit float. */\n  export function reinterpret_i32(value: i32): f32;\n  /** Calculates the square root of a 32-bit float. */\n  export function sqrt(value: f32): f32;\n  /** Rounds to the nearest integer towards zero of a 32-bit float. */\n  export function trunc(value: f32): f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: any): f64;\ndeclare namespace f64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f64;\n  /** Largest representable value. */\n  export const MAX_VALUE: f64;\n  /** Smallest normalized positive value. */\n  export const MIN_NORMAL_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Positive infinity value. */\n  export const POSITIVE_INFINITY: f64;\n  /** Negative infinity value. */\n  export const NEGATIVE_INFINITY: f64;\n  /** Not a number value. */\n  export const NaN: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n  /** Loads a 64-bit float from memory. */\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n  /** Stores a 64-bit float to memory. */\n  export function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n  /** Computes the sum of two 64-bit floats. */\n  export function add(left: f64, right: f64): f64;\n  /** Computes the difference of two 64-bit floats. */\n  export function sub(left: f64, right: f64): f64;\n  /** Computes the product of two 64-bit floats. */\n  export function mul(left: f64, right: f64): f64;\n  /** Computes the quotient of two 64-bit floats. */\n  export function div(left: f64, right: f64): f64;\n  /** Computes the absolute value of a 64-bit float. */\n  export function abs(value: f64): f64;\n  /** Determines the maximum of two 64-bit floats. If either operand is `NaN`, returns `NaN`. */\n  export function max(left: f64, right: f64): f64;\n  /** Determines the minimum of two 64-bit floats. If either operand is `NaN`, returns `NaN`. */\n  export function min(left: f64, right: f64): f64;\n  /** Performs the ceiling operation on a 64-bit float. */\n  export function ceil(value: f64): f64;\n  /** Composes a 64-bit float from the magnitude of `x` and the sign of `y`. */\n  export function copysign(x: f64, y: f64): f64;\n  /** Performs the floor operation on a 64-bit float. */\n  export function floor(value: f64): f64;\n  /** Rounds to the nearest integer tied to even of a 64-bit float. */\n  export function nearest(value: f64): f64;\n  /** Reinterprets the bits of the specified 64-bit integer as a 64-bit float. */\n  export function reinterpret_i64(value: i64): f64;\n  /** Calculates the square root of a 64-bit float. */\n  export function sqrt(value: f64): f64;\n  /** Rounds to the nearest integer towards zero of a 64-bit float. */\n  export function trunc(value: f64): f64;\n}\n/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */\ndeclare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\ndeclare namespace v128 {\n  /** Creates a vector with identical lanes. */\n  export function splat<T>(x: T): v128;\n  /** Extracts one lane as a scalar. */\n  export function extract_lane<T>(x: v128, idx: u8): T;\n  /** Replaces one lane. */\n  export function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n  /** Selects lanes from either vector according to the specified lane indexes. */\n  export function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\n  export function swizzle(a: v128, s: v128): v128;\n  /** Loads a vector from memory. */\n  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n  /** Creates a vector with identical lanes by loading the splatted value. */\n  export function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128\n  /** Creates a vector by loading the lanes of the specified type and extending each to the next larger type. */\n  export function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128\n  /** Stores a vector to memory. */\n  export function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n  /** Adds each lane. */\n  export function add<T>(a: v128, b: v128): v128;\n  /** Subtracts each lane. */\n  export function sub<T>(a: v128, b: v128): v128;\n  /** Multiplies each lane. */\n  export function mul<T>(a: v128, b: v128): v128; // except i64\n  /** Divides each lane. */\n  export function div<T = f32 | f64>(a: v128, b: v128): v128;\n  /** Negates each lane of a vector. */\n  export function neg<T>(a: v128): v128;\n  /** Adds each lane using saturation. */\n  export function add_saturate<T>(a: v128, b: v128): v128;\n  /** Subtracts each lane using saturation. */\n  export function sub_saturate<T>(a: v128, b: v128): v128;\n  /** Performs a bitwise left shift on each lane of a vector by a scalar. */\n  export function shl<T>(a: v128, b: i32): v128;\n  /** Performs a bitwise right shift on each lane of a vector by a scalar. */\n  export function shr<T>(a: v128, b: i32): v128;\n  /** Performs the bitwise AND operation on two vectors. */\n  export function and(a: v128, b: v128): v128;\n  /** Performs the bitwise OR operation on two vectors. */\n  export function or(a: v128, b: v128): v128;\n  /** Performs the bitwise XOR operation on two vectors. */\n  export function xor(a: v128, b: v128): v128;\n  /** Performs the bitwise ANDNOT operation on two vectors. */\n  export function andnot(a: v128, b: v128): v128;\n  /** Performs the bitwise NOT operation on a vector. */\n  export function not(a: v128): v128;\n  /** Selects bits of either vector according to the specified mask. */\n  export function bitselect(v1: v128, v2: v128, mask: v128): v128;\n  /** Reduces a vector to a scalar indicating whether any lane is considered `true`. */\n  export function any_true<T>(a: v128): bool;\n  /** Reduces a vector to a scalar indicating whether all lanes are considered `true`. */\n  export function all_true<T>(a: v128): bool;\n  /** Extracts the high bit of each lane and produces a scalar mask with all bits concatenated. */\n  export function bitmask<T>(a: v128): i32;\n  /** Computes the minimum of each lane. */\n  export function min<T>(a: v128, b: v128): v128;\n  /** Computes the maximum of each lane. */\n  export function max<T>(a: v128, b: v128): v128;\n  /** Computes the pseudo-minimum of each lane. */\n  export function pmin<T>(a: v128, b: v128): v128;\n  /** Computes the pseudo-maximum of each lane. */\n  export function pmax<T>(a: v128, b: v128): v128;\n  /** Computes the dot product of two lanes each, yielding lanes one size wider than the input. */\n  export function dot<T = i16>(a: v128, b: v128): v128;\n  /** Computes the average of each lane. */\n  export function avgr<T = u8 | u16>(a: v128, b: v128): v128;\n  /** Computes the absolute value of each lane. */\n  export function abs<T = f32 | f64>(a: v128): v128;\n  /** Computes the square root of each lane. */\n  export function sqrt<T = f32 | f64>(a: v128): v128;\n  /** Performs the ceiling operation on each lane. */\n  export function ceil<T = f32 | f64>(a: v128): v128;\n  /** Performs the floor operation on each lane. */\n  export function floor<T = f32 | f64>(a: v128): v128;\n  /** Rounds to the nearest integer towards zero of each lane. */\n  export function trunc<T = f32 | f64>(a: v128): v128;\n  /** Rounds to the nearest integer tied to even of each lane. */\n  export function nearest<T = f32 | f64>(a: v128): v128;\n  /** Computes which lanes are equal. */\n  export function eq<T>(a: v128, b: v128): v128;\n  /** Computes which lanes are not equal. */\n  export function ne<T>(a: v128, b: v128): v128;\n  /** Computes which lanes of the first vector are less than those of the second. */\n  export function lt<T>(a: v128, b: v128): v128;\n  /** Computes which lanes of the first vector are less than or equal those of the second. */\n  export function le<T>(a: v128, b: v128): v128;\n  /** Computes which lanes of the first vector are greater than those of the second. */\n  export function gt<T>(a: v128, b: v128): v128;\n  /** Computes which lanes of the first vector are greater than or equal those of the second. */\n  export function ge<T>(a: v128, b: v128): v128;\n  /** Converts each lane of a vector from integer to floating point. */\n  export function convert<TFrom = i32 | u32 | i64 | u64>(a: v128): v128;\n  /** Truncates each lane of a vector from floating point to integer with saturation. Takes the target type. */\n  export function trunc_sat<TTo = i32 | u32 | i64 | u64>(a: v128): v128;\n  /** Narrows each lane to their respective narrower lanes. */\n  export function narrow<TFrom = i16 | i32>(a: v128, b: v128): v128;\n  /** Widens the low lanes of a vector to their respective wider lanes. */\n  export function widen_low<TFrom = i8 | i16>(a: v128): v128;\n  /** Widens the high lanes of a vector to their respective wider lanes. */\n  export function widen_high<TFrom = i8 | i16>(a: v128): v128;\n  /** Computes `(a * b) + c` for each lane. */\n  export function qfma<T = f32 | f64>(a: v128, b: v128, c: v128): v128;\n  /** Computes `(a * b) - c` for each lane. */\n  export function qfms<T = f32 | f64>(a: v128, b: v128, c: v128): v128;\n}\n/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */\ndeclare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\ndeclare namespace i8x16 {\n  /** Creates a vector with sixteen identical 8-bit integer lanes. */\n  export function splat(x: i8): v128;\n  /** Extracts one 8-bit integer lane as a signed scalar. */\n  export function extract_lane_s(x: v128, idx: u8): i8;\n  /** Extracts one 8-bit integer lane as an unsigned scalar. */\n  export function extract_lane_u(x: v128, idx: u8): u8;\n  /** Replaces one 8-bit integer lane. */\n  export function replace_lane(x: v128, idx: u8, value: i8): v128;\n  /** Adds each 8-bit integer lane. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 8-bit integer lane. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 8-bit integer lane. */\n  export function mul(a: v128, b: v128): v128;\n  /** Computes the signed minimum of each 8-bit integer lane. */\n  export function min_s(a: v128, b: v128): v128;\n  /** Computes the unsigned minimum of each 8-bit integer lane. */\n  export function min_u(a: v128, b: v128): v128;\n  /** Computes the signed maximum of each 8-bit integer lane. */\n  export function max_s(a: v128, b: v128): v128;\n  /** Computes the unsigned maximum of each 8-bit integer lane. */\n  export function max_u(a: v128, b: v128): v128;\n  /** Computes the unsigned average of each 8-bit integer lane. */\n  export function avgr_u(a: v128, b: v128): v128;\n  /** Compules the absolute value of each 8-bit integer lane. */\n  export function abs(a: v128): v128;\n  /** Negates each 8-bit integer lane. */\n  export function neg(a: v128): v128;\n  /** Adds each 8-bit integer lane using signed saturation. */\n  export function add_saturate_s(a: v128, b: v128): v128;\n  /** Adds each 8-bit integer lane using unsigned saturation. */\n  export function add_saturate_u(a: v128, b: v128): v128;\n  /** Subtracts each 8-bit integer lane using signed saturation. */\n  export function sub_saturate_s(a: v128, b: v128): v128;\n  /** Subtracts each 8-bit integer lane using unsigned saturation. */\n  export function sub_saturate_u(a: v128, b: v128): v128;\n  /** Performs a bitwise left shift on each 8-bit integer lane by a scalar. */\n  export function shl(a: v128, b: i32): v128;\n  /** Performs a bitwise arithmetic right shift on each 8-bit integer lane by a scalar. */\n  export function shr_s(a: v128, b: i32): v128;\n  /** Performs a bitwise logical right shift on each 8-bit integer lane by a scalar. */\n  export function shr_u(a: v128, b: i32): v128;\n  /** Reduces a vector to a scalar indicating whether any 8-bit integer lane is considered `true`. */\n  export function any_true(a: v128): bool;\n  /** Reduces a vector to a scalar indicating whether all 8-bit integer lanes are considered `true`. */\n  export function all_true(a: v128): bool;\n  /** Extracts the high bit of each 8-bit integer lane and produces a scalar mask with all bits concatenated. */\n  export function bitmask(a: v128): i32;\n  /** Computes which 8-bit integer lanes are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 8-bit integer lanes are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 8-bit signed integer lanes of the first vector are less than those of the second. */\n  export function lt_s(a: v128, b: v128): v128;\n  /** Computes which 8-bit unsigned integer lanes of the first vector are less than those of the second. */\n  export function lt_u(a: v128, b: v128): v128;\n  /** Computes which 8-bit signed integer lanes of the first vector are less than or equal those of the second. */\n  export function le_s(a: v128, b: v128): v128;\n  /** Computes which 8-bit unsigned integer lanes of the first vector are less than or equal those of the second. */\n  export function le_u(a: v128, b: v128): v128;\n  /** Computes which 8-bit signed integer lanes of the first vector are greater than those of the second. */\n  export function gt_s(a: v128, b: v128): v128;\n  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than those of the second. */\n  export function gt_u(a: v128, b: v128): v128;\n  /** Computes which 8-bit signed integer lanes of the first vector are greater than or equal those of the second. */\n  export function ge_s(a: v128, b: v128): v128;\n  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */\n  export function ge_u(a: v128, b: v128): v128;\n  /** Narrows each 16-bit signed integer lane to 8-bit signed integer lanes. */\n  export function narrow_i16x8_s(a: v128, b: v128): v128;\n  /** Narrows each 16-bit signed integer lane to 8-bit unsigned integer lanes. */\n  export function narrow_i16x8_u(a: v128, b: v128): v128;\n}\n/** Initializes a 128-bit vector from eight 16-bit integer values. Arguments must be compile-time constants. */\ndeclare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\ndeclare namespace i16x8 {\n  /** Creates a vector with eight identical 16-bit integer lanes. */\n  export function splat(x: i16): v128;\n  /** Extracts one 16-bit integer lane as a signed scalar. */\n  export function extract_lane_s(x: v128, idx: u8): i16;\n  /** Extracts one 16-bit integer lane as an unsigned scalar. */\n  export function extract_lane_u(x: v128, idx: u8): u16;\n  /** Replaces one 16-bit integer lane. */\n  export function replace_lane(x: v128, idx: u8, value: i16): v128;\n  /** Adds each 16-bit integer lane. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 16-bit integer lane. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 16-bit integer lane. */\n  export function mul(a: v128, b: v128): v128;\n  /** Computes the signed minimum of each 16-bit integer lane. */\n  export function min_s(a: v128, b: v128): v128;\n  /** Computes the unsigned minimum of each 16-bit integer lane. */\n  export function min_u(a: v128, b: v128): v128;\n  /** Computes the signed maximum of each 16-bit integer lane. */\n  export function max_s(a: v128, b: v128): v128;\n  /** Computes the unsigned maximum of each 16-bit integer lane. */\n  export function max_u(a: v128, b: v128): v128;\n  /** Computes the unsigned average of each 16-bit integer lane. */\n  export function avgr_u(a: v128, b: v128): v128;\n  /** Compules the absolute value of each 16-bit integer lane. */\n  export function abs(a: v128): v128;\n  /** Negates each 16-bit integer lane. */\n  export function neg(a: v128): v128;\n  /** Adds each 16-bit integer lane using signed saturation. */\n  export function add_saturate_s(a: v128, b: v128): v128;\n  /** Adds each 16-bit integer lane using unsigned saturation. */\n  export function add_saturate_u(a: v128, b: v128): v128;\n  /** Subtracts each 16-bit integer lane using signed saturation. */\n  export function sub_saturate_s(a: v128, b: v128): v128;\n  /** Subtracts each 16-bit integer lane using unsigned saturation. */\n  export function sub_saturate_u(a: v128, b: v128): v128;\n  /** Performs a bitwise left shift on each 16-bit integer lane by a scalar. */\n  export function shl(a: v128, b: i32): v128;\n  /** Performs a bitwise arithmetic right shift each 16-bit integer lane by a scalar. */\n  export function shr_s(a: v128, b: i32): v128;\n  /** Performs a bitwise logical right shift on each 16-bit integer lane by a scalar. */\n  export function shr_u(a: v128, b: i32): v128;\n  /** Reduces a vector to a scalar indicating whether any 16-bit integer lane is considered `true`. */\n  export function any_true(a: v128): bool;\n  /** Reduces a vector to a scalar indicating whether all 16-bit integer lanes are considered `true`. */\n  export function all_true(a: v128): bool;\n  /** Extracts the high bit of each 16-bit integer lane and produces a scalar mask with all bits concatenated. */\n  export function bitmask(a: v128): i32;\n  /** Computes which 16-bit integer lanes are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 16-bit integer lanes are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 16-bit signed integer lanes of the first vector are less than those of the second. */\n  export function lt_s(a: v128, b: v128): v128;\n  /** Computes which 16-bit unsigned integer lanes of the first vector are less than those of the second. */\n  export function lt_u(a: v128, b: v128): v128;\n  /** Computes which 16-bit signed integer lanes of the first vector are less than or equal those of the second. */\n  export function le_s(a: v128, b: v128): v128;\n  /** Computes which 16-bit unsigned integer lanes of the first vector are less than or equal those of the second. */\n  export function le_u(a: v128, b: v128): v128;\n  /** Computes which 16-bit signed integer lanes of the first vector are greater than those of the second. */\n  export function gt_s(a: v128, b: v128): v128;\n  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than those of the second. */\n  export function gt_u(a: v128, b: v128): v128;\n  /** Computes which 16-bit signed integer lanes of the first vector are greater than or equal those of the second. */\n  export function ge_s(a: v128, b: v128): v128;\n  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */\n  export function ge_u(a: v128, b: v128): v128;\n  /** Narrows each 32-bit signed integer lane to 16-bit signed integer lanes. */\n  export function narrow_i32x4_s(a: v128, b: v128): v128;\n  /** Narrows each 32-bit signed integer lane to 16-bit unsigned integer lanes. */\n  export function narrow_i32x4_u(a: v128, b: v128): v128;\n  /** Widens the low 8-bit signed integer lanes to 16-bit signed integer lanes. */\n  export function widen_low_i8x16_s(a: v128): v128;\n  /** Widens the low 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */\n  export function widen_low_i8x16_u(a: v128): v128;\n  /** Widens the high 8-bit signed integer lanes to 16-bit signed integer lanes. */\n  export function widen_high_i8x16_s(a: v128): v128;\n  /** Widens the high 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */\n  export function widen_high_i8x16_u(a: v128): v128;\n  /** Creates a vector with eight 16-bit integer lanes by loading and sign extending eight 8-bit integers. */\n  export function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n  /** Creates a vector with eight 16-bit integer lanes by loading and zero extending eight 8-bit integers. */\n  export function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n/** Initializes a 128-bit vector from four 32-bit integer values. Arguments must be compile-time constants. */\ndeclare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\ndeclare namespace i32x4 {\n  /** Creates a vector with four identical 32-bit integer lanes. */\n  export function splat(x: i32): v128;\n  /** Extracts one 32-bit integer lane as a scalar. */\n  export function extract_lane(x: v128, idx: u8): i32;\n  /** Replaces one 32-bit integer lane. */\n  export function replace_lane(x: v128, idx: u8, value: i32): v128;\n  /** Adds each 32-bit integer lane. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 32-bit integer lane. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 32-bit integer lane. */\n  export function mul(a: v128, b: v128): v128;\n  /** Computes the signed minimum of each 32-bit integer lane. */\n  export function min_s(a: v128, b: v128): v128;\n  /** Computes the unsigned minimum of each 32-bit integer lane. */\n  export function min_u(a: v128, b: v128): v128;\n  /** Computes the signed maximum of each 32-bit integer lane. */\n  export function max_s(a: v128, b: v128): v128;\n  /** Computes the unsigned maximum of each 32-bit integer lane. */\n  export function max_u(a: v128, b: v128): v128;\n  /** Computes the dot product of two 16-bit integer lanes each, yielding 32-bit integer lanes. */\n  export function dot_i16x8_s(a: v128, b: v128): v128;\n  /** Compules the absolute value of each 32-bit integer lane. */\n  export function abs(a: v128): v128;\n  /** Negates each 32-bit integer lane. */\n  export function neg(a: v128): v128;\n  /** Performs a bitwise left shift on each 32-bit integer lane by a scalar. */\n  export function shl(a: v128, b: i32): v128;\n  /** Performs a bitwise arithmetic right shift on each 32-bit integer lane by a scalar. */\n  export function shr_s(a: v128, b: i32): v128;\n  /** Performs a bitwise logical right shift on each 32-bit integer lane by a scalar. */\n  export function shr_u(a: v128, b: i32): v128;\n  /** Reduces a vector to a scalar indicating whether any 32-bit integer lane is considered `true`. */\n  export function any_true(a: v128): bool;\n  /** Reduces a vector to a scalar indicating whether all 32-bit integer lanes are considered `true`. */\n  export function all_true(a: v128): bool;\n  /** Extracts the high bit of each 32-bit integer lane and produces a scalar mask with all bits concatenated. */\n  export function bitmask(a: v128): i32;\n  /** Computes which 32-bit integer lanes are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 32-bit integer lanes are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 32-bit signed integer lanes of the first vector are less than those of the second. */\n  export function lt_s(a: v128, b: v128): v128;\n  /** Computes which 32-bit unsigned integer lanes of the first vector are less than those of the second. */\n  export function lt_u(a: v128, b: v128): v128;\n  /** Computes which 32-bit signed integer lanes of the first vector are less than or equal those of the second. */\n  export function le_s(a: v128, b: v128): v128;\n  /** Computes which 32-bit unsigned integer lanes of the first vector are less than or equal those of the second. */\n  export function le_u(a: v128, b: v128): v128;\n  /** Computes which 32-bit signed integer lanes of the first vector are greater than those of the second. */\n  export function gt_s(a: v128, b: v128): v128;\n  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than those of the second. */\n  export function gt_u(a: v128, b: v128): v128;\n  /** Computes which 32-bit signed integer lanes of the first vector are greater than or equal those of the second. */\n  export function ge_s(a: v128, b: v128): v128;\n  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */\n  export function ge_u(a: v128, b: v128): v128;\n  /** Truncates each 32-bit float lane to a signed integer with saturation. */\n  export function trunc_sat_f32x4_s(a: v128): v128;\n  /** Truncates each 32-bit float lane to an unsigned integer with saturation. */\n  export function trunc_sat_f32x4_u(a: v128): v128;\n  /** Widens the low 16-bit signed integer lanes to 32-bit signed integer lanes. */\n  export function widen_low_i16x8_s(a: v128): v128;\n  /** Widens the low 16-bit unsigned integer lane to 32-bit unsigned integer lanes. */\n  export function widen_low_i16x8_u(a: v128): v128;\n  /** Widens the high 16-bit signed integer lanes to 32-bit signed integer lanes. */\n  export function widen_high_i16x8_s(a: v128): v128;\n  /** Widens the high 16-bit unsigned integer lanes to 32-bit unsigned integer lanes. */\n  export function widen_high_i16x8_u(a: v128): v128;\n  /** Creates a vector with four 32-bit integer lanes by loading and sign extending four 16-bit integers. */\n  export function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n  /** Creates a vector with four 32-bit integer lanes by loading and zero extending four 16-bit integers. */\n  export function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n/** Initializes a 128-bit vector from two 64-bit integer values. Arguments must be compile-time constants. */\ndeclare function i64x2(a: i64, b: i64): v128;\ndeclare namespace i64x2 {\n  /** Creates a vector with two identical 64-bit integer lanes. */\n  export function splat(x: i64): v128;\n  /** Extracts one 64-bit integer lane as a scalar. */\n  export function extract_lane(x: v128, idx: u8): i64;\n  /** Replaces one 64-bit integer lane. */\n  export function replace_lane(x: v128, idx: u8, value: i64): v128;\n  /** Adds each 64-bit integer lane. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 64-bit integer lane. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 64-bit integer lane. */\n  export function mul(a: v128, b: v128): v128;\n  /** Negates each 64-bit integer lane. */\n  export function neg(a: v128): v128;\n  /** Performs a bitwise left shift on each 64-bit integer lane by a scalar. */\n  export function shl(a: v128, b: i32): v128;\n  /** Performs a bitwise arithmetic right shift on each 64-bit integer lane by a scalar. */\n  export function shr_s(a: v128, b: i32): v128;\n  /** Performs a bitwise logical right shift on each 64-bit integer lane by a scalar. */\n  export function shr_u(a: v128, b: i32): v128;\n  /** Reduces a vector to a scalar indicating whether any 64-bit integer lane is considered `true`. */\n  export function any_true(a: v128): bool;\n  /** Reduces a vector to a scalar indicating whether all 64-bit integer lanes are considered `true`. */\n  export function all_true(a: v128): bool;\n  /** Truncates each 64-bit float lane to a signed integer with saturation. */\n  export function trunc_sat_f64x2_s(a: v128): v128;\n  /** Truncates each 64-bit float lane to an unsigned integer with saturation. */\n  export function trunc_sat_f64x2_u(a: v128): v128;\n  /** Creates a vector with two 64-bit integer lanes by loading and sign extending two 32-bit integers. */\n  export function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n  /** Creates a vector with two 64-bit integer lanes by loading and zero extending two 32-bit integers. */\n  export function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n/** Initializes a 128-bit vector from four 32-bit float values. Arguments must be compile-time constants. */\ndeclare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\ndeclare namespace f32x4 {\n  /** Creates a vector with four identical 32-bit float lanes. */\n  export function splat(x: f32): v128;\n  /** Extracts one 32-bit float lane as a scalar. */\n  export function extract_lane(x: v128, idx: u8): f32;\n  /** Replaces one 32-bit float lane. */\n  export function replace_lane(x: v128, idx: u8, value: f32): v128;\n  /** Adds each 32-bit float lane. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 32-bit float lane. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 32-bit float lane. */\n  export function mul(a: v128, b: v128): v128;\n  /** Divides each 32-bit float lane. */\n  export function div(a: v128, b: v128): v128;\n  /** Negates each 32-bit float lane. */\n  export function neg(a: v128): v128;\n  /** Computes the minimum of each 32-bit float lane. */\n  export function min(a: v128, b: v128): v128;\n  /** Computes the maximum of each 32-bit float lane. */\n  export function max(a: v128, b: v128): v128;\n  /** Computes the pseudo-minimum of each 32-bit float lane. */\n  export function pmin(a: v128, b: v128): v128;\n  /** Computes the pseudo-maximum of each 32-bit float lane. */\n  export function pmax(a: v128, b: v128): v128;\n  /** Computes the absolute value of each 32-bit float lane. */\n  export function abs(a: v128): v128;\n  /** Computes the square root of each 32-bit float lane. */\n  export function sqrt(a: v128): v128;\n  /** Performs the ceiling operation on each 32-bit float lane. */\n  export function ceil(a: v128): v128;\n  /** Performs the floor operation on each each 32-bit float lane. */\n  export function floor(a: v128): v128;\n  /** Rounds to the nearest integer towards zero of each 32-bit float lane. */\n  export function trunc(a: v128): v128;\n  /** Rounds to the nearest integer tied to even of each 32-bit float lane. */\n  export function nearest(a: v128): v128;\n  /** Computes which 32-bit float lanes are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes of the first vector are less than those of the second. */\n  export function lt(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes of the first vector are less than or equal those of the second. */\n  export function le(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes of the first vector are greater than those of the second. */\n  export function gt(a: v128, b: v128): v128;\n  /** Computes which 32-bit float lanes of the first vector are greater than or equal those of the second. */\n  export function ge(a: v128, b: v128): v128;\n  /** Converts each 32-bit signed integer lane of a vector to floating point. */\n  export function convert_i32x4_s(a: v128): v128;\n  /** Converts each 32-bit unsigned integer lane of a vector to floating point. */\n  export function convert_i32x4_u(a: v128): v128;\n  /** Computes `(a * b) + c` for each 32-bit float lane. */\n  export function qfma(a: v128, b: v128, c: v128): v128;\n  /** Computes `(a * b) - c` for each 32-bit float lane. */\n  export function qfms(a: v128, b: v128, c: v128): v128;\n}\n/** Initializes a 128-bit vector from two 64-bit float values. Arguments must be compile-time constants. */\ndeclare function f64x2(a: f64, b: f64): v128;\ndeclare namespace f64x2 {\n  /** Creates a vector with two identical 64-bit float lanes. */\n  export function splat(x: f64): v128;\n  /** Extracts one 64-bit float lane as a scalar. */\n  export function extract_lane(x: v128, idx: u8): f64;\n  /** Replaces one 64-bit float lane. */\n  export function replace_lane(x: v128, idx: u8, value: f64): v128;\n  /** Adds each 64-bit float lane. */\n  export function add(a: v128, b: v128): v128;\n  /** Subtracts each 64-bit float lane. */\n  export function sub(a: v128, b: v128): v128;\n  /** Multiplies each 64-bit float lane. */\n  export function mul(a: v128, b: v128): v128;\n  /** Divides each 64-bit float lane. */\n  export function div(a: v128, b: v128): v128;\n  /** Negates each 64-bit float lane. */\n  export function neg(a: v128): v128;\n  /** Computes the minimum of each 64-bit float lane. */\n  export function min(a: v128, b: v128): v128;\n  /** Computes the maximum of each 64-bit float lane. */\n  export function max(a: v128, b: v128): v128;\n  /** Computes the pseudo-minimum of each 64-bit float lane. */\n  export function pmin(a: v128, b: v128): v128;\n  /** Computes the pseudo-maximum of each 64-bit float lane. */\n  export function pmax(a: v128, b: v128): v128;\n  /** Computes the absolute value of each 64-bit float lane. */\n  export function abs(a: v128): v128;\n  /** Computes the square root of each 64-bit float lane. */\n  export function sqrt(a: v128): v128;\n  /** Performs the ceiling operation on each 64-bit float lane. */\n  export function ceil(a: v128): v128;\n  /** Performs the floor operation on each each 64-bit float lane. */\n  export function floor(a: v128): v128;\n  /** Rounds to the nearest integer towards zero of each 64-bit float lane. */\n  export function trunc(a: v128): v128;\n  /** Rounds to the nearest integer tied to even of each 64-bit float lane. */\n  export function nearest(a: v128): v128;\n  /** Computes which 64-bit float lanes are equal. */\n  export function eq(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes are not equal. */\n  export function ne(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes of the first vector are less than those of the second. */\n  export function lt(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes of the first vector are less than or equal those of the second. */\n  export function le(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes of the first vector are greater than those of the second. */\n  export function gt(a: v128, b: v128): v128;\n  /** Computes which 64-bit float lanes of the first vector are greater than or equal those of the second. */\n  export function ge(a: v128, b: v128): v128;\n  /** Converts each 64-bit signed integer lane of a vector to floating point. */\n  export function convert_i64x2_s(a: v128): v128;\n  /** Converts each 64-bit unsigned integer lane of a vector to floating point. */\n  export function convert_i64x2_u(a: v128): v128;\n  /** Computes `(a * b) + c` for each 64-bit float lane. */\n  export function qfma(a: v128, b: v128, c: v128): v128;\n  /** Computes `(a * b) - c` for each 64-bit float lane. */\n  export function qfms(a: v128, b: v128, c: v128): v128;\n}\ndeclare namespace v8x16 {\n  /** Selects 8-bit lanes from either vector according to the specified [0-15] respectively [16-31] lane indexes. */\n  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;\n  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */\n  export function swizzle(a: v128, s: v128): v128;\n  /** Loads an 8-bit integer and splats it sixteen times forming a new vector. */\n  export function load_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n}\ndeclare namespace v16x8 {\n  /** Loads a 16-bit integer and splats it eight times forming a new vector. */\n  export function load_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n}\ndeclare namespace v32x4 {\n  /** Loads a 32-bit integer and splats it four times forming a new vector. */\n  export function load_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n}\ndeclare namespace v64x2 {\n  /** Loads a 64-bit integer and splats it two times forming a new vector. */\n  export function load_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n}\n/** Macro type evaluating to the underlying native WebAssembly type. */\ndeclare type native<T> = T;\n/** Special type evaluating the indexed access index type. */\ndeclare type indexof<T extends unknown[]> = keyof T;\n/** Special type evaluating the indexed access value type. */\ndeclare type valueof<T extends unknown[]> = T[0];\n/** A special type evaluated to the return type of T if T is a callable function. */\ndeclare type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n/** A special type evaluated to the return type of T if T is a callable function. */\ndeclare type returnof<T extends (...args: any) => any> = ReturnType<T>;\n\n/** Pseudo-class representing the backing class of integer types. */\ndeclare class _Integer {\n  /** Smallest representable value. */\n  static readonly MIN_VALUE: number;\n  /** Largest representable value. */\n  static readonly MAX_VALUE: number;\n  /** Converts a string to an integer of this type. */\n  static parseInt(value: string, radix?: number): number;\n  /** Converts this integer to a string. */\n  toString(radix?: number): string;\n}\n\n/** Pseudo-class representing the backing class of floating-point types. */\ndeclare class _Float {\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  static readonly EPSILON: f32 | f64;\n  /** Smallest representable value. */\n  static readonly MIN_VALUE: f32 | f64;\n  /** Largest representable value. */\n  static readonly MAX_VALUE: f32 | f64;\n  /** Smallest safely representable integer value. */\n  static readonly MIN_SAFE_INTEGER: f32 | f64;\n  /** Largest safely representable integer value. */\n  static readonly MAX_SAFE_INTEGER: f32 | f64;\n  /** Value representing positive infinity. */\n  static readonly POSITIVE_INFINITY: f32 | f64;\n  /** Value representing negative infinity. */\n  static readonly NEGATIVE_INFINITY: f32 | f64;\n  /** Value representing \'not a number\'. */\n  static readonly NaN: f32 | f64;\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\n  static isNaN(value: f32 | f64): bool;\n  /** Returns true if passed value is finite. */\n  static isFinite(value: f32 | f64): bool;\n  /** Returns true if the value passed is a safe integer. */\n  static isSafeInteger(value: f32 | f64): bool;\n  /** Returns true if the value passed is an integer, false otherwise. */\n  static isInteger(value: f32 | f64): bool;\n  /** Converts a string to an integer. */\n  static parseInt(value: string, radix?: i32): f32 | f64;\n  /** Converts a string to a floating-point number. */\n  static parseFloat(value: string): f32 | f64;\n  /** Converts this floating-point number to a string. */\n  toString(radix?: number): string;\n}\n\n/** Backing class of signed 8-bit integers. */\ndeclare const I8: typeof _Integer;\n/** Backing class of signed 16-bit integers. */\ndeclare const I16: typeof _Integer;\n/** Backing class of signed 32-bit integers. */\ndeclare const I32: typeof _Integer;\n/** Backing class of signed 64-bit integers. */\ndeclare const I64: typeof _Integer;\n/** Backing class of signed size integers. */\ndeclare const Isize: typeof _Integer;\n/** Backing class of unsigned 8-bit integers. */\ndeclare const U8: typeof _Integer;\n/** Backing class of unsigned 16-bit integers. */\ndeclare const U16: typeof _Integer;\n/** Backing class of unsigned 32-bit integers. */\ndeclare const U32: typeof _Integer;\n/** Backing class of unsigned 64-bit integers. */\ndeclare const U64: typeof _Integer;\n/** Backing class of unsigned size integers. */\ndeclare const Usize: typeof _Integer;\n/** Backing class of 32-bit floating-point values. */\ndeclare const F32: typeof _Float;\n/** Backing class of 64-bit floating-point values. */\ndeclare const F64: typeof _Float;\n\n// User-defined diagnostic macros\n\n/** Emits a user-defined diagnostic error when encountered. */\ndeclare function ERROR(message?: any): void;\n/** Emits a user-defined diagnostic warning when encountered. */\ndeclare function WARNING(message?: any): void;\n/** Emits a user-defined diagnostic info when encountered. */\ndeclare function INFO(message?: any): void;\n\n// Polyfills\n\n/** Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | isize | usize>(value: T): T;\n/** Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i8 | u8 | i16 | u16 | i32 | u32>(value: T): T;\n\n// Standard library\n\n/** Memory operations. */\ndeclare namespace memory {\n  /** Whether the memory managed interface is implemented. */\n  export const implemented: bool;\n  /** Returns the current memory size in units of pages. One page is 64kb. */\n  export function size(): i32;\n  /** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\n  export function grow(value: i32): i32;\n  /** Sets n bytes beginning at the specified destination in memory to the specified byte value. */\n  export function fill(dst: usize, value: u8, count: usize): void;\n  /** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\n  export function copy(dst: usize, src: usize, n: usize): void;\n  /** Repeats `src` of length `srcLength` `count` times at `dst`. */\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void;\n  /** Copies elements from a passive element segment to a table. */\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void;\n  /** Prevents further use of a passive element segment. */\n  export function drop(segmentIndex: u32): void;\n  /** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */\n  export function compare(vl: usize, vr: usize, n: usize): i32;\n  /** Gets a pointer to a zeroed static chunk of memory of the given size. Alignment defaults to `16`. Arguments must be compile-time constants. */\n  export function data(size: i32, align?: i32): usize;\n  /** Gets a pointer to a pre-initialized static chunk of memory. Alignment defaults to the size of `T`. Arguments must be compile-time constants. */\n  export function data<T>(values: T[], align?: i32): usize;\n}\n\n/** Heap memory interface. */\ndeclare namespace heap {\n  /** Allocates a chunk of memory of at least the specified size. */\n  export function alloc(size: usize): usize;\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  export function realloc(ptr: usize, size: usize): usize;\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub/none runtime. */\n  export function free(ptr: usize): void;\n}\n\n/** Table operations. */\ndeclare namespace table {\n  /** Copies elements from a passive element segment to a table. */\n  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void;\n  /** Prevents further use of a passive element segment. */\n  export function drop(elementIndex: u32): void;\n  /** Copies elements from one region of a table to another region. */\n  export function copy(dest: u32, src: u32, n: u32): void;\n}\n\ndeclare namespace Atomics {\n  export function load<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32): T;\n  export function store<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): void;\n  export function add<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\n  export function sub<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\n  export function and<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\n  export function or<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\n  export function xor<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\n  export function exchange<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;\n  export function compareExchange<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, expectedValue: T, replacementValue: T): T;\n  export function wait<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, value: T, timeout?: i64): AtomicWaitResult;\n  export function notify<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, count?: i32): i32;\n  /** The static Atomics.isLockFree() method is used to determine whether to use locks or atomic operations. It returns true, if the given size is one of the BYTES_PER_ELEMENT */\n  export function isLockFree(size: usize): bool;\n}\n\n/** Class representing a generic, fixed-length raw binary data buffer. */\ndeclare class ArrayBuffer {\n  /** The size, in bytes, of the array. */\n  readonly byteLength: i32;\n  /** Returns true if value is one of the ArrayBuffer views, such as typed array or a DataView **/\n  static isView<T>(value: T): bool;\n  /** Constructs a new array buffer of the given length in bytes. */\n  constructor(length: i32);\n  /** Returns a copy of this array buffer\'s bytes from begin, inclusive, up to end, exclusive. */\n  slice(begin?: i32, end?: i32): ArrayBuffer;\n  /** Returns a string representation of ArrayBuffer. */\n  toString(): string;\n}\n\n/** The `DataView` view provides a low-level interface for reading and writing multiple number types in a binary `ArrayBuffer`, without having to care about the platform\'s endianness. */\ndeclare class DataView {\n  /** The `buffer` accessor property represents the `ArrayBuffer` or `SharedArrayBuffer` referenced by the `DataView` at construction time. */\n  readonly buffer: ArrayBuffer;\n  /** The `byteLength` accessor property represents the length (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\n  readonly byteLength: i32;\n  /** The `byteOffset` accessor property represents the offset (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */\n  readonly byteOffset: i32;\n  /** Constructs a new `DataView` with the given properties */\n  constructor(buffer: ArrayBuffer, byteOffset?: i32, byteLength?: i32);\n  /** The `getFloat32()` method gets a signed 32-bit float (float) at the specified byte offset from the start of the `DataView`. */\n  getFloat32(byteOffset: i32, littleEndian?: bool): f32;\n  /** The `getFloat64()` method gets a signed 64-bit float (double) at the specified byte offset from the start of the `DataView`. */\n  getFloat64(byteOffset: i32, littleEndian?: bool): f64;\n  /** The `getInt8()` method gets a signed 8-bit integer (byte) at the specified byte offset from the start of the `DataView`. */\n  getInt8(byteOffset: i32): i8;\n  /** The `getInt16()` method gets a signed 16-bit integer (short) at the specified byte offset from the start of the `DataView`. */\n  getInt16(byteOffset: i32, littleEndian?: bool): i16;\n  /** The `getInt32()` method gets a signed 32-bit integer (long) at the specified byte offset from the start of the `DataView`. */\n  getInt32(byteOffset: i32, littleEndian?: bool): i32;\n  /** The `getInt64()` method gets a signed 64-bit integer (long long) at the specified byte offset from the start of the `DataView`. */\n  getInt64(byteOffset: i32, littleEndian?: bool): i64;\n  /** The `getUint8()` method gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the `DataView`. */\n  getUint8(byteOffset: i32): u8;\n  /** The `getUint16()` method gets an unsigned 16-bit integer (unsigned short) at the specified byte offset from the start of the `DataView`. */\n  getUint16(byteOffset: i32, littleEndian?: bool): u16;\n  /** The `getUint32()` method gets an unsigned 32-bit integer (unsigned long) at the specified byte offset from the start of the `DataView`. */\n  getUint32(byteOffset: i32, littleEndian?: bool): u32;\n  /** The `getUint64()` method gets an unsigned 64-bit integer (unsigned long long) at the specified byte offset from the start of the `DataView`. */\n  getUint64(byteOffset: i32, littleEndian?: bool): u64;\n  /** The `setFloat32()` method stores a signed 32-bit float (float) value at the specified byte offset from the start of the `DataView`. */\n  setFloat32(byteOffset: i32, value: f32, littleEndian?: bool): void;\n  /** The `setFloat64()` method stores a signed 64-bit float (double) value at the specified byte offset from the start of the `DataView`. */\n  setFloat64(byteOffset: i32, value: f64, littleEndian?: bool): void;\n  /** The `setInt8()` method stores a signed 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\n  setInt8(byteOffset: i32, value: i8): void;\n  /** The `setInt16()` method stores a signed 16-bit integer (short) value at the specified byte offset from the start of the `DataView`. */\n  setInt16(byteOffset: i32, value: i16, littleEndian?: bool): void;\n  /** The `setInt32()` method stores a signed 32-bit integer (long) value at the specified byte offset from the start of the `DataView`. */\n  setInt32(byteOffset: i32, value: i32, littleEndian?: bool): void;\n  /** The `setInt64()` method stores a signed 64-bit integer (long long) value at the specified byte offset from the start of the `DataView`. */\n  setInt64(byteOffset: i32, value: i64, littleEndian?: bool): void;\n  /** The `setUint8()` method stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */\n  setUint8(byteOffset: i32, value: u8): void;\n  /** The `setUint16()` method stores an unsigned 16-bit integer (unsigned short) value at the specified byte offset from the start of the `DataView`. */\n  setUint16(byteOffset: i32, value: u16, littleEndian?: bool): void;\n  /** The `setUint32()` method stores an unsigned 32-bit integer (unsigned long) value at the specified byte offset from the start of the `DataView`. */\n  setUint32(byteOffset: i32, value: u32, littleEndian?: bool): void;\n  /** The `setUint64()` method stores an unsigned 64-bit integer (unsigned long long) value at the specified byte offset from the start of the `DataView`. */\n  setUint64(byteOffset: i32, value: u64, littleEndian?: bool): void;\n  /** Returns a string representation of DataView. */\n  toString(): string;\n}\n\ninterface ArrayLike<T> {\n  [key: number]: T;\n  length: i32;\n}\n\n/** Interface for a typed view on an array buffer. */\ninterface ArrayBufferView {\n  /** The {@link ArrayBuffer} referenced by this view. */\n  readonly buffer: ArrayBuffer;\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteOffset: i32;\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteLength: i32;\n}\n\n/* @internal */\ndeclare abstract class TypedArray<T> implements ArrayBufferView {\n  [key: number]: T;\n  /** Number of bytes per element. */\n  static readonly BYTES_PER_ELEMENT: usize;\n  /** Constructs a new typed array. */\n  constructor(length: i32);\n  /** The {@link ArrayBuffer} referenced by this view. */\n  readonly buffer: ArrayBuffer;\n  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteOffset: i32;\n  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */\n  readonly byteLength: i32;\n  /** The length (in elements). */\n  readonly length: i32;\n  /** Returns value using relative indexing. Index may be negative */\n  at(index: i32): T;\n  /** The includes() method determines whether a typed array includes a certain element, returning true or false as appropriate. */\n  includes(searchElement: T, fromIndex?: i32): bool;\n  /** The indexOf() method returns the first index at which a given element can be found in the typed array, or -1 if it is not present. */\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  /** The lastIndexOf() method returns the last index at which a given element can be found in the typed array, or -1 if it is not present. The typed array is searched backwards, starting at fromIndex. */\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  /** Returns copied section of an TypedArray from begin inclusive to end exclusive */\n  slice(begin?: i32, end?: i32): TypedArray<T>;\n  /** Returns a new TypedArray of this type on the same ArrayBuffer from begin inclusive to end exclusive. */\n  subarray(begin?: i32, end?: i32): TypedArray<T>;\n  /** The copyWithin() method copies the sequence of array elements within the array to the position starting at target. The copy is taken from the index positions of the second and third arguments start and end. The end argument is optional and defaults to the length of the array. */\n  copyWithin(target: i32, start: i32, end?: i32): this;\n  /**  The reduce() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value. This method has the same algorithm as Array.prototype.reduce(). */\n  reduce<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;\n  /**  The reduceRight() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value, starting from the end of the array. This method has the same algorithm as Array.prototype.reduceRight(). */\n  reduceRight<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;\n  /** The some() method tests whether some element in the typed array passes the test implemented by the provided function. This method has the same algorithm as Array.prototype.some().*/\n  some(callbackfn: (value: T, index: i32, self: this) => bool): bool;\n  /** The map() method creates a new typed array with the results of calling a provided function on every element in this typed array. This method has the same algorithm as Array.prototype.map().*/\n  map(callbackfn: (value: T, index: i32, self: this) => T): TypedArray<T>;\n  /** The filter() method creates a new typed array with all elements that pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.filter(). */\n  filter(callbackfn: (value: T, index: i32, self: this) => bool): TypedArray<T>;\n  /** The sort() method sorts the elements of a typed array numerically in place and returns the typed array. This method has the same algorithm as Array.prototype.sort(), except that sorts the values numerically instead of as strings. TypedArray is one of the typed array types here. */\n  sort(callback?: (a: T, b: T) => i32): this;\n  /** The fill() method fills all the elements of a typed array from a start index to an end index with a static value. This method has the same algorithm as Array.prototype.fill(). */\n  fill(value: T, start?: i32, end?: i32): this;\n  /** The findIndex() method returns an index in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */\n  findIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;\n  /** The every() method tests whether all elements in the typed array pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.every(). */\n  every(callbackfn: (value: T, index: i32, self: this) => bool): bool;\n  /** The forEach() method executes a provided function once per array element. This method has the same algorithm as Array.prototype.forEach().*/\n  forEach(callbackfn: (value: T, index: i32, self: this) => void): void;\n  /** The reverse() method reverses a typed array in place. The first typed array element becomes the last and the last becomes the first. This method has the same algorithm as Array.prototype.reverse(). */\n  reverse(): this;\n  /** The join() method joins all elements of an array into a string. This method has the same algorithm as Array.prototype.join(). */\n  join(separator?: string): string;\n  /** The set() method stores multiple values in the typed array, reading input values from a specified array. */\n  set<U extends ArrayBufferView>(source: U, offset?: i32): void\n  /** The toString() method returns a string representing the specified array and its elements. This method has the same algorithm as Array.prototype.toString() */\n  toString(): string;\n}\n\n/** An array of twos-complement 8-bit signed integers. */\ndeclare class Int8Array extends TypedArray<i8> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;\n}\n/** An array of 8-bit unsigned integers. */\ndeclare class Uint8Array extends TypedArray<u8> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;\n}\n/** A clamped array of 8-bit unsigned integers. */\ndeclare class Uint8ClampedArray extends TypedArray<u8> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;\n}\n/** An array of twos-complement 16-bit signed integers. */\ndeclare class Int16Array extends TypedArray<i16> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;\n}\n/** An array of 16-bit unsigned integers. */\ndeclare class Uint16Array extends TypedArray<u16> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;\n}\n/** An array of twos-complement 32-bit signed integers. */\ndeclare class Int32Array extends TypedArray<i32> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;\n}\n/** An array of 32-bit unsigned integers. */\ndeclare class Uint32Array extends TypedArray<u32> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;\n}\n/** An array of twos-complement 64-bit signed integers. */\ndeclare class Int64Array extends TypedArray<i64> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int64Array;\n}\n/** An array of 64-bit unsigned integers. */\ndeclare class Uint64Array extends TypedArray<u64> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint64Array;\n}\n/** An array of 32-bit floating point numbers. */\ndeclare class Float32Array extends TypedArray<f32> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;\n}\n/** An array of 64-bit floating point numbers. */\ndeclare class Float64Array extends TypedArray<f64> {\n  /** Wrap an ArrayBuffer */\n  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;\n}\n\n/** Class representing a sequence of values of type `T`. */\ndeclare class Array<T> {\n\n  /** Tests if a value is an array. */\n  static isArray<U>(value: any): value is Array<any>;\n\n  [key: number]: T;\n  /** Current length of the array. */\n  length: i32;\n  /** Constructs a new array. */\n  constructor(capacity?: i32);\n\n  at(index: i32): T;\n  fill(value: T, start?: i32, end?: i32): this;\n  every(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  findIndex(predicate: (element: T, index: i32, array?: Array<T>) => bool): i32;\n  includes(searchElement: T, fromIndex?: i32): bool;\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): i32;\n  concat(items: T[]): T[];\n  copyWithin(target: i32, start: i32, end?: i32): this;\n  pop(): T;\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void;\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U>;\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T>;\n  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;\n  shift(): T;\n  some(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): Array<T>;\n  splice(start: i32, deleteCount?: i32): Array<T>;\n  sort(comparator?: (a: T, b: T) => i32): this;\n  join(separator?: string): string;\n  reverse(): T[];\n  /** Flattens an array of arrays. If any null entries exist in the array, they are ignored, unlike JavaScript\'s version of Array#flat(). */\n  flat(): T extends unknown[] ? T : never;\n  toString(): string;\n}\n\n/** Class representing a static (not resizable) sequence of values of type `T`. This class is @final. */\ndeclare class StaticArray<T> {\n  [key: number]: T;\n  static fromArray<T>(source: Array<T>): StaticArray<T>;\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T>;\n  static slice<T>(source: StaticArray<T>, start?: i32, end?: i32): StaticArray<T>;\n  readonly length: i32;\n  constructor(length?: i32);\n  at(index: i32): T;\n  includes(searchElement: T, fromIndex?: i32): bool;\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  concat(items: Array<T>): Array<T>;\n  slice(from: i32, to?: i32): Array<T>;\n  join(separator?: string): string;\n  toString(): string;\n}\n\n/** Class representing a sequence of characters. */\ndeclare class String {\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(code: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n  readonly length: i32;\n  at(index: i32): string;\n  charAt(index: i32): string;\n  charCodeAt(index: i32): i32;\n  codePointAt(index: i32): i32;\n  concat(other: string): string;\n  endsWith(other: string): bool;\n  indexOf(other: string, fromIndex?: i32): i32;\n  lastIndexOf(other: string, fromIndex?: i32): i32;\n  localeCompare(other: string): i32;\n  includes(other: string): bool;\n  startsWith(other: string): bool;\n  substr(start: i32, length?: i32): string;\n  substring(start: i32, end?: i32): string;\n  trim(): string;\n  trimLeft(): string;\n  trimRight(): string;\n  trimStart(): string;\n  trimEnd(): string;\n  padStart(targetLength: i32, padString?: string): string;\n  padEnd(targetLength: i32, padString?: string): string;\n  repeat(count?: i32): string;\n  replace(search: string, replacement: string): string;\n  replaceAll(search: string, replacement: string): string;\n  slice(beginIndex: i32, endIndex?: i32): string;\n  split(separator?: string, limit?: i32): string[];\n  toLowerCase(): string;\n  toUpperCase(): string;\n  toString(): string;\n}\n\ndeclare namespace String {\n  /** Encoding helpers for UTF-8. */\n  export namespace UTF8 {\n    /** Calculates the byte length of the specified string when encoded as UTF-8, optionally null terminated. */\n    export function byteLength(str: string, nullTerminated?: bool): i32;\n    /** Encodes the specified string to UTF-8 bytes, optionally null terminated. */\n    export function encode(str: string, nullTerminated?: bool): ArrayBuffer;\n    /** Encodes the specified raw string to UTF-8 bytes, opionally null terminated. Returns the number of bytes written. */\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated?: bool): usize;\n    /** Decodes the specified buffer from UTF-8 bytes to a string, optionally null terminated. */\n    export function decode(buf: ArrayBuffer, nullTerminated?: bool): string;\n    /** Decodes raw UTF-8 bytes to a string, optionally null terminated. */\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated?: bool): string;\n  }\n  /** Encoding helpers for UTF-16. */\n  export namespace UTF16 {\n    /** Calculates the byte length of the specified string when encoded as UTF-16. */\n    export function byteLength(str: string): i32;\n    /** Encodes the specified string to UTF-16 bytes. */\n    export function encode(str: string): ArrayBuffer;\n    /** Encodes the specified raw string to UTF-16 bytes. Returns the number of bytes written. */\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize;\n    /** Decodes the specified buffer from UTF-16 bytes to a string. */\n    export function decode(buf: ArrayBuffer): string;\n    /** Decodes raw UTF-16 bytes to a string. */\n    export function decodeUnsafe(buf: usize, len: usize): string;\n  }\n}\n\ndeclare class Object {\n  /** The Object.is() method determines whether two values are the same value. */\n  static is<T>(value1: T, value2: T): bool;\n}\n\ndeclare class Date {\n  /** Returns the UTC timestamp in milliseconds of the specified date. */\n  static UTC(\n    year: i32,\n    month: i32,\n    day: i32,\n    hour: i32,\n    minute: i32,\n    second: i32,\n    millisecond: i32\n  ): i64;\n  /** Returns the current UTC timestamp in milliseconds. */\n  static now(): i64;\n  /** Constructs a new date object from an UTC timestamp in milliseconds. */\n  constructor(value: i64);\n  /** Returns the UTC timestamp of this date in milliseconds. */\n  getTime(): i64;\n  /** Sets the UTC timestamp of this date in milliseconds. */\n  setTime(value: i64): i64;\n}\n\n/** Class for representing a runtime error. Base class of all errors. */\ndeclare class Error {\n\n  /** Error name. */\n  name: string;\n\n  /** Message provided on construction. */\n  message: string;\n\n  /** Stack trace. */\n  stack?: string;\n\n  /** Constructs a new error, optionally with a message. */\n  constructor(message?: string);\n\n  /** Method returns a string representing the specified Error class. */\n  toString(): string;\n}\n\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\ndeclare class RangeError extends Error { }\n\n/** Class for indicating an error when a value is not of the expected type. */\ndeclare class TypeError extends Error { }\n\n/** Class for indicating an error when trying to interpret syntactically invalid code. */\ndeclare class SyntaxError extends Error { }\n\ninterface Boolean {\n  toString(radix?: number): string;\n}\n\ninterface Number {\n  toString(radix?: number): string;\n}\n\ninterface Function {\n  /** Function table index. */\n  readonly index: u32;\n  /** Function name. Always an empty string. */\n  readonly name: string;\n  /** Number of expected parameters. */\n  readonly length: u32;\n  /** Calls this function indirectly with the specified arguments. */\n  call(thisArg: unknown, ...args: unknown[]): any;\n  /** Returns a string representation of this function. */\n  toString(): string;\n}\ninterface IArguments {}\ninterface RegExp {}\n\ndeclare class Map<K,V> {\n  readonly size: i32;\n  has(key: K): bool;\n  set(key: K, value: V): this;\n  get(key: K): V;\n  delete(key: K): bool;\n  clear(): void;\n  keys(): K[]; // preliminary\n  values(): V[]; // preliminary\n  toString(): string;\n}\n\ndeclare class Set<K> {\n  readonly size: i32;\n  has(value: K): bool;\n  add(value: K): this;\n  delete(value: K): bool;\n  clear(): void;\n  values(): K[]; // preliminary\n  toString(): string;\n}\n\ninterface SymbolConstructor {\n  readonly hasInstance: symbol;\n  readonly isConcatSpreadable: symbol;\n  readonly isRegExp: symbol;\n  readonly iterator: symbol;\n  readonly match: symbol;\n  readonly replace: symbol;\n  readonly search: symbol;\n  readonly species: symbol;\n  readonly split: symbol;\n  readonly toPrimitive: symbol;\n  readonly toStringTag: symbol;\n  readonly unscopables: symbol;\n  (description?: string | null): symbol;\n  for(key: string): symbol;\n  keyFor(sym: symbol): string | null;\n}\n\ndeclare const Symbol: SymbolConstructor;\n\ninterface IMath<T> {\n  /** The base of natural logarithms, e, approximately 2.718. */\n  readonly E: T;\n  /** The natural logarithm of 2, approximately 0.693. */\n  readonly LN2: T;\n  /** The natural logarithm of 10, approximately 2.302. */\n  readonly LN10: T;\n  /** The base 2 logarithm of e, approximately 1.442. */\n  readonly LOG2E: T;\n  /** The base 10 logarithm of e, approximately 0.434. */\n  readonly LOG10E: T;\n  /** The ratio of the circumference of a circle to its diameter, approximately 3.14159. */\n  readonly PI: T;\n  /** The square root of 1/2, approximately 0.707. */\n  readonly SQRT1_2: T;\n  /** The square root of 2, approximately 1.414. */\n  readonly SQRT2: T;\n  /** Returns the absolute value of `x`. */\n  abs(x: T): T;\n  /** Returns the arccosine (in radians) of `x`. */\n  acos(x: T): T;\n  /** Returns the hyperbolic arc-cosine of `x`. */\n  acosh(x: T): T;\n  /** Returns the arcsine (in radians) of `x`. */\n  asin(x: T): T;\n  /** Returns the hyperbolic arcsine of `x`. */\n  asinh(x: T): T;\n  /** Returns the arctangent (in radians) of `x`. */\n  atan(x: T): T;\n  /** Returns the arctangent of the quotient of its arguments. */\n  atan2(y: T, x: T): T;\n  /** Returns the hyperbolic arctangent of `x`. */\n  atanh(x: T): T;\n  /** Returns the cube root of `x`. */\n  cbrt(x: T): T;\n  /** Returns the smallest integer greater than or equal to `x`. */\n  ceil(x: T): T;\n  /** Returns the number of leading zero bits in the 32-bit binary representation of `x`. */\n  clz32(x: T): T;\n  /** Returns the cosine (in radians) of `x`. */\n  cos(x: T): T;\n  /** Returns the hyperbolic cosine of `x`. */\n  cosh(x: T): T;\n  /** Returns e to the power of `x`. */\n  exp(x: T): T;\n  /** Returns e to the power of `x`, minus 1. */\n  expm1(x: T): T;\n  /** Returns the largest integer less than or equal to `x`. */\n  floor(x: T): T;\n  /** Returns the nearest 32-bit single precision float representation of `x`. */\n  fround(x: T): T;\n  /** Returns the square root of the sum of squares of its arguments. */\n  hypot(value1: T, value2: T): T; // TODO: rest\n  /** Returns the result of the C-like 32-bit multiplication of `a` and `b`. */\n  imul(a: T, b: T): T;\n  /** Returns the natural logarithm (base e) of `x`. */\n  log(x: T): T;\n  /** Returns the base 10 logarithm of `x`. */\n  log10(x: T): T;\n  /** Returns the natural logarithm (base e) of 1 + `x`. */\n  log1p(x: T): T;\n  /** Returns the base 2 logarithm of `x`. */\n  log2(x: T): T;\n  /** Returns the largest-valued number of its arguments. */\n  max(value1: T, value2: T): T; // TODO: rest\n  /** Returns the lowest-valued number of its arguments. */\n  min(value1: T, value2: T): T; // TODO: rest\n  /** Returns `base` to the power of `exponent`. */\n  pow(base: T, exponent: T): T;\n  /** Returns a pseudo-random number in the range from 0.0 inclusive up to but not including 1.0. */\n  random(): T;\n  /** Returns the value of `x` rounded to the nearest integer. */\n  round(x: T): T;\n  /** Returns the sign of `x`, indicating whether the number is positive, negative or zero. */\n  sign(x: T): T;\n  /** Returns whether the sign bit of `x` is set. */\n  signbit(x: T): bool;\n  /** Returns the sine of `x`. */\n  sin(x: T): T;\n  /** Returns the hyperbolic sine of `x`. */\n  sinh(x: T): T;\n  /** Returns the square root of `x`. */\n  sqrt(x: T): T;\n  /** Returns the tangent of `x`. */\n  tan(x: T): T;\n  /** Returns the hyperbolic tangent of `x`. */\n  tanh(x: T): T;\n  /** Returns the integer part of `x` by removing any fractional digits. */\n  trunc(x: T): T;\n}\n\ninterface INativeMath<T> extends IMath<T> {\n  /** Contains sin value produced after Math/Mathf.sincos */\n  sincos_sin: T;\n  /** Contains cos value produced after Math/Mathf.sincos */\n  sincos_cos: T;\n  /** Seeds the random number generator. */\n  seedRandom(value: i64): void;\n  /** Multiplies a floating point `x` by 2 raised to power exp `n`. */\n  scalbn(x: T, n: i32): T;\n  /** Returns the floating-point remainder of `x / y` (rounded towards zero). */\n  mod(x: T, y: T): T;\n  /** Returns the floating-point remainder of `x / y` (rounded to nearest). */\n  rem(x: T, y: T): T;\n  /** Returns sin and cos simultaneously for same angle. Results stored to `sincos_s32/64` and `sincos_c32/64` globals */\n  sincos(x: T): void;\n  /** Returns 2 raised to the given power x. Equivalent to 2 ** x. */\n  exp2(x: T): T;\n}\n\n/** Double precision math imported from JavaScript. */\ndeclare const JSMath: IMath<f64>;\n/** Double precision math implemented natively. */\ndeclare const NativeMath: INativeMath<f64>;\n/** Single precision math implemented natively. */\ndeclare const NativeMathf: INativeMath<f32>;\n/** Alias of {@link NativeMath} or {@link JSMath} respectively. Defaults to `NativeMath`. */\ndeclare const Math: IMath<f64>;\n/** Alias of {@link NativeMathf} or {@link JSMath} respectively. Defaults to `NativeMathf`. */\ndeclare const Mathf: IMath<f32>;\n\n/** Environmental abort function. */\ndeclare function abort(msg?: string | null, fileName?: string | null, lineNumber?: i32, columnNumber?: i32): never;\n/** Environmental tracing function. */\ndeclare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;\n/** Environmental seeding function. */\ndeclare function seed(): f64;\n\n/** Node-like process on top of WASI. */\ndeclare namespace process {\n  /** String representing the CPU architecture for which the binary was compiled. Either `wasm32` or `wasm64`. */\n  export const arch: string;\n  /** String representing the operating system platform for which the binary was compiled. Always `wasm`. */\n  export const platform: string;\n  /** Array of command line arguments passed to the binary upon instantiation. */\n  export const argv: string[];\n  /** Map of variables in the binary\'s user environment. */\n  export const env: Map<string,string>;\n  /** Process exit code to use when the process exits gracefully. Defaults to `0`. */\n  export var exitCode: i32;\n  /** Terminates the process with either the given exit code, or `process.exitCode` if omitted. */\n  export function exit(code?: i32): void;\n  /** Stream connected to `stdin` (fd `0`). */\n  export const stdin: ReadableStream;\n  /** Stream connected to `stdout` (fd `1`). */\n  export const stdout: WritableStream;\n  /** Stream connected to `stderr` (fd `2`). */\n  export const stderr: WritableStream;\n  /** Obtains the system\'s current time of day, in milliseconds since Unix epoch. */\n  export function time(): i64;\n  /** Obtains the system\'s monotonic high resolution time, in nanoseconds since an arbitrary time in the past. */\n  export function hrtime(): u64;\n\n  interface Stream {\n    /** Closes the stream. Throws if already closed or if the stream cannot be closed. */\n    close(): void;\n  }\n  interface ReadableStream extends Stream {\n    /** Reads available data from the stream, into `buffer` at offset `offset`, returning the number of bytes read. */\n    read(buffer: ArrayBuffer, offset?: isize): i32;\n  }\n  interface WritableStream extends Stream {\n    /** Writes string or buffer to the stream. */\n    write<T extends string | ArrayBuffer>(data: T): void;\n  }\n}\n\n/** Browser-like console on top of WASI. */\ndeclare namespace console {\n  /** Logs `message` to console if `assertion` is false-ish. */\n  export function assert<T>(assertion: T, message: string): void;\n  /** Outputs `message` to the console. */\n  export function log(message: string): void;\n  /** Outputs `message` to the console, prefixed with "Debug:". */\n  export function debug(message: string): void;\n  /** Outputs `message` to the console, prefixed with "Info:". */\n  export function info(message: string): void;\n  /** Outputs `message` to the console, prefixed with "Warning:". */\n  export function warn(message: string): void;\n  /** Outputs `message` to the console, prefixed with "Error:". */\n  export function error(message: string): void;\n  /** Starts a new timer using the specified `label`. */\n  export function time(label: string): void;\n  /** Logs the current value of a timer previously started with `console.time`. */\n  export function timeLog(label: string): void;\n  /** Logs the current value of a timer previously started with `console.time` and discards the timer. */\n  export function timeEnd(label: string): void;\n}\n\n/** Browser-like crypto utilities on top of WASI. */\ndeclare namespace crypto {\n  /** Fills `array` with cryptographically strong random values. */\n  export function getRandomValues(array: Uint8Array): void;\n}\n\n// Decorators\n\ninterface TypedPropertyDescriptor<T> {\n  configurable?: boolean;\n  enumerable?: boolean;\n  writable?: boolean;\n  value?: T;\n  get?(): T;\n  set?(value: T): void;\n}\n\n/** Annotates a method as a binary operator overload for the specified `token`. */\ndeclare function operator(token:\n  "[]" | "[]=" | "{}" | "{}=" | "==" | "!=" | ">" | "<" | "<=" | ">=" |\n  ">>" | ">>>" | "<<" |  "&"  | "|"  | "^"  | "+" | "-" | "*"  | "**" | "/"  | "%"\n): (\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<any>\n) => TypedPropertyDescriptor<any> | void;\n\ndeclare namespace operator {\n  /** Annotates a method as a binary operator overload for the specified `token`. */\n  export function binary(token:\n    "[]" | "[]=" | "{}" | "{}=" | "==" | "!=" | ">" | "<" | "<=" | ">=" |\n    ">>" | ">>>" | "<<" |  "&"  | "|"  | "^"  | "+" | "-" | "*"  | "**" | "/"  | "%"\n  ): (\n    target: any,\n    propertyKey: string,\n    descriptor: TypedPropertyDescriptor<any>\n  ) => TypedPropertyDescriptor<any> | void;\n  /** Annotates a method as an unary prefix operator overload for the specified `token`. */\n  export function prefix(token: "!" | "~" | "+" | "-" | "++" | "--"): (\n    target: any,\n    propertyKey: string,\n    descriptor: TypedPropertyDescriptor<any>\n  ) => TypedPropertyDescriptor<any> | void;\n  /** Annotates a method as an unary postfix operator overload for the specified `token`. */\n  export function postfix(token: "++" | "--"): (\n    target: any,\n    propertyKey: string,\n    descriptor: TypedPropertyDescriptor<any>\n  ) => TypedPropertyDescriptor<any> | void;\n}\n\n/** Annotates an element as a program global. */\ndeclare function global(...args: any[]): any;\n\n/** Annotates a class as being unmanaged with limited capabilities. */\ndeclare function unmanaged(constructor: Function): void;\n\n/** Annotates a class as being final / non-derivable. */\ndeclare function final(constructor: Function): void;\n\n/** Annotates a method, function or constant global as always inlined. */\ndeclare function inline(...args: any[]): any;\n\n/** Annotates a method, function or constant global as unsafe. */\ndeclare function unsafe(...args: any[]): any;\n\n/** Annotates an explicit external name of a function or global. */\ndeclare function external(...args: any[]): any;\n\n/** Annotates a global for lazy compilation. */\ndeclare function lazy(...args: any[]): any;\n',portable:'/**\n * Environment definitions for compiling AssemblyScript to JavaScript using tsc.\n *\n * Note that semantic differences require additional explicit conversions for full compatibility.\n * For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same\n * result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.\n *\n * Note that i64\'s are not portable (JS numbers are IEEE754 doubles with a maximum safe integer\n * value of 2^53-1) and instead require a compatibility layer to work in JS as well, as for example\n * {@link glue/js/i64} respectively {@link glue/wasm/i64}.\n *\n * @module std/portable\n *//***/\n\n// Types\n\ndeclare type bool = boolean;\ndeclare type i8 = number;\ndeclare type i16 = number;\ndeclare type i32 = number;\ndeclare type isize = number;\ndeclare type u8 = number;\ndeclare type u16 = number;\ndeclare type u32 = number;\ndeclare type usize = number;\ndeclare type f32 = number;\ndeclare type f64 = number;\n\n/** Special type evaluating the indexed access index type. */\ndeclare type indexof<T extends unknown[]> = keyof T;\n/** Special type evaluating the indexed access value type. */\ndeclare type valueof<T extends unknown[]> = T[0];\n\n// Compiler hints\n\n/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */\ndeclare const ASC_TARGET: i32;\n/** Provided noAssert option. */\ndeclare const ASC_NO_ASSERT: bool;\n/** Provided memoryBase option. */\ndeclare const ASC_MEMORY_BASE: i32;\n/** Provided optimizeLevel option. */\ndeclare const ASC_OPTIMIZE_LEVEL: i32;\n/** Provided shrinkLevel option. */\ndeclare const ASC_SHRINK_LEVEL: i32;\n/** Whether the mutable global feature is enabled. */\ndeclare const ASC_FEATURE_MUTABLE_GLOBAL: bool;\n/** Whether the sign extension feature is enabled. */\ndeclare const ASC_FEATURE_SIGN_EXTENSION: bool;\n\n// Builtins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */\ndeclare function popcnt<T = i32>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit integer. */\ndeclare function rotl<T = i32>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit integer. */\ndeclare function rotr<T = i32>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Emits an unreachable operation that results in a runtime error when executed. */\ndeclare function unreachable(): any; // sic\n\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */\ndeclare function unchecked<T>(value: T): T;\n/** Tests if the specified value is a valid integer. Can\'t distinguish an integer from an integral float. */\ndeclare function isInteger(value: any): value is number;\n/** Tests if the specified value is a valid float. Can\'t distinguish a float from an integer. */\ndeclare function isFloat(value: any): value is number;\n/** Tests if the specified value is of a nullable reference type. */\ndeclare function isNullable(value: any): bool;\n/** Tests if the specified value is of a reference type. */\ndeclare function isReference(value: any): value is object | string;\n/** Tests if the specified value is of a function type */\ndeclare function isFunction(value: any): value is Function;\n/** Tests if the specified value can be used as a string. */\ndeclare function isString(value: any): value is string | String;\n/** Tests if the specified value can be used as an array. */\ndeclare function isArray(value: any): value is Array<any>;\n/** Tests if the specified type *or* expression can be used as an array like object. */\ndeclare function isArrayLike(value: any): value is ArrayLike<any>;\n/** Tests if the specified expression resolves to a defined element. */\ndeclare function isDefined(expression: any): bool;\n/** Tests if the specified expression evaluates to a constant value. */\ndeclare function isConstant(expression: any): bool;\n/** Traps if the specified value is not true-ish, otherwise returns the value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses a floating point string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n/** Returns the 64-bit floating-point remainder of `x/y`. */\ndeclare function fmod(x: f64, y: f64): f64;\n/** Returns the 32-bit floating-point remainder of `x/y`. */\ndeclare function fmodf(x: f32, y: f32): f32;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: any): i8;\ndeclare namespace i8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i8;\n  /** Largest representable value. */\n  export const MAX_VALUE: i8;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): i8;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: any): i16;\ndeclare namespace i16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i16;\n  /** Largest representable value. */\n  export const MAX_VALUE: i16;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): i16;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: any): i32;\ndeclare namespace i32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i32;\n  /** Largest representable value. */\n  export const MAX_VALUE: i32;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): i32;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): i32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: any): isize;\ndeclare namespace isize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: isize;\n  /** Largest representable value. */\n  export const MAX_VALUE: isize;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): isize;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: any): u8;\ndeclare namespace u8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u8;\n  /** Largest representable value. */\n  export const MAX_VALUE: u8;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): u8;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: any): u16;\ndeclare namespace u16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u16;\n  /** Largest representable value. */\n  export const MAX_VALUE: u16;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): u16;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: any): u32;\ndeclare namespace u32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u32;\n  /** Largest representable value. */\n  export const MAX_VALUE: u32;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): u32;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): u32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: any): isize;\ndeclare namespace usize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: usize;\n  /** Largest representable value. */\n  export const MAX_VALUE: usize;\n  /** Converts a string to a floating-point number and cast to target integer after. */\n  export function parseFloat(string: string): usize;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: any): bool;\ndeclare namespace bool {\n  /** Smallest representable value. */\n  export const MIN_VALUE: bool;\n  /** Largest representable value. */\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: any): f32;\ndeclare namespace f32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f32;\n  /** Largest representable value. */\n  export const MAX_VALUE: f32;\n  /** Smallest normalized positive value. */\n  export const MIN_NORMAL_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Positive infinity value. */\n  export const POSITIVE_INFINITY: f32;\n  /** Negative infinity value. */\n  export const NEGATIVE_INFINITY: f32;\n  /** Not a number value. */\n  /* eslint no-shadow-restricted-names: "off" */\n  export const NaN: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\n  export function isNaN(value: f32): bool;\n  /** Returns true if passed value is finite. */\n  export function isFinite(value: f32): bool;\n  /** Returns true if the value passed is a safe integer. */\n  export function isSafeInteger(value: f32): bool;\n  /** Returns true if the value passed is an integer, false otherwise. */\n  export function isInteger(value: f32): bool;\n  /** Converts a string to a floating-point number. */\n  export function parseFloat(string: string): f32;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: any): f64;\ndeclare namespace f64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f64;\n  /** Largest representable value. */\n  export const MAX_VALUE: f64;\n  /** Smallest normalized positive value. */\n  export const MIN_NORMAL_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Positive infinity value. */\n  export const POSITIVE_INFINITY: f64;\n  /** Negative infinity value. */\n  export const NEGATIVE_INFINITY: f64;\n  /** Not a number value. */\n  /* eslint no-shadow-restricted-names: "off" */\n  export const NaN: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */\n  export function isNaN(value: f32): bool;\n  /** Returns true if passed value is finite. */\n  export function isFinite(value: f32): bool;\n  /** Returns true if the value passed is a safe integer. */\n  export function isSafeInteger(value: f64): bool;\n  /** Returns true if the value passed is an integer, false otherwise. */\n  export function isInteger(value: f64): bool;\n  /** Converts a string to a floating-point number. */\n  export function parseFloat(string: string): f64;\n  /** Converts A string to an integer. */\n  export function parseInt(string: string, radix?: i32): f64;\n}\n\n// Polyfills\n\n/** [Polyfill] Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i32 | u32 | isize | usize>(value: T): T;\n/** [Polyfill] Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i16 | u16 | i32 | u32>(value: T): T;\n\n// Standard library\n\ndeclare const Mathf: typeof Math;\ndeclare const JSMath: typeof Math;\n\ndeclare interface StringConstructor {\n  /** Equivalent to calling `String.fromCharCode` with multiple arguments. */\n  fromCharCodes(arr: u16[]): string;\n  /** Equivalent to calling `String.fromCodePoint` with multiple arguments. */\n  fromCodePoints(arr: i32[]): string;\n}\n\n/** Annotates a class as being unmanaged with limited capabilities. */\ndeclare function unmanaged(constructor: Function): void;\n\n/** Environmental tracing function. */\ndeclare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;\n\ndeclare interface Int8ArrayConstructor {\n  /** Equivalent to calling `new Int8Array` with multiple arguments. */\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;\n}\n\ndeclare interface Uint8ArrayConstructor {\n  /** Equivalent to calling `new Uint8Array` with multiple arguments. */\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;\n}\n\ndeclare interface Uint8ClampedArrayConstructor {\n  /** Equivalent to calling `new Uint8ClampedArray` with multiple arguments. */\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;\n}\n\ndeclare interface Int16ArrayConstructor {\n  /** Equivalent to calling `new Int16Array` with multiple arguments. */\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;\n}\n\ndeclare interface Uint16ArrayConstructor {\n  /** Equivalent to calling `new Uint16Array` with multiple arguments. */\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;\n}\n\ndeclare interface Int32ArrayConstructor {\n  /** Equivalent to calling `new Int32Array` with multiple arguments. */\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;\n}\n\ndeclare interface Uint32ArrayConstructor {\n  /** Equivalent to calling `new Uint32Array` with multiple arguments. */\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;\n}\n\ndeclare interface Float32ArrayConstructor {\n  /** Equivalent to calling `new Float32Array` with multiple arguments. */\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;\n}\n\ndeclare interface Float64ArrayConstructor {\n  /** Equivalent to calling `new Float64Array` with multiple arguments. */\n  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;\n}\n\n// FIXME: remove\ndeclare function offsetof<T>(fieldName?: string): usize;\ndeclare function idof<T>(): u32;\n'}:(()=>{const e=e=>r.readFileSync(i.join(".","..","std",e,"index"+m.ext_d),"utf8");return{assembly:e("assembly"),portable:e("portable")}})(),n.compileString=(e,t)=>{"string"==typeof e&&(e={["input"+m.ext]:e});const r=Object.create({stdout:D(),stderr:D()});var i=["--binaryFile","binary","--textFile","text"];return Object.keys(t||{}).forEach((e=>{var r=t[e],a=n.options[e];a&&"b"===a.type?r&&i.push("--"+e):Array.isArray(r)?r.forEach((n=>{i.push("--"+e,String(n))})):i.push("--"+e,String(r))})),n.main(i.concat(Object.keys(e)),{stdout:r.stdout,stderr:r.stderr,readFile:n=>Object.prototype.hasOwnProperty.call(e,n)?e[n]:null,writeFile:(e,n)=>{r[e]=n},listFiles:()=>[]}),r},n.main=function(e,t,s){"function"==typeof t?(s=t,t={}):t||(t={});const o=t.stdout||a.stdout,p=t.stderr||a.stderr,_=t.readFile||ce,F=t.writeFile||pe,C=t.listFiles||fe,N=t.stats||{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,initializeTime:0,initializeCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0,transformTime:0,transformCount:0};let k=m;if(!o)throw Error("'options.stdout' must be specified");if(!p)throw Error("'options.stderr' must be specified");const B=u.parse(e,n.options,!1);let D=B.options;e=B.arguments,D.noColors?l.stdout.supported=l.stderr.supported=!1:(l.stdout=l.from(o),l.stderr=l.from(p));const R=B.unknown;R.length&&R.forEach((e=>{p.write(l.stderr.yellow("WARNING ")+"Unknown option '"+e+"'"+h)}));const w=B.trailing;if(w.length&&p.write(l.stderr.yellow("WARNING ")+"Unsupported trailing arguments: "+w.join(" ")+h),s||(s=function(e){var n=0;return e&&(p.write(l.stderr.red("FAILURE ")+e.stack.replace(/^ERROR: /i,"")+h),n=1),n}),D.version)return o.write("Version "+n.version+h),s(null);if("string"==typeof D.extension){if(!/^\.?[0-9a-zA-Z]{1,14}$/.test(D.extension))return s(Error("Invalid extension: "+D.extension));k=x(D.extension)}const z=i.normalize(D.baseDir||".");let P=u.resolvePath(D.config||"asconfig.json",z),U=i.basename(P),M=i.dirname(P),G=I(U,M,_),V=null!=G&&Array.isArray(G.entries)&&G.entries.length;if(D.help||!e.length&&!V){var K=D.help?o:p,H=D.help?l.stdout:l.stderr;return K.write([H.white("SYNTAX"),"  "+H.cyan("asc")+" [entryFile ...] [options]","",H.white("EXAMPLES"),"  "+H.cyan("asc")+" hello"+k.ext,"  "+H.cyan("asc")+" hello"+k.ext+" -b hello.wasm -t hello.wat","  "+H.cyan("asc")+" hello1"+k.ext+" hello2"+k.ext+" -b -O > hello.wasm","  "+H.cyan("asc")+" --config asconfig.json --target release","",H.white("OPTIONS")].concat(u.help(n.options,24,h)).join(h)+h),s(null)}if(!r.readFileSync){if(_===ce)throw Error("'options.readFile' must be specified");if(F===pe)throw Error("'options.writeFile' must be specified");if(C===fe)throw Error("'options.listFiles' must be specified")}const W=new Set;W.add(P);const X=D.target||"release";for(;G;){if(G.targets){const e=G.targets[X];e&&(D=u.merge(n.options,D,e,M))}const t=G.options;if(t&&(D=u.merge(n.options,D,t,M)),G.entries)for(let n of G.entries)e.push(u.resolvePath(n,M));if(!G.extends)break;if(P=u.resolvePath(G.extends,M,!0),U=i.basename(P),M=i.dirname(P),W.has(P))break;W.add(P),G=I(U,M,_)}if(u.addDefaults(n.options,D),D.showConfig)return p.write(JSON.stringify({options:D,entries:e},null,2)),s(null);var Y;const j=b(y.newOptions());if(y.setTarget(j,0),y.setNoAssert(j,D.noAssert),y.setExportMemory(j,!D.noExportMemory),y.setImportMemory(j,D.importMemory),y.setInitialMemory(j,D.initialMemory>>>0),y.setMaximumMemory(j,D.maximumMemory>>>0),y.setSharedMemory(j,D.sharedMemory),y.setImportTable(j,D.importTable),y.setExportTable(j,D.exportTable),y.setExplicitStart(j,D.explicitStart),y.setMemoryBase(j,D.memoryBase>>>0),y.setTableBase(j,D.tableBase>>>0),y.setSourceMap(j,null!=D.sourceMap),y.setNoUnsafe(j,D.noUnsafe),y.setPedantic(j,D.pedantic),y.setLowMemoryLimit(j,D.lowMemoryLimit>>>0),y.setExportRuntime(j,D.exportRuntime),D.stackSize||"incremental"!=D.runtime||(D.stackSize=y.DEFAULT_STACK_SIZE),y.setStackSize(j,D.stackSize),s=function(e){return function(n){return v(j),Y&&v(Y),A(),e(n)}}(s),D.use){let e=D.use;for(let n=0,t=e.length;n<t;++n){let t=e[n],r=t.indexOf("=");if(r<0)return s(Error("Global alias '"+t+"' is invalid."));let i=t.substring(0,r).trim(),a=t.substring(r+1).trim();if(!i.length)return s(Error("Global alias '"+t+"' is invalid."));{let e=b(E(i)),n=E(a);y.setGlobalAlias(j,e,n),v(e)}}}var q;if(null!=(q=D.disable)){"string"==typeof q&&(q=q.split(","));for(let e=0,n=q.length;e<n;++e){let n=q[e].trim(),t=y["FEATURE_"+n.replace(/-/g,"_").toUpperCase()];if(!t)return s(Error("Feature '"+n+"' is unknown."));y.disableFeature(j,t)}}if(null!=(q=D.enable)){"string"==typeof q&&(q=q.split(","));for(let e=0,n=q.length;e<n;++e){let n=q[e].trim(),t=y["FEATURE_"+n.replace(/-/g,"_").toUpperCase()];if(!t)return s(Error("Feature '"+n+"' is unknown."));y.enableFeature(j,t)}}var Q=0,Z=0;D.optimize&&(Q=n.defaultOptimizeLevel,Z=n.defaultShrinkLevel),"number"==typeof D.optimizeLevel&&(Q=D.optimizeLevel),"number"==typeof D.shrinkLevel&&(Z=D.shrinkLevel),Q=Math.min(Math.max(Q,0),3),Z=Math.min(Math.max(Z,0),2),y.setOptimizeLevelHints(j,Q,Z),Y=b(y.newProgram(j));const J=[];function $(e,...n){for(let t=0,r=J.length;t<r;++t){let r=J[t];if("function"==typeof r[e])try{N.transformCount++,N.transfromTime+=O((()=>{r[e](...n)}))}catch(e){return e}}}Object.keys(n.libraryFiles).forEach((e=>{e.indexOf("/")>=0||(N.parseCount++,N.parseTime+=O((()=>{let t=b(E(n.libraryFiles[e])),r=E(n.libraryPrefix+e+k.ext);y.parse(Y,t,r,!1),v(t)})))}));let ee=[];if(D.lib){let e=D.lib;"string"==typeof e&&(e=e.split(",")),ee.push(...e.map((e=>e.trim()))),ee=[...new Set(ee)];for(let e=0,t=ee.length;e<t;++e){let t,r=ee[e];r.endsWith(k.ext)?(t=[i.basename(r)],r=i.dirname(r)):t=C(r,z)||[];for(let e=0,i=t.length;e<i;++e){let i=t[e],a=_(i,r);if(null===a)return s(Error("Library file '"+i+"' not found."));N.parseCount++,n.libraryFiles[i.replace(k.re,"")]=a,N.parseTime+=O((()=>{let e=b(E(a)),t=E(n.libraryPrefix+i);y.parse(Y,e,t,!1),v(e)}))}}}D.path=D.path||[];var ne,te=new Map,re=new Map;function ie(e,t){var r=null,a=null;const s=n.libraryPrefix,o=n.libraryFiles;if(e.startsWith(s)){const n=e.substring(s.length),l=n+"/index";if(Object.prototype.hasOwnProperty.call(o,n))r=o[n],a=s+n+k.ext;else if(Object.prototype.hasOwnProperty.call(o,l))r=o[l],a=s+l+k.ext;else{for(const e of ee){if(null!=(r=_(n+k.ext,e))){a=s+n+k.ext;break}if(null!=(r=_(l+k.ext,e))){a=s+l+k.ext;break}}if(null==r){const n=e.match(/^~lib\/((?:@[^/]+\/)?[^/]+)(?:\/(.+))?/);if(n){const e=n[1],o=void 0===n[2],l=o?"index":n[2],u=re.has(t)?re.get(t):".";D.traceResolution&&p.write("Looking for package '"+e+"' file '"+l+"' relative to '"+u+"'"+h);const c=[],f=i.resolve(z,u).split(g);for(let e=f.length,n=d?1:0;e>=n;--e)"node_modules"!==f[e-1]&&c.push(f.slice(0,e).join(g)+g+"node_modules");for(const n of c.concat(...D.path).map((e=>i.relative(z,e)))){D.traceResolution&&p.write("  in "+i.join(n,e)+h);let t="assembly";if(te.has(e))t=te.get(e);else{let r=i.join(n,e,"package.json"),a=_(r,z);if(null!=a)try{let n=JSON.parse(a);"string"==typeof n.ascMain&&(t=n.ascMain.replace(k.re_index,""),te.set(e,t))}catch(e){}}const u=i.join(n,e,t),c=l;if(null!=(r=_(i.join(u,c+k.ext),z))){a=s+e+"/"+c+k.ext,re.set(a.replace(k.re,""),i.join(n,e)),D.traceResolution&&p.write("  -> "+i.join(u,c+k.ext)+h);break}if(!o){const t=l+"/index";if(null!==(r=_(i.join(u,t+k.ext),z))){a=s+e+"/"+t+k.ext,re.set(a.replace(k.re,""),i.join(n,e)),D.traceResolution&&p.write("  -> "+i.join(u,t+k.ext)+h);break}}}}}}}else null==(r=_(a=e+k.ext,z))&&null==(r=_(a=e+"/index"+k.ext,z))&&(a=e+k.ext,r=_(e+k.ext_d,z));return null==r?null:{sourceText:r,sourcePath:a}}function ae(){for(var e;e=T(y.nextFile(Y));){let n=ie(e,y.getDependee(Y,e));n?(N.parseCount++,N.parseTime+=O((()=>{let e=b(E(n.sourceText)),t=E(n.sourcePath);y.parse(Y,e,t,!1),v(e)}))):N.parseTime+=O((()=>{let n=E(null),t=E(e+k.ext);y.parse(Y,n,t,!1)}))}var n=S(Y,p,t.reportDiagnostic);if(n){const e=Error(n+" parse error(s)");return e.stack=e.message,s(e)}}{let e=String(D.runtime),t="rt/index-"+e,r=n.libraryFiles[t];if(null==r){if(t=e,r=_(t+k.ext,z),null==r)return s(Error(`Runtime '${e}' not found.`))}else t="~lib/"+t;N.parseCount++,N.parseTime+=O((()=>{let e=b(E(r)),n=E(t+k.ext);y.parse(Y,e,n,!0),v(e)}))}for(let n=0,t=e.length;n<t;++n){const t=e[n];let r=String(t).replace(/\\/g,"/").replace(k.re,"").replace(/[\\/]$/,"");r=i.isAbsolute(r)?i.relative(z,r).replace(/\\/g,"/"):r;let a=_(r+k.ext,z);null==a?(a=_(r+"/index"+k.ext,z),r+=null!=a?"/index"+k.ext:k.ext):r+=k.ext,N.parseCount++,N.parseTime+=O((()=>{let e=b(E(a)),n=E(r);y.parse(Y,e,n,!0),v(e)}))}{let e=ae();if(e)return e}{let e=$("afterParse",Y.parser);if(e)return s(e)}{let e=ae();if(e)return e}if(D.listFiles)return p.write(Y.sources.map((e=>e.normalizedPath)).sort().join(h)+h),s(null);N.initializeCount++,N.initializeTime+=O((()=>{y.initializeProgram(Y)}));{let e=$("afterInitialize",Y);if(e)return s(e)}N.compileCount++,N.compileTime+=O((()=>{if("number"==typeof(ne=y.compile(Y))){const e=y.Module.wrap(ne);(ne=f.wrapModule(e.ref)).optimize=function(...n){e.optimize(...n)}}else{const e=ne;(ne=f.wrapModule(ne.ref)).optimize=function(...n){e.optimize(...n)}}}));var se=S(Y,p,t.reportDiagnostic);if(se){ne&&ne.dispose();const e=Error(se+" compile error(s)");return e.stack=e.message,s(e)}{let e=$("afterCompile",ne);if(e)return s(e)}if(!D.noValidate){let e;if(N.validateCount++,N.validateTime+=O((()=>{e=ne.validate()})),!e)return ne.dispose(),s(Error("validate error"))}if("clamp"===D.trapMode)N.optimizeCount++,N.optimizeTime+=O((()=>{ne.runPass("trap-mode-clamp")}));else if("js"===D.trapMode)N.optimizeCount++,N.optimizeTime+=O((()=>{ne.runPass("trap-mode-js")}));else if("allow"!==D.trapMode)return ne.dispose(),s(Error("Unsupported trap mode"));const oe=D.debug,le=D.converge,ue=[];if(D.runPasses&&("string"==typeof D.runPasses&&(D.runPasses=D.runPasses.split(",")),D.runPasses.length&&D.runPasses.forEach((e=>{ue.indexOf(e=e.trim())<0&&ue.push(e)}))),N.optimizeTime+=O((()=>{if(N.optimizeCount++,ne.optimize(Q,Z,oe),ne.runPasses(ue),le){let e=ne.emitBinary();for(;;){N.optimizeCount++,ne.optimize(Q,Z,oe),ne.runPasses(ue);let n=ne.emitBinary();if(n.length>=e.length){n.length>e.length&&p.write("Last converge was suboptimial."+h);break}e=n}}})),!D.noEmit){null!=D.outFile&&(/\.was?t$/.test(D.outFile)&&null==D.textFile?D.textFile=D.outFile:/\.js$/.test(D.outFile)&&null==D.jsFile?D.jsFile=D.outFile:null==D.binaryFile&&(D.binaryFile=D.outFile));let e=!1,n=null!=D.textFile||null!=D.binaryFile||null!=D.jsFile||null!=D.tsdFile||null!=D.idlFile;if(null!=D.binaryFile){let n,t=i.basename(D.binaryFile),r=null!=D.sourceMap?D.sourceMap.length?D.sourceMap:"./"+t+".map":null;if(N.emitCount++,N.emitTime+=O((()=>{n=ne.emitBinary(r)})),D.binaryFile.length?F(D.binaryFile,n.binary,z):(de(n.binary),e=!0),""!=n.sourceMap)if(D.binaryFile.length){let e=JSON.parse(n.sourceMap);e.sourceRoot="./"+t;let a=[];e.sources.forEach(((e,n)=>{let t=y.getSource(Y,E(e.replace(k.re,"")));if(null==t)return s(Error("Source of file '"+e+"' not found."));a[n]=t})),e.sourcesContent=a,F(i.join(i.dirname(D.binaryFile),i.basename(r)).replace(/^\.\//,""),JSON.stringify(e),z)}else p.write("Skipped source map (stdout already occupied)"+h)}if(null!=D.textFile||!n){let n;if(null!=D.textFile&&D.textFile.length){let e=D.textFile.endsWith(".wast");N.emitCount++,N.emitTime+=O((()=>{n=e?ne.emitText():ne.emitStackIR(!0)})),F(D.textFile,n,z)}else e||(N.emitCount++,N.emitTime+=O((()=>{n=ne.emitStackIR(!0)})),de(n))}if(null!=D.idlFile){let n;D.idlFile.length?(N.emitCount++,N.emitTime+=O((()=>{n=y.buildIDL(Y)})),F(D.idlFile,T(n),z)):e||(N.emitCount++,N.emitTime+=O((()=>{n=y.buildIDL(Y)})),de(T(n)),e=!0)}if(null!=D.tsdFile){let n;D.tsdFile.length?(N.emitCount++,N.emitTime+=O((()=>{n=y.buildTSD(Y)})),F(D.tsdFile,T(n),z)):e||(N.emitCount++,N.emitTime+=O((()=>{n=y.buildTSD(Y)})),de(T(n)),e=!0)}if(null!=D.jsFile){let n;D.jsFile.length?(N.emitCount++,N.emitTime+=O((()=>{n=ne.emitAsmjs()})),F(D.jsFile,n,z)):e||(N.emitCount++,N.emitTime+=O((()=>{n=ne.emitAsmjs()})),de(n))}}return ne.dispose(),D.measure&&L(N,p),s(null);function ce(e,n){let t=i.resolve(n,e);try{let e;return N.readCount++,N.readTime+=O((()=>{e=r.readFileSync(t,"utf8")})),e}catch(e){return null}}function pe(e,n,t){try{return N.writeCount++,N.writeTime+=O((()=>{const a=i.resolve(t,i.dirname(e));e=i.basename(e);const s=i.join(a,e);r.existsSync(a)||c(a),r.writeFileSync(s,n)})),!0}catch(e){return!1}}function fe(e,n){var t;try{return N.readCount++,N.readTime+=O((()=>{t=r.readdirSync(i.join(n,e)).filter((e=>k.re_except_d.test(e)))})),t}catch(e){return null}}function de(e){de.used||(N.writeCount++,de.used=!0),N.writeTime+=O((()=>{o.write(e)}))}};const F=Object.prototype.toString;function C(e){return"[object Object]"===F.call(e)}function I(e,n,t){const r=t(e,n),a=i.join(n,e);if(!r)return null;let s;try{s=JSON.parse(r)}catch(e){throw new Error("Asconfig is not valid json: "+a)}if(s.options&&!C(s.options))throw new Error("Asconfig.options is not an object: "+a);if(s.include&&!Array.isArray(s.include))throw new Error("Asconfig.include is not an array: "+a);if(s.targets){if(!C(s.targets))throw new Error("Asconfig.targets is not an object: "+a);const e=Object.keys(s.targets);for(let n=0;n<e.length;n++){const t=e[n];if(!C(s.targets[t]))throw new Error("Asconfig.targets."+t+" is not an object: "+a)}}if(s.extends&&"string"!=typeof s.extends)throw new Error("Asconfig.extends is not a string: "+a);return s}function S(e,n,t){for(var r=0;;){let i=y.nextDiagnostic(e);if(!i)break;if(b(i),n&&n.write(T(y.formatDiagnostic(i,n.isTTY,!0))+h+h),t){const e=_(i,y.DiagnosticMessage),n=_(e.range,y.Range),r=_(e.relatedRange,y.Range),a=n?_(n.source,y.Source):null,s=r?_(r.source,y.Source):null;t({message:T(e.message),code:e.code,category:e.category,range:n?{start:n.start,end:n.end,source:a?{normalizedPath:T(a.normalizedPath)}:null}:null,relatedRange:r?{start:r.start,end:r.end,source:s?{normalizedPath:T(s.normalizedPath)}:null}:null})}y.isError(i)&&++r,v(i)}return r}function N(){return{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,initializeTime:0,initializeCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0,transformTime:0,transformCount:0}}function O(e){const n=a.hrtime();e();const t=a.hrtime(n);return 1e9*t[0]+t[1]}function k(e){return e?(e/1e6).toFixed(3)+" ms":"n/a"}function L(e,n){const t=(e,n)=>function(e,n){for(;e.length<n;)e=" "+e;return e}(k(e),12)+"  n="+n;(n||a.stdout).write(["I/O Read   : "+t(e.readTime,e.readCount),"I/O Write  : "+t(e.writeTime,e.writeCount),"Parse      : "+t(e.parseTime,e.parseCount),"Initialize : "+t(e.initializeTime,e.initializeCount),"Compile    : "+t(e.compileTime,e.compileCount),"Emit       : "+t(e.emitTime,e.emitCount),"Validate   : "+t(e.validateTime,e.validateCount),"Optimize   : "+t(e.optimizeTime,e.optimizeCount),"Transform  : "+t(e.transformTime,e.transformCount),""].join(h)+h)}n.getAsconfig=I,n.checkDiagnostics=S,n.createStats=N,n.measure=O,n.formatTime=k,n.printStats=L;var B=void 0!==t.g&&t.g.Buffer?t.g.Buffer.allocUnsafe||(e=>new t.g.Buffer(e)):e=>new Uint8Array(e);function D(e){var n=[];return n.write=function(n){if(e&&e(n),"string"==typeof n){let e=B(o.length(n));o.write(n,e,0),n=e}this.push(n)},n.reset=function(){n.length=0},n.toBuffer=function(){for(var e=0,n=0,t=this.length;n<t;)e+=this[n++].length;var r=B(e);for(e=n=0;n<t;)r.set(this[n],e),e+=this[n].length,++n;return r},n.toString=function(){var e=this.toBuffer();return o.read(e,0,e.length)},n}n.createMemoryStream=D,n.tscOptions={alwaysStrict:!0,noImplicitAny:!0,noImplicitReturns:!0,noImplicitThis:!0,noEmitOnError:!0,strictNullChecks:!0,experimentalDecorators:!0,target:"esnext",module:"commonjs",noLib:!0,types:[],allowJs:!1}},422:e=>{"use strict";e.exports=JSON.parse('{"version":{"category":"General","description":"Prints just the compiler\'s version and exits.","type":"b","alias":"v"},"help":{"category":"General","description":"Prints this message and exits.","type":"b","alias":"h"},"noColors":{"category":"General","description":"Disables terminal colors.","type":"b","default":false},"config":{"category":"General","description":"Configuration file to apply. CLI arguments take precedence.","type":"s","cliOnly":true},"target":{"category":"General","description":"Target configuration to use. Defaults to \'release\'.","type":"s","cliOnly":true},"optimize":{"category":"Optimization","description":["Optimizes the module. Typical shorthands are:",""," Default optimizations   -O / -O3s"," Make a release build    -O --noAssert"," Make a debug build      --debug"," Optimize for speed      -O3"," Optimize for size       -O3z --converge",""],"type":"b","alias":"O"},"optimizeLevel":{"category":"Optimization","description":"How much to focus on optimizing code. [0-3]","type":"i"},"shrinkLevel":{"category":"Optimization","description":"How much to focus on shrinking code size. [0-2, s=1, z=2]","type":"i"},"converge":{"category":"Optimization","description":"Re-optimizes until no further improvements can be made.","type":"b","default":false},"noAssert":{"category":"Optimization","description":"Replaces assertions with just their value without trapping.","type":"b","default":false},"outFile":{"category":"Output","description":"Specifies the output file. File extension indicates format.","type":"s","alias":"o","isPath":true},"binaryFile":{"category":"Output","description":"Specifies the binary output file (.wasm).","type":"s","alias":"b","isPath":true},"textFile":{"category":"Output","description":"Specifies the text output file (.wat).","type":"s","alias":"t","isPath":true},"jsFile":{"category":"Output","description":"Specifies the JavaScript (via wasm2js) output file (.js).","type":"s","alias":"j","isPath":true},"idlFile":{"category":"Output","description":"Specifies the WebIDL output file (.webidl).","type":"s","alias":"i","isPath":true},"tsdFile":{"category":"Output","description":"Specifies the TypeScript definition output file (.d.ts).","type":"s","alias":"d","isPath":true},"sourceMap":{"category":"Debugging","description":["Enables source map generation. Optionally takes the URL","used to reference the source map from the binary file."],"type":"s"},"debug":{"category":"Debugging","description":"Enables debug information in emitted binaries.","type":"b","default":false},"importMemory":{"category":"Features","description":"Imports the memory from \'env.memory\'.","type":"b","default":false},"noExportMemory":{"category":"Features","description":"Does not export the memory as \'memory\'.","type":"b","default":false},"initialMemory":{"category":"Features","description":"Sets the initial memory size in pages.","type":"i","default":0},"maximumMemory":{"category":"Features","description":"Sets the maximum memory size in pages.","type":"i","default":0},"sharedMemory":{"category":"Features","description":"Declare memory as shared. Requires maximumMemory.","type":"b","default":false},"importTable":{"category":"Features","description":"Imports the function table from \'env.table\'.","type":"b","default":false},"exportTable":{"category":"Features","description":"Exports the function table as \'table\'.","type":"b","default":false},"runtime":{"category":"Features","description":["Specifies the runtime variant to include in the program.",""," incremental  TLSF + incremental GC (default)"," minimal      TLSF + lightweight GC invoked externally"," stub         Minimal runtime stub (never frees)"," ...          Path to a custom runtime implementation",""],"type":"s","default":"incremental"},"exportRuntime":{"category":"Features","description":"Exports the runtime helpers (__new, __collect etc.).","type":"b","default":false},"stackSize":{"category":"Features","description":["Overrides the stack size. Only relevant for incremental GC","or when using a custom runtime that requires stack space.","Defaults to 0 without and to 16384 with incremental GC."],"default":0,"type":"i"},"explicitStart":{"category":"Features","description":"Exports an explicit \'_start\' function to call.","type":"b","default":false},"enable":{"category":"Features","description":["Enables WebAssembly features being disabled by default.",""," sign-extension      Sign-extension operations"," nontrapping-f2i     Non-trapping float to integer ops."," bulk-memory         Bulk memory operations."," simd                SIMD types and operations."," threads             Threading and atomic operations."," reference-types     Reference types and operations."," gc                  Garbage collection (anyref, WIP).",""],"TODO_doesNothingYet":[" exception-handling  Exception handling."," tail-calls          Tail call operations."," multi-value         Multi value types."," memory64            Memory64 operations."],"type":"S","mutuallyExclusive":"disable"},"disable":{"category":"Features","description":["Disables WebAssembly features being enabled by default.",""," mutable-globals     Mutable global imports and exports.",""],"type":"S","mutuallyExclusive":"enable"},"use":{"category":"Features","description":["Aliases a global object under another name, e.g., to switch","the default \'Math\' implementation used: --use Math=JSMath","Can also be used to introduce an integer constant."],"type":"S","alias":"u"},"lowMemoryLimit":{"category":"Features","description":"Enforces very low (<64k) memory constraints.","default":0,"type":"i"},"memoryBase":{"category":"Linking","description":"Sets the start offset of emitted memory segments.","type":"i","default":0},"tableBase":{"category":"Linking","description":"Sets the start offset of emitted table elements.","type":"i","default":0},"transform":{"category":"API","description":"Specifies the path to a custom transform to \'require\'.","type":"S","isPath":true,"useNodeResolution":true},"trapMode":{"category":"Binaryen","description":["Sets the trap mode to use.",""," allow  Allow trapping operations. This is the default."," clamp  Replace trapping operations with clamping semantics."," js     Replace trapping operations with JS semantics.",""],"type":"s","default":"allow"},"runPasses":{"category":"Binaryen","description":["Specifies additional Binaryen passes to run after other","optimizations, if any. See: Binaryen/src/passes/pass.cpp"],"type":"s"},"noValidate":{"category":"Binaryen","description":"Skips validating the module using Binaryen.","type":"b","default":false},"baseDir":{"description":"Specifies the base directory of input and output files.","type":"s","default":"."},"extension":{"description":"Specifies an alternative file extension to use.","type":"s","cliOnly":true},"noUnsafe":{"description":["Disallows the use of unsafe features in user code.","Does not affect library files and external modules."],"type":"b","default":false},"noEmit":{"description":"Performs compilation as usual but does not emit code.","type":"b","default":false},"showConfig":{"description":"Print computed compiler options and exit.","type":"b","default":false},"measure":{"description":"Prints measuring information on I/O and compile times.","type":"b","default":false},"pedantic":{"description":"Make yourself sad for no good reason.","type":"b","default":false},"lib":{"description":["Adds one or multiple paths to custom library components and","uses exports of all top-level files at this path as globals."],"type":"S","isPath":true},"path":{"description":["Adds one or multiple paths to package resolution, similar","to node_modules. Prefers an \'ascMain\' entry in a package\'s","package.json and falls back to an inner \'assembly/\' folder."],"type":"S","isPath":true},"traceResolution":{"description":"Enables tracing of package resolution.","type":"b","default":false},"listFiles":{"description":"Lists files to be compiled and exits.","type":"b","default":false},"wasm":{"description":"Uses the specified Wasm binary of the compiler.","type":"s"}," ...":{"description":"Specifies node.js options (CLI only). See: node --help"},"-Os":{"value":{"optimize":true,"shrinkLevel":1}},"-Oz":{"value":{"optimize":true,"shrinkLevel":2}},"-O0":{"value":{"optimizeLevel":0,"shrinkLevel":0}},"-O1":{"value":{"optimizeLevel":1,"shrinkLevel":0}},"-O2":{"value":{"optimizeLevel":2,"shrinkLevel":0}},"-O3":{"value":{"optimizeLevel":3,"shrinkLevel":0}},"-O0s":{"value":{"optimizeLevel":0,"shrinkLevel":1}},"-O1s":{"value":{"optimizeLevel":1,"shrinkLevel":1}},"-O2s":{"value":{"optimizeLevel":2,"shrinkLevel":1}},"-O3s":{"value":{"optimizeLevel":3,"shrinkLevel":1}},"-O0z":{"value":{"optimizeLevel":0,"shrinkLevel":2}},"-O1z":{"value":{"optimizeLevel":1,"shrinkLevel":2}},"-O2z":{"value":{"optimizeLevel":2,"shrinkLevel":2}},"-O3z":{"value":{"optimizeLevel":3,"shrinkLevel":2}}}')},551:e=>{e.exports={}},484:(e,n,t)=>{const r=t(286);function i(e){if("string"!=typeof e)throw new TypeError("Path must be a string. Received "+JSON.stringify(e))}function a(e,n){for(var t,r="",i=0,a=-1,s=0,o=0;o<=e.length;++o){if(o<e.length)t=e.charCodeAt(o);else{if(47===t)break;t=47}if(47===t){if(a===o-1||1===s);else if(a!==o-1&&2===s){if(r.length<2||2!==i||46!==r.charCodeAt(r.length-1)||46!==r.charCodeAt(r.length-2))if(r.length>2){var l=r.lastIndexOf("/");if(l!==r.length-1){-1===l?(r="",i=0):i=(r=r.slice(0,l)).length-1-r.lastIndexOf("/"),a=o,s=0;continue}}else if(2===r.length||1===r.length){r="",i=0,a=o,s=0;continue}n&&(r.length>0?r+="/..":r="..",i=2)}else r.length>0?r+="/"+e.slice(a+1,o):r=e.slice(a+1,o),i=o-a-1;a=o,s=0}else 46===t&&-1!==s?++s:s=-1}return r}var s={resolve:function(){for(var e,n="",t=!1,s=arguments.length-1;s>=-1&&!t;s--){var o;s>=0?o=arguments[s]:(void 0===e&&(e=r.cwd()),o=e),i(o),0!==o.length&&(n=o+"/"+n,t=47===o.charCodeAt(0))}return n=a(n,!t),t?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(e){if(i(e),0===e.length)return".";var n=47===e.charCodeAt(0),t=47===e.charCodeAt(e.length-1);return 0!==(e=a(e,!n)).length||n||(e="."),e.length>0&&t&&(e+="/"),n?"/"+e:e},isAbsolute:function(e){return i(e),e.length>0&&47===e.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var e,n=0;n<arguments.length;++n){var t=arguments[n];i(t),t.length>0&&(void 0===e?e=t:e+="/"+t)}return void 0===e?".":s.normalize(e)},relative:function(e,n){if(i(e),i(n),e===n)return"";if((e=s.resolve(e))===(n=s.resolve(n)))return"";if("."===e)return n;for(var t=1;t<e.length&&47===e.charCodeAt(t);++t);for(var r=e.length,a=r-t,o=1;o<n.length&&47===n.charCodeAt(o);++o);for(var l=n.length-o,u=a<l?a:l,c=-1,p=0;p<=u;++p){if(p===u){if(l>u){if(47===n.charCodeAt(o+p))return n.slice(o+p+1);if(0===p)return n.slice(o+p)}else a>u&&(47===e.charCodeAt(t+p)?c=p:0===p&&(c=0));break}var f=e.charCodeAt(t+p);if(f!==n.charCodeAt(o+p))break;47===f&&(c=p)}var d="";for(p=t+c+1;p<=r;++p)p!==r&&47!==e.charCodeAt(p)||(0===d.length?d+="..":d+="/..");return d.length>0?d+n.slice(o+c):(o+=c,47===n.charCodeAt(o)&&++o,n.slice(o))},_makeLong:function(e){return e},dirname:function(e){if(i(e),0===e.length)return".";for(var n=e.charCodeAt(0),t=47===n,r=-1,a=!0,s=e.length-1;s>=1;--s)if(47===(n=e.charCodeAt(s))){if(!a){r=s;break}}else a=!1;return-1===r?t?"/":".":t&&1===r?"//":e.slice(0,r)},basename:function(e,n){if(void 0!==n&&"string"!=typeof n)throw new TypeError('"ext" argument must be a string');i(e);var t,r=0,a=-1,s=!0;if(void 0!==n&&n.length>0&&n.length<=e.length){if(n.length===e.length&&n===e)return"";var o=n.length-1,l=-1;for(t=e.length-1;t>=0;--t){var u=e.charCodeAt(t);if(47===u){if(!s){r=t+1;break}}else-1===l&&(s=!1,l=t+1),o>=0&&(u===n.charCodeAt(o)?-1==--o&&(a=t):(o=-1,a=l))}return r===a?a=l:-1===a&&(a=e.length),e.slice(r,a)}for(t=e.length-1;t>=0;--t)if(47===e.charCodeAt(t)){if(!s){r=t+1;break}}else-1===a&&(s=!1,a=t+1);return-1===a?"":e.slice(r,a)},extname:function(e){i(e);for(var n=-1,t=0,r=-1,a=!0,s=0,o=e.length-1;o>=0;--o){var l=e.charCodeAt(o);if(47!==l)-1===r&&(a=!1,r=o+1),46===l?-1===n?n=o:1!==s&&(s=1):-1!==n&&(s=-1);else if(!a){t=o+1;break}}return-1===n||-1===r||0===s||1===s&&n===r-1&&n===t+1?"":e.slice(n,r)},format:function(e){if(null===e||"object"!=typeof e)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof e);return function(e,n){var t=n.dir||n.root,r=n.base||(n.name||"")+(n.ext||"");return t?t===n.root?t+r:t+e+r:r}("/",e)},parse:function(e){i(e);var n={root:"",dir:"",base:"",ext:"",name:""};if(0===e.length)return n;var t,r=e.charCodeAt(0),a=47===r;a?(n.root="/",t=1):t=0;for(var s=-1,o=0,l=-1,u=!0,c=e.length-1,p=0;c>=t;--c)if(47!==(r=e.charCodeAt(c)))-1===l&&(u=!1,l=c+1),46===r?-1===s?s=c:1!==p&&(p=1):-1!==s&&(p=-1);else if(!u){o=c+1;break}return-1===s||-1===l||0===p||1===p&&s===l-1&&s===o+1?-1!==l&&(n.base=n.name=0===o&&a?e.slice(1,l):e.slice(o,l)):(0===o&&a?(n.name=e.slice(1,s),n.base=e.slice(1,l)):(n.name=e.slice(o,s),n.base=e.slice(o,l)),n.ext=e.slice(s,l)),o>0?n.dir=e.slice(0,o-1):a&&(n.dir="/"),n},sep:"/",delimiter:":",win32:null,posix:null};s.posix=s,e.exports=s},286:(e,n,t)=>{e.exports={platform:"linux",cwd:()=>".",umask:()=>0,hrtime:function(e){var n=i.call(r),t=Math.floor(.001*n),a=Math.floor(1e6*n-1e9*t);e&&(t-=e[0],(a-=e[1])<0&&(t--,a+=1e9));return[t,a]},argv:[]};var r=t.g.performance||{},i=r.now||r.mozNow||r.msNow||r.oNow||r.webkitNow||function(){return(new Date).getTime()}},820:(e,n)=>{var t="undefined"!=typeof process&&process||{},r=t.env&&"CI"in t.env;function i(e,t){var i=t||{};return i.supported=e&&!!e.isTTY||r,i.gray=e=>i.supported?n.GRAY+e+n.RESET:e,i.red=e=>i.supported?n.RED+e+n.RESET:e,i.green=e=>i.supported?n.GREEN+e+n.RESET:e,i.yellow=e=>i.supported?n.YELLOW+e+n.RESET:e,i.blue=e=>i.supported?n.BLUE+e+n.RESET:e,i.magenta=e=>i.supported?n.MAGENTA+e+n.RESET:e,i.cyan=e=>i.supported?n.CYAN+e+n.RESET:e,i.white=e=>i.supported?n.WHITE+e+n.RESET:e,i}n.stdout=i(t.stdout,n),n.stderr=i(t.stderr),n.from=i,n.GRAY="[90m",n.RED="[91m",n.GREEN="[92m",n.YELLOW="[93m",n.BLUE="[94m",n.MAGENTA="[95m",n.CYAN="[96m",n.WHITE="[97m",n.RESET="[0m"},790:(e,n,t)=>{const r=t(551),i=t(484);n.files=function e(n,t){var a=[];return r.readdirSync(n).forEach((s=>{r.statSync(i.join(n,s)).isDirectory()?e(i.join(n,s),t).forEach((e=>a.push(s+"/"+e))):(t&&"function"!=typeof t?t.test(s):t(s))&&a.push(s)})),a}},342:(e,n,t)=>{const r=t(484),i=t(551),a=t(286);e.exports=function e(n,t,s){t&&"object"==typeof t||(t={mode:t});var o=t.mode;void 0===o&&(o=511&~a.umask()),s||(s=null),n=r.resolve(n);try{i.mkdirSync(n,o),s=s||n}catch(a){switch(a.code){case"ENOENT":s=e(r.dirname(n),t,s),e(n,t,s);break;default:var l;try{l=i.statSync(n)}catch(e){throw a}if(!l.isDirectory())throw a}}return s}},565:(e,n,t)=>{const r=t(484),i=t(820);function a(e,n){if(null!=e)switch(n){case void 0:case"b":return Boolean(e);case"i":return Math.trunc(e)||0;case"f":return Number(e)||0;case"s":return!0===e?"":String(e);case"I":return Array.isArray(e)||(e=[e]),e.map((e=>Math.trunc(e)||0));case"F":return Array.isArray(e)||(e=[e]),e.map((e=>Number(e)||0));case"S":return Array.isArray(e)||(e=[e]),e.map(String)}}function s(e,n,t=!1){return r.isAbsolute(e)?e:r.join(n,e)}function o(e,n){for(const[t,{default:r}]of Object.entries(e))null==n[t]&&null!=r&&(n[t]=r)}n.parse=function(e,n,t=!0){var r={},i=[],a=[],s=[],l={};Object.keys(n).forEach((e=>{if(!e.startsWith(" ")){var i=n[e];null!=i.alias&&("string"==typeof i.alias?l[i.alias]=e:Array.isArray(i.alias)&&i.alias.forEach((n=>l[n]=e))),t&&null!=i.default&&(r[e]=i.default)}}));for(var u=0,c=(e=e.slice()).length;u<c;++u){let t=e[u];if("--"==t){++u;break}let s,o,c=/^(?:(-\w)(?:=(.*))?|(--\w{2,})(?:=(.*))?)$/.exec(t);if(c)n[t]?s=n[o=t]:null!=c[1]?(s=n[o=l[c[1].substring(1)]],s&&null!=c[2]&&(e[u--]=c[2])):null!=c[3]&&(s=n[o=c[3].substring(2)],s&&null!=c[4]&&(e[u--]=c[4]));else{if(45!=t.charCodeAt(0)){a.push(t);continue}s=n[o=t]}if(s)if(s.value)Object.keys(s.value).forEach((e=>r[e]=s.value[e]));else if(null==s.type||"b"===s.type)r[o]=!0;else if(u+1<e.length&&45!=e[u+1].charCodeAt(0))switch(s.type){case"i":r[o]=parseInt(e[++u],10);break;case"I":r[o]=(r[o]||[]).concat(parseInt(e[++u],10));break;case"f":r[o]=parseFloat(e[++u]);break;case"F":r[o]=(r[o]||[]).concat(parseFloat(e[++u]));break;case"s":r[o]=String(e[++u]);break;case"S":r[o]=(r[o]||[]).concat(e[++u].split(","));break;default:i.push(t),--u}else switch(s.type){case"i":case"f":r[o]=s.default||0;break;case"s":r[o]=s.default||"";break;case"I":case"F":case"S":r[o]=s.default||[];break;default:i.push(t)}else i.push(t)}for(;u<c;)s.push(e[u++]);return t&&o(n,r),{options:r,unknown:i,arguments:a,trailing:s}},n.help=function(e,n){n||(n={});var t=n.indent||2,r=n.padding||24,a=n.eol||"\n",s={},o=[];Object.keys(e).forEach((i=>{var l=e[i];if(null!=l.description){for(var u,c="";c.length<t;)c+=" ";for(c+="--"+i,l.alias&&(c+=", -"+l.alias);c.length<r;)c+=" ";!n.noCategories&&l.category?(u=s[l.category])||(s[l.category]=u=[]):u=o,Array.isArray(l.description)?u.push(c+l.description[0]+l.description.slice(1).map((e=>{for(let n=0;n<r;++n)e=" "+e;return a+e})).join("")):u.push(c+l.description)}}));var l=[],u=!1;return Object.keys(s).forEach((e=>{u=!0,l.push(a+" "+i.gray(e)+a),l.push(s[e].join(a))})),u&&l.push(a+" "+i.gray("Other")+a),l.push(o.join(a)),l.join(a)},n.merge=function(e,n,t,r){const i={};for(const[o,{type:l,mutuallyExclusive:u,isPath:c,useNodeResolution:p,cliOnly:f}]of Object.entries(e)){let e=a(n[o],l),d=a(t[o],l);if(null==e){if(null!=d){if(f)continue;if(Array.isArray(d)){let e;c&&(d=d.map((e=>s(e,r,p)))),null!=u&&(e=n[u])?i[o]=d.filter((n=>!e.includes(n))):i[o]=d.slice()}else c&&(d=s(d,r,p)),i[o]=d}}else if(null==d)Array.isArray(e)?i[o]=e.slice():i[o]=e;else if(Array.isArray(e)){if(f){i[o]=e.slice();continue}let t;c&&(d=d.map((e=>s(e,r,p)))),null!=u&&(t=n[u])?i[o]=[...e,...d.filter((n=>!e.includes(n)&&!t.includes(n)))]:i[o]=[...e,...d.filter((n=>!e.includes(n)))]}else i[o]=e}return i},n.resolvePath=s,n.addDefaults=o},198:(e,n)=>{var t=n;t.length=function(e){for(var n=0,t=0,r=0,i=e.length;r<i;++r)(t=e.charCodeAt(r))<128?n+=1:t<2048?n+=2:55296==(64512&t)&&56320==(64512&e.charCodeAt(r+1))?(++r,n+=4):n+=3;return n},t.read=function(e,n,t){if(t-n<1)return"";for(var r,i=null,a=[],s=0;n<t;)(r=e[n++])<128?a[s++]=r:r>191&&r<224?a[s++]=(31&r)<<6|63&e[n++]:r>239&&r<365?(r=((7&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,a[s++]=55296+(r>>10),a[s++]=56320+(1023&r)):a[s++]=(15&r)<<12|(63&e[n++])<<6|63&e[n++],s>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,a)),s=0);return i?(s&&i.push(String.fromCharCode.apply(String,a.slice(0,s))),i.join("")):String.fromCharCode.apply(String,a.slice(0,s))},t.write=function(e,n,t){for(var r,i,a=t,s=0;s<e.length;++s)(r=e.charCodeAt(s))<128?n[t++]=r:r<2048?(n[t++]=r>>6|192,n[t++]=63&r|128):55296==(64512&r)&&56320==(64512&(i=e.charCodeAt(s+1)))?(r=65536+((1023&r)<<10)+(1023&i),++s,n[t++]=r>>18|240,n[t++]=r>>12&63|128,n[t++]=r>>6&63|128,n[t++]=63&r|128):(n[t++]=r>>12|224,n[t++]=r>>6&63|128,n[t++]=63&r|128);return t-a}},370:function(e,n,t){var r;"undefined"!=typeof self&&self,r=function(e){return(()=>{var n={720:e=>{e.exports=t;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function t(e,n,t){this.low=0|e,this.high=0|n,this.unsigned=!!t}function r(e){return!0===(e&&e.__isLong__)}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0}),t.isLong=r;var i={},a={};function s(e,n){var t,r,s;return n?(s=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(t=l(e,(0|e)<0?-1:0,!0),s&&(a[e]=t),t):(s=-128<=(e|=0)&&e<128)&&(r=i[e])?r:(t=l(e,e<0?-1:0,!1),s&&(i[e]=t),t)}function o(e,n){if(isNaN(e))return n?m:x;if(n){if(e<0)return m;if(e>=d)return b}else{if(e<=-h)return v;if(e+1>=h)return T}return e<0?o(-e,n).neg():l(e%f|0,e/f|0,n)}function l(e,n,r){return new t(e,n,r)}t.fromInt=s,t.fromNumber=o,t.fromBits=l;var u=Math.pow;function c(e,n,t){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return x;if("number"==typeof n?(t=n,n=!1):n=!!n,(t=t||10)<2||36<t)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),n,t).neg();for(var i=o(u(t,8)),a=x,s=0;s<e.length;s+=8){var l=Math.min(8,e.length-s),p=parseInt(e.substring(s,s+l),t);if(l<8){var f=o(u(t,l));a=a.mul(f).add(o(p))}else a=(a=a.mul(i)).add(o(p))}return a.unsigned=n,a}function p(e,n){return"number"==typeof e?o(e,n):"string"==typeof e?c(e,n):l(e.low,e.high,"boolean"==typeof n?n:e.unsigned)}t.fromString=c,t.fromValue=p;var f=4294967296,d=f*f,h=d/2,g=s(1<<24),x=s(0);t.ZERO=x;var m=s(0,!0);t.UZERO=m;var _=s(1);t.ONE=_;var y=s(1,!0);t.UONE=y;var E=s(-1);t.NEG_ONE=E;var T=l(-1,2147483647,!1);t.MAX_VALUE=T;var b=l(-1,-1,!0);t.MAX_UNSIGNED_VALUE=b;var v=l(0,-2147483648,!1);t.MIN_VALUE=v;var A=t.prototype;A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},A.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(v)){var n=o(e),t=this.div(n),r=t.mul(n).sub(this);return t.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var i=o(u(e,6),this.unsigned),a=this,s="";;){var l=a.div(i),c=(a.sub(l.mul(i)).toInt()>>>0).toString(e);if((a=l).isZero())return c+s;for(;c.length<6;)c="0"+c;s=""+c+s}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(v)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,n=31;n>0&&0==(e&1<<n);n--);return 0!=this.high?n+33:n+1},A.isZero=function(){return 0===this.high&&0===this.low},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return 1==(1&this.low)},A.isEven=function(){return 0==(1&this.low)},A.equals=function(e){return r(e)||(e=p(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},A.eq=A.equals,A.notEquals=function(e){return!this.eq(e)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(e){return this.comp(e)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(e){return this.comp(e)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(e){return this.comp(e)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(e){return this.comp(e)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(e){if(r(e)||(e=p(e)),this.eq(e))return 0;var n=this.isNegative(),t=e.isNegative();return n&&!t?-1:!n&&t?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(v)?v:this.not().add(_)},A.neg=A.negate,A.add=function(e){r(e)||(e=p(e));var n=this.high>>>16,t=65535&this.high,i=this.low>>>16,a=65535&this.low,s=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,f=0,d=0,h=0;return d+=(h+=a+(65535&e.low))>>>16,f+=(d+=i+u)>>>16,c+=(f+=t+o)>>>16,c+=n+s,l((d&=65535)<<16|(h&=65535),(c&=65535)<<16|(f&=65535),this.unsigned)},A.subtract=function(e){return r(e)||(e=p(e)),this.add(e.neg())},A.sub=A.subtract,A.multiply=function(e){if(this.isZero())return x;if(r(e)||(e=p(e)),n)return l(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return x;if(this.eq(v))return e.isOdd()?v:x;if(e.eq(v))return this.isOdd()?v:x;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return o(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,i=65535&this.high,a=this.low>>>16,s=65535&this.low,u=e.high>>>16,c=65535&e.high,f=e.low>>>16,d=65535&e.low,h=0,m=0,_=0,y=0;return _+=(y+=s*d)>>>16,m+=(_+=a*d)>>>16,_&=65535,m+=(_+=s*f)>>>16,h+=(m+=i*d)>>>16,m&=65535,h+=(m+=a*f)>>>16,m&=65535,h+=(m+=s*c)>>>16,h+=t*d+i*f+a*c+s*u,l((_&=65535)<<16|(y&=65535),(h&=65535)<<16|(m&=65535),this.unsigned)},A.mul=A.multiply,A.divide=function(e){if(r(e)||(e=p(e)),e.isZero())throw Error("division by zero");var t,i,a;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?m:x;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return m;if(e.gt(this.shru(1)))return y;a=m}else{if(this.eq(v))return e.eq(_)||e.eq(E)?v:e.eq(v)?_:(t=this.shr(1).div(e).shl(1)).eq(x)?e.isNegative()?_:E:(i=this.sub(e.mul(t)),a=t.add(i.div(e)));if(e.eq(v))return this.unsigned?m:x;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=x}for(i=this;i.gte(e);){t=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var s=Math.ceil(Math.log(t)/Math.LN2),c=s<=48?1:u(2,s-48),f=o(t),d=f.mul(e);d.isNegative()||d.gt(i);)d=(f=o(t-=c,this.unsigned)).mul(e);f.isZero()&&(f=_),a=a.add(f),i=i.sub(d)}return a},A.div=A.divide,A.modulo=function(e){return r(e)||(e=p(e)),n?l((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return l(~this.low,~this.high,this.unsigned)},A.and=function(e){return r(e)||(e=p(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},A.or=function(e){return r(e)||(e=p(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},A.xor=function(e){return r(e)||(e=p(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},A.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var n=this.high;return e<32?l(this.low>>>e|n<<32-e,n>>>e,this.unsigned):l(32===e?n:n>>>e-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},A.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var e=this.high,n=this.low;return[255&n,n>>>8&255,n>>>16&255,n>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},A.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,n>>>24,n>>>16&255,n>>>8&255,255&n]},t.fromBytes=function(e,n,r){return r?t.fromBytesLE(e,n):t.fromBytesBE(e,n)},t.fromBytesLE=function(e,n){return new t(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)},t.fromBytesBE=function(e,n){return new t(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)}},60:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.DeclarationStatement=n.Source=n.SourceKind=n.Statement=n.UnaryPrefixExpression=n.UnaryPostfixExpression=n.UnaryExpression=n.FalseExpression=n.TrueExpression=n.ThisExpression=n.SuperExpression=n.StringLiteralExpression=n.TernaryExpression=n.RegexpLiteralExpression=n.PropertyAccessExpression=n.ParenthesizedExpression=n.OmittedExpression=n.ObjectLiteralExpression=n.NullExpression=n.NewExpression=n.IntegerLiteralExpression=n.InstanceOfExpression=n.FunctionExpression=n.FloatLiteralExpression=n.ElementAccessExpression=n.ConstructorExpression=n.CommaExpression=n.ClassExpression=n.CallExpression=n.BinaryExpression=n.AssertionExpression=n.AssertionKind=n.ArrayLiteralExpression=n.LiteralExpression=n.LiteralKind=n.IdentifierExpression=n.Expression=n.CommentNode=n.CommentKind=n.DecoratorNode=n.DecoratorKind=n.ParameterNode=n.ParameterKind=n.TypeParameterNode=n.FunctionTypeNode=n.NamedTypeNode=n.TypeName=n.TypeNode=n.Node=n.NodeKind=void 0,n.isTypeOmitted=n.mangleInternalPath=n.findDecorator=n.WhileStatement=n.VoidStatement=n.VariableStatement=n.VariableDeclaration=n.TypeDeclaration=n.TryStatement=n.ThrowStatement=n.SwitchStatement=n.SwitchCase=n.ReturnStatement=n.NamespaceDeclaration=n.MethodDeclaration=n.InterfaceDeclaration=n.ImportStatement=n.ImportDeclaration=n.IfStatement=n.FunctionDeclaration=n.ArrowKind=n.ForOfStatement=n.ForStatement=n.FieldDeclaration=n.ExpressionStatement=n.ExportDefaultStatement=n.ExportStatement=n.ExportMember=n.ExportImportStatement=n.EnumValueDeclaration=n.EnumDeclaration=n.EmptyStatement=n.DoStatement=n.ContinueStatement=n.ClassDeclaration=n.BreakStatement=n.BlockStatement=n.VariableLikeDeclarationStatement=n.IndexSignatureNode=void 0;const r=t(200),i=t(411),a=t(910);var s,o,l,u;!function(e){e[e.SOURCE=0]="SOURCE",e[e.NAMEDTYPE=1]="NAMEDTYPE",e[e.FUNCTIONTYPE=2]="FUNCTIONTYPE",e[e.TYPENAME=3]="TYPENAME",e[e.TYPEPARAMETER=4]="TYPEPARAMETER",e[e.PARAMETER=5]="PARAMETER",e[e.IDENTIFIER=6]="IDENTIFIER",e[e.ASSERTION=7]="ASSERTION",e[e.BINARY=8]="BINARY",e[e.CALL=9]="CALL",e[e.CLASS=10]="CLASS",e[e.COMMA=11]="COMMA",e[e.ELEMENTACCESS=12]="ELEMENTACCESS",e[e.FALSE=13]="FALSE",e[e.FUNCTION=14]="FUNCTION",e[e.INSTANCEOF=15]="INSTANCEOF",e[e.LITERAL=16]="LITERAL",e[e.NEW=17]="NEW",e[e.NULL=18]="NULL",e[e.OMITTED=19]="OMITTED",e[e.PARENTHESIZED=20]="PARENTHESIZED",e[e.PROPERTYACCESS=21]="PROPERTYACCESS",e[e.TERNARY=22]="TERNARY",e[e.SUPER=23]="SUPER",e[e.THIS=24]="THIS",e[e.TRUE=25]="TRUE",e[e.CONSTRUCTOR=26]="CONSTRUCTOR",e[e.UNARYPOSTFIX=27]="UNARYPOSTFIX",e[e.UNARYPREFIX=28]="UNARYPREFIX",e[e.BLOCK=29]="BLOCK",e[e.BREAK=30]="BREAK",e[e.CONTINUE=31]="CONTINUE",e[e.DO=32]="DO",e[e.EMPTY=33]="EMPTY",e[e.EXPORT=34]="EXPORT",e[e.EXPORTDEFAULT=35]="EXPORTDEFAULT",e[e.EXPORTIMPORT=36]="EXPORTIMPORT",e[e.EXPRESSION=37]="EXPRESSION",e[e.FOR=38]="FOR",e[e.FOROF=39]="FOROF",e[e.IF=40]="IF",e[e.IMPORT=41]="IMPORT",e[e.RETURN=42]="RETURN",e[e.SWITCH=43]="SWITCH",e[e.THROW=44]="THROW",e[e.TRY=45]="TRY",e[e.VARIABLE=46]="VARIABLE",e[e.VOID=47]="VOID",e[e.WHILE=48]="WHILE",e[e.CLASSDECLARATION=49]="CLASSDECLARATION",e[e.ENUMDECLARATION=50]="ENUMDECLARATION",e[e.ENUMVALUEDECLARATION=51]="ENUMVALUEDECLARATION",e[e.FIELDDECLARATION=52]="FIELDDECLARATION",e[e.FUNCTIONDECLARATION=53]="FUNCTIONDECLARATION",e[e.IMPORTDECLARATION=54]="IMPORTDECLARATION",e[e.INTERFACEDECLARATION=55]="INTERFACEDECLARATION",e[e.METHODDECLARATION=56]="METHODDECLARATION",e[e.NAMESPACEDECLARATION=57]="NAMESPACEDECLARATION",e[e.TYPEDECLARATION=58]="TYPEDECLARATION",e[e.VARIABLEDECLARATION=59]="VARIABLEDECLARATION",e[e.DECORATOR=60]="DECORATOR",e[e.EXPORTMEMBER=61]="EXPORTMEMBER",e[e.SWITCHCASE=62]="SWITCHCASE",e[e.INDEXSIGNATURE=63]="INDEXSIGNATURE",e[e.COMMENT=64]="COMMENT"}(s=n.NodeKind||(n.NodeKind={}));class c{constructor(e,n){this.kind=e,this.range=n}static createSimpleTypeName(e,n){return new f(c.createIdentifierExpression(e,n),null,n)}static createNamedType(e,n,t,r){return new d(e,n,t,r)}static createFunctionType(e,n,t,r,i){return new h(e,n,t,r,i)}static createOmittedType(e){return new d(c.createSimpleTypeName("",e),null,!1,e)}static createTypeParameter(e,n,t,r){return new g(e,n,t,r)}static createParameter(e,n,t,r,i){return new x(e,n,t,r,i)}static createDecorator(e,n,t){return new m(o.fromNode(e),e,n,t)}static createComment(e,n,t){return new _(e,n,t)}static createIdentifierExpression(e,n,t=!1){return new E(e,t,n)}static createEmptyIdentifierExpression(e){return new E("",!1,e)}static createArrayLiteralExpression(e,n){return new b(e,n)}static createAssertionExpression(e,n,t,r){return new v(e,n,t,r)}static createBinaryExpression(e,n,t,r){return new A(e,n,t,r)}static createCallExpression(e,n,t,r){return new F(e,n,t,r)}static createClassExpression(e){return new C(e)}static createCommaExpression(e,n){return new I(e,n)}static createConstructorExpression(e){return new S(e)}static createElementAccessExpression(e,n,t){return new N(e,n,t)}static createFalseExpression(e){return new X(e)}static createFloatLiteralExpression(e,n){return new O(e,n)}static createFunctionExpression(e){return new k(e)}static createInstanceOfExpression(e,n,t){return new L(e,n,t)}static createIntegerLiteralExpression(e,n){return new B(e,n)}static createNewExpression(e,n,t,r){return new D(e,n,t,r)}static createNullExpression(e){return new R(e)}static createObjectLiteralExpression(e,n,t){return new w(e,n,t)}static createOmittedExpression(e){return new z(e)}static createParenthesizedExpression(e,n){return new P(e,n)}static createPropertyAccessExpression(e,n,t){return new U(e,n,t)}static createRegexpLiteralExpression(e,n,t){return new M(e,n,t)}static createTernaryExpression(e,n,t,r){return new G(e,n,t,r)}static createStringLiteralExpression(e,n){return new V(e,n)}static createSuperExpression(e){return new K(e)}static createThisExpression(e){return new H(e)}static createTrueExpression(e){return new W(e)}static createUnaryPostfixExpression(e,n,t){return new j(e,n,t)}static createUnaryPrefixExpression(e,n,t){return new q(e,n,t)}static createBlockStatement(e,n){return new ee(e,n)}static createBreakStatement(e,n){return new ne(e,n)}static createClassDeclaration(e,n,t,r,i,a,s,o){return new te(e,n,t,r,i,a,s,o)}static createContinueStatement(e,n){return new re(e,n)}static createDoStatement(e,n,t){return new ie(e,n,t)}static createEmptyStatement(e){return new ae(e)}static createEnumDeclaration(e,n,t,r,i){return new se(e,n,t,r,i)}static createEnumValueDeclaration(e,n,t,r){return new oe(e,n,t,r)}static createExportStatement(e,n,t,r){return new ce(e,n,t,r)}static createExportDefaultStatement(e,n){return new pe(e,n)}static createExportImportStatement(e,n,t){return new le(e,n,t)}static createExportMember(e,n,t){return n||(n=e),new ue(e,n,t)}static createExpressionStatement(e){return new fe(e)}static createIfStatement(e,n,t,r){return new me(e,n,t,r)}static createImportStatement(e,n,t){return new ye(e,null,n,t)}static createWildcardImportStatement(e,n,t){return new ye(null,e,n,t)}static createImportDeclaration(e,n,t){return n||(n=e),new _e(n,e,t)}static createInterfaceDeclaration(e,n,t,r,i,a,s,o){return new Ee(e,n,t,r,i,a,s,o)}static createFieldDeclaration(e,n,t,r,i,a){return new de(e,n,t,r,i,-1,a)}static createForStatement(e,n,t,r,i){return new he(e,n,t,r,i)}static createForOfStatement(e,n,t,r){return new ge(e,n,t,r)}static createFunctionDeclaration(e,n,t,r,i,a,s,o){return new xe(e,n,t,r,i,a,s,o)}static createIndexSignature(e,n,t,r){return new J(e,n,t,r)}static createMethodDeclaration(e,n,t,r,i,a,s){return new Te(e,n,t,r,i,a,s)}static createNamespaceDeclaration(e,n,t,r,i){return new be(e,n,t,r,i)}static createReturnStatement(e,n){return new ve(e,n)}static createSwitchStatement(e,n,t){return new Fe(e,n,t)}static createSwitchCase(e,n,t){return new Ae(e,n,t)}static createThrowStatement(e,n){return new Ce(e,n)}static createTryStatement(e,n,t,r,i){return new Ie(e,n,t,r,i)}static createTypeDeclaration(e,n,t,r,i,a){return new Se(e,n,t,r,i,a)}static createVariableStatement(e,n,t){return new Oe(e,n,t)}static createVariableDeclaration(e,n,t,r,i,a){return new Ne(e,n,t,r,i,a)}static createVoidStatement(e,n){return new ke(e,n)}static createWhileStatement(e,n,t){return new Le(e,n,t)}isLiteralKind(e){return this.kind==s.LITERAL&&changetype(this).literalKind==e}get isNumericLiteral(){if(this.kind==s.LITERAL)switch(changetype(this).literalKind){case l.FLOAT:case l.INTEGER:return!0}return!1}get compilesToConst(){switch(this.kind){case s.LITERAL:switch(changetype(this).literalKind){case l.FLOAT:case l.INTEGER:case l.STRING:return!0}break;case s.NULL:case s.TRUE:case s.FALSE:return!0}return!1}isAccessOn(e){let n=changetype(this);return n.kind==s.CALL&&(n=n.expression),n.kind==s.PROPERTYACCESS&&n.expression.kind==e}get isAccessOnThis(){return this.isAccessOn(s.THIS)}get isAccessOnSuper(){return this.isAccessOn(s.SUPER)}}n.Node=c;class p extends c{constructor(e,n,t){super(e,t),this.isNullable=n}hasGenericComponent(e){if(this.kind==s.NAMEDTYPE){let n=changetype(this);if(!n.name.next){let t=n.typeArguments;if(null!==t&&t.length>0){for(let n=0,r=t.length;n<r;++n)if(t[n].hasGenericComponent(e))return!0}else{let t=n.name.identifier.text;for(let n=0,r=e.length;n<r;++n)if(e[n].name.text==t)return!0}}}else if(this.kind==s.FUNCTIONTYPE){let n=changetype(this),t=n.parameters;for(let n=0,r=t.length;n<r;++n)if(t[n].type.hasGenericComponent(e))return!0;if(n.returnType.hasGenericComponent(e))return!0;let r=n.explicitThisType;if(null!==r&&r.hasGenericComponent(e))return!0}else assert(!1);return!1}}n.TypeNode=p;class f extends c{constructor(e,n,t){super(s.TYPENAME,t),this.identifier=e,this.next=n}}n.TypeName=f;class d extends p{constructor(e,n,t,r){super(s.NAMEDTYPE,t,r),this.name=e,this.typeArguments=n}get hasTypeArguments(){var e=this.typeArguments;return null!==e&&e.length>0}}n.NamedTypeNode=d;class h extends p{constructor(e,n,t,r,i){super(s.FUNCTIONTYPE,r,i),this.parameters=e,this.returnType=n,this.explicitThisType=t}}n.FunctionTypeNode=h;class g extends c{constructor(e,n,t,r){super(s.TYPEPARAMETER,r),this.name=e,this.extendsType=n,this.defaultType=t}}n.TypeParameterNode=g,function(e){e[e.DEFAULT=0]="DEFAULT",e[e.OPTIONAL=1]="OPTIONAL",e[e.REST=2]="REST"}(n.ParameterKind||(n.ParameterKind={}));class x extends c{constructor(e,n,t,i,a){super(s.PARAMETER,a),this.parameterKind=e,this.name=n,this.type=t,this.initializer=i,this.implicitFieldDeclaration=null,this.flags=r.CommonFlags.NONE}is(e){return(this.flags&e)==e}isAny(e){return 0!=(this.flags&e)}set(e){this.flags|=e}}n.ParameterNode=x,function(e){e[e.CUSTOM=0]="CUSTOM",e[e.GLOBAL=1]="GLOBAL",e[e.OPERATOR=2]="OPERATOR",e[e.OPERATOR_BINARY=3]="OPERATOR_BINARY",e[e.OPERATOR_PREFIX=4]="OPERATOR_PREFIX",e[e.OPERATOR_POSTFIX=5]="OPERATOR_POSTFIX",e[e.UNMANAGED=6]="UNMANAGED",e[e.FINAL=7]="FINAL",e[e.INLINE=8]="INLINE",e[e.EXTERNAL=9]="EXTERNAL",e[e.BUILTIN=10]="BUILTIN",e[e.LAZY=11]="LAZY",e[e.UNSAFE=12]="UNSAFE"}(o=n.DecoratorKind||(n.DecoratorKind={})),function(e){e.fromNode=function(n){if(n.kind==s.IDENTIFIER){let t=n.text;switch(assert(t.length),t.charCodeAt(0)){case 98:if("builtin"==t)return e.BUILTIN;break;case 101:if("external"==t)return e.EXTERNAL;break;case 102:if("final"==t)return e.FINAL;break;case 103:if("global"==t)return e.GLOBAL;break;case 105:if("inline"==t)return e.INLINE;break;case 108:if("lazy"==t)return e.LAZY;break;case 111:if("operator"==t)return e.OPERATOR;break;case 117:if("unmanaged"==t)return e.UNMANAGED;if("unsafe"==t)return e.UNSAFE}}else if(n.kind==s.PROPERTYACCESS){let t=n,r=t.expression;if(r.kind==s.IDENTIFIER){let n=r.text;assert(n.length);let i=t.property.text;if(assert(i.length),"operator"==n)switch(i.charCodeAt(0)){case 98:if("binary"==i)return e.OPERATOR_BINARY;break;case 112:if("prefix"==i)return e.OPERATOR_PREFIX;if("postfix"==i)return e.OPERATOR_POSTFIX}}}return e.CUSTOM}}(o=n.DecoratorKind||(n.DecoratorKind={}));class m extends c{constructor(e,n,t,r){super(s.DECORATOR,r),this.decoratorKind=e,this.name=n,this.args=t}}n.DecoratorNode=m,function(e){e[e.LINE=0]="LINE",e[e.TRIPLE=1]="TRIPLE",e[e.BLOCK=2]="BLOCK"}(n.CommentKind||(n.CommentKind={}));class _ extends c{constructor(e,n,t){super(s.COMMENT,t),this.commentKind=e,this.text=n}}n.CommentNode=_;class y extends c{}n.Expression=y;class E extends y{constructor(e,n,t){super(s.IDENTIFIER,t),this.text=e,this.isQuoted=n}}n.IdentifierExpression=E,function(e){e[e.FLOAT=0]="FLOAT",e[e.INTEGER=1]="INTEGER",e[e.STRING=2]="STRING",e[e.REGEXP=3]="REGEXP",e[e.ARRAY=4]="ARRAY",e[e.OBJECT=5]="OBJECT"}(l=n.LiteralKind||(n.LiteralKind={}));class T extends y{constructor(e,n){super(s.LITERAL,n),this.literalKind=e}}n.LiteralExpression=T;class b extends T{constructor(e,n){super(l.ARRAY,n),this.elementExpressions=e}}n.ArrayLiteralExpression=b,function(e){e[e.PREFIX=0]="PREFIX",e[e.AS=1]="AS",e[e.NONNULL=2]="NONNULL",e[e.CONST=3]="CONST"}(n.AssertionKind||(n.AssertionKind={}));class v extends y{constructor(e,n,t,r){super(s.ASSERTION,r),this.assertionKind=e,this.expression=n,this.toType=t}}n.AssertionExpression=v;class A extends y{constructor(e,n,t,r){super(s.BINARY,r),this.operator=e,this.left=n,this.right=t}}n.BinaryExpression=A;class F extends y{constructor(e,n,t,r){super(s.CALL,r),this.expression=e,this.typeArguments=n,this.args=t}get typeArgumentsRange(){var e,n=this.typeArguments;return n&&(e=n.length)?i.Range.join(n[0].range,n[e-1].range):this.expression.range}get argumentsRange(){var e=this.args,n=e.length;return n?i.Range.join(e[0].range,e[n-1].range):this.expression.range}}n.CallExpression=F;class C extends y{constructor(e){super(s.CLASS,e.range),this.declaration=e}}n.ClassExpression=C;class I extends y{constructor(e,n){super(s.COMMA,n),this.expressions=e}}n.CommaExpression=I;class S extends E{constructor(e){super("constructor",!1,e),this.kind=s.CONSTRUCTOR}}n.ConstructorExpression=S;class N extends y{constructor(e,n,t){super(s.ELEMENTACCESS,t),this.expression=e,this.elementExpression=n}}n.ElementAccessExpression=N;class O extends T{constructor(e,n){super(l.FLOAT,n),this.value=e}}n.FloatLiteralExpression=O;class k extends y{constructor(e){super(s.FUNCTION,e.range),this.declaration=e}}n.FunctionExpression=k;class L extends y{constructor(e,n,t){super(s.INSTANCEOF,t),this.expression=e,this.isType=n}}n.InstanceOfExpression=L;class B extends T{constructor(e,n){super(l.INTEGER,n),this.value=e}}n.IntegerLiteralExpression=B;class D extends y{constructor(e,n,t,r){super(s.NEW,r),this.typeName=e,this.typeArguments=n,this.args=t}get typeArgumentsRange(){var e,n=this.typeArguments;return null!==n&&(e=n.length)>0?i.Range.join(n[0].range,n[e-1].range):this.typeName.range}get argumentsRange(){var e=this.args,n=e.length;return n?i.Range.join(e[0].range,e[n-1].range):this.typeName.range}}n.NewExpression=D;class R extends E{constructor(e){super("null",!1,e),this.kind=s.NULL}}n.NullExpression=R;class w extends T{constructor(e,n,t){super(l.OBJECT,t),this.names=e,this.values=n}}n.ObjectLiteralExpression=w;class z extends y{constructor(e){super(s.OMITTED,e)}}n.OmittedExpression=z;class P extends y{constructor(e,n){super(s.PARENTHESIZED,n),this.expression=e}}n.ParenthesizedExpression=P;class U extends y{constructor(e,n,t){super(s.PROPERTYACCESS,t),this.expression=e,this.property=n}}n.PropertyAccessExpression=U;class M extends T{constructor(e,n,t){super(l.REGEXP,t),this.pattern=e,this.patternFlags=n}}n.RegexpLiteralExpression=M;class G extends y{constructor(e,n,t,r){super(s.TERNARY,r),this.condition=e,this.ifThen=n,this.ifElse=t}}n.TernaryExpression=G;class V extends T{constructor(e,n){super(l.STRING,n),this.value=e}}n.StringLiteralExpression=V;class K extends E{constructor(e){super("super",!1,e),this.kind=s.SUPER}}n.SuperExpression=K;class H extends E{constructor(e){super("this",!1,e),this.kind=s.THIS}}n.ThisExpression=H;class W extends E{constructor(e){super("true",!1,e),this.kind=s.TRUE}}n.TrueExpression=W;class X extends E{constructor(e){super("false",!1,e),this.kind=s.FALSE}}n.FalseExpression=X;class Y extends y{constructor(e,n,t,r){super(e,r),this.operator=n,this.operand=t}}n.UnaryExpression=Y;class j extends Y{constructor(e,n,t){super(s.UNARYPOSTFIX,e,n,t)}}n.UnaryPostfixExpression=j;class q extends Y{constructor(e,n,t){super(s.UNARYPREFIX,e,n,t)}}n.UnaryPrefixExpression=q;class Q extends c{}n.Statement=Q,function(e){e[e.USER=0]="USER",e[e.USER_ENTRY=1]="USER_ENTRY",e[e.LIBRARY=2]="LIBRARY",e[e.LIBRARY_ENTRY=3]="LIBRARY_ENTRY"}(u=n.SourceKind||(n.SourceKind={})),n.Source=class extends c{constructor(e,n,t){super(s.SOURCE,new i.Range(0,t.length)),this.sourceKind=e,this.normalizedPath=n,this.text=t,this.statements=new Array,this.debugInfoIndex=-1,this.exportPaths=null,this.lineCache=null,this.lineColumn=1;var a=Be(n);this.internalPath=a;var o=a.lastIndexOf(r.PATH_DELIMITER);this.simplePath=o>=0?a.substring(o+1):a,this.range.source=this}get isNative(){return this.internalPath==r.LIBRARY_SUBST}get isLibrary(){var e=this.sourceKind;return e==u.LIBRARY||e==u.LIBRARY_ENTRY}lineAt(e){assert(e>=0&&e<2147483647);var n=this.lineCache;if(!n){this.lineCache=n=[0];let e=this.text,t=0,r=e.length;for(;t<r;)10==e.charCodeAt(t++)&&n.push(t);n.push(2147483647)}for(var t=0,r=n.length-1;t<r;){let i=t+(r-t>>1),a=unchecked(n[i]);if(e<a)r=i;else{if(e<unchecked(n[i+1]))return this.lineColumn=e-a+1,i+1;t=i+1}}return assert(0)}columnAt(){return this.lineColumn}};class Z extends Q{constructor(e,n,t,r,i){super(e,i),this.name=n,this.decorators=t,this.flags=r}is(e){return(this.flags&e)==e}isAny(e){return 0!=(this.flags&e)}set(e){this.flags|=e}}n.DeclarationStatement=Z;class J extends c{constructor(e,n,t,r){super(s.INDEXSIGNATURE,r),this.keyType=e,this.valueType=n,this.flags=t}}n.IndexSignatureNode=J;class $ extends Z{constructor(e,n,t,r,i,a,s){super(e,n,t,r,s),this.type=i,this.initializer=a}}n.VariableLikeDeclarationStatement=$;class ee extends Q{constructor(e,n){super(s.BLOCK,n),this.statements=e}}n.BlockStatement=ee;class ne extends Q{constructor(e,n){super(s.BREAK,n),this.label=e}}n.BreakStatement=ne;class te extends Z{constructor(e,n,t,r,i,a,o,l){super(s.CLASSDECLARATION,e,n,t,l),this.typeParameters=r,this.extendsType=i,this.implementsTypes=a,this.members=o,this.indexSignature=null}get isGeneric(){var e=this.typeParameters;return null!=e&&e.length>0}}n.ClassDeclaration=te;class re extends Q{constructor(e,n){super(s.CONTINUE,n),this.label=e}}n.ContinueStatement=re;class ie extends Q{constructor(e,n,t){super(s.DO,t),this.statement=e,this.condition=n}}n.DoStatement=ie;class ae extends Q{constructor(e){super(s.EMPTY,e)}}n.EmptyStatement=ae;class se extends Z{constructor(e,n,t,r,i){super(s.ENUMDECLARATION,e,n,t,i),this.values=r}}n.EnumDeclaration=se;class oe extends ${constructor(e,n,t,r){super(s.ENUMVALUEDECLARATION,e,null,n,null,t,r)}}n.EnumValueDeclaration=oe;class le extends Q{constructor(e,n,t){super(s.EXPORTIMPORT,t),this.name=e,this.externalName=n}}n.ExportImportStatement=le;class ue extends c{constructor(e,n,t){super(s.EXPORTMEMBER,t),this.localName=e,this.exportedName=n}}n.ExportMember=ue;class ce extends Q{constructor(e,n,t,i){if(super(s.EXPORT,i),this.members=e,this.path=n,this.isDeclare=t,n){let e=a.normalizePath(n.value);n.value.startsWith(".")?e=a.resolvePath(e,i.source.internalPath):e.startsWith(r.LIBRARY_PREFIX)||(e=r.LIBRARY_PREFIX+e),this.internalPath=e}else this.internalPath=null}}n.ExportStatement=ce;class pe extends Q{constructor(e,n){super(s.EXPORTDEFAULT,n),this.declaration=e}}n.ExportDefaultStatement=pe;class fe extends Q{constructor(e){super(s.EXPRESSION,e.range),this.expression=e}}n.ExpressionStatement=fe;class de extends ${constructor(e,n,t,r,i,a,o){super(s.FIELDDECLARATION,e,n,t,r,i,o),this.parameterIndex=a}}n.FieldDeclaration=de;class he extends Q{constructor(e,n,t,r,i){super(s.FOR,i),this.initializer=e,this.condition=n,this.incrementor=t,this.statement=r}}n.ForStatement=he;class ge extends Q{constructor(e,n,t,r){super(s.FOROF,r),this.variable=e,this.iterable=n,this.statement=t}}n.ForOfStatement=ge,function(e){e[e.NONE=0]="NONE",e[e.ARROW_PARENTHESIZED=1]="ARROW_PARENTHESIZED",e[e.ARROW_SINGLE=2]="ARROW_SINGLE"}(n.ArrowKind||(n.ArrowKind={}));class xe extends Z{constructor(e,n,t,r,i,a,o,l){super(s.FUNCTIONDECLARATION,e,n,t,l),this.typeParameters=r,this.signature=i,this.body=a,this.arrowKind=o}get isGeneric(){var e=this.typeParameters;return null!=e&&e.length>0}clone(){return new xe(this.name,this.decorators,this.flags,this.typeParameters,this.signature,this.body,this.arrowKind,this.range)}}n.FunctionDeclaration=xe;class me extends Q{constructor(e,n,t,r){super(s.IF,r),this.condition=e,this.ifTrue=n,this.ifFalse=t}}n.IfStatement=me;class _e extends Z{constructor(e,n,t){super(s.IMPORTDECLARATION,e,null,r.CommonFlags.NONE,t),this.foreignName=n}}n.ImportDeclaration=_e;class ye extends Q{constructor(e,n,t,i){super(s.IMPORT,i),this.declarations=e,this.namespaceName=n,this.path=t;var o=a.normalizePath(t.value);t.value.startsWith(".")?o=a.resolvePath(o,i.source.internalPath):o.startsWith(r.LIBRARY_PREFIX)||(o=r.LIBRARY_PREFIX+o),this.internalPath=o}}n.ImportStatement=ye;class Ee extends te{constructor(e,n,t,r,i,a,o,l){super(e,n,t,r,i,a,o,l),this.kind=s.INTERFACEDECLARATION}}n.InterfaceDeclaration=Ee;class Te extends xe{constructor(e,n,t,r,i,a,o){super(e,n,t,r,i,a,0,o),this.kind=s.METHODDECLARATION}}n.MethodDeclaration=Te;class be extends Z{constructor(e,n,t,r,i){super(s.NAMESPACEDECLARATION,e,n,t,i),this.members=r}}n.NamespaceDeclaration=be;class ve extends Q{constructor(e,n){super(s.RETURN,n),this.value=e}}n.ReturnStatement=ve;class Ae extends c{constructor(e,n,t){super(s.SWITCHCASE,t),this.label=e,this.statements=n}}n.SwitchCase=Ae;class Fe extends Q{constructor(e,n,t){super(s.SWITCH,t),this.condition=e,this.cases=n}}n.SwitchStatement=Fe;class Ce extends Q{constructor(e,n){super(s.THROW,n),this.value=e}}n.ThrowStatement=Ce;class Ie extends Q{constructor(e,n,t,r,i){super(s.TRY,i),this.statements=e,this.catchVariable=n,this.catchStatements=t,this.finallyStatements=r}}n.TryStatement=Ie;class Se extends Z{constructor(e,n,t,r,i,a){super(s.TYPEDECLARATION,e,n,t,a),this.typeParameters=r,this.type=i}}n.TypeDeclaration=Se;class Ne extends ${constructor(e,n,t,r,i,a){super(s.VARIABLEDECLARATION,e,n,t,r,i,a)}}n.VariableDeclaration=Ne;class Oe extends Q{constructor(e,n,t){super(s.VARIABLE,t),this.decorators=e,this.declarations=n}}n.VariableStatement=Oe;class ke extends Q{constructor(e,n){super(s.VOID,n),this.expression=e}}n.VoidStatement=ke;class Le extends Q{constructor(e,n,t){super(s.WHILE,t),this.condition=e,this.statement=n}}function Be(e){var n=e.lastIndexOf("."),t=e.length;if(n>=0&&t-n>=2){let r=n;for(;++r<t;)if(!a.isTrivialAlphanum(e.charCodeAt(r)))return assert(!1),e;return e.substring(0,n)}return assert(!1),e}n.WhileStatement=Le,n.findDecorator=function(e,n){if(n)for(let t=0,r=n.length;t<r;++t){let r=n[t];if(r.decoratorKind==e)return r}return null},n.mangleInternalPath=Be,n.isTypeOmitted=function(e){if(e.kind==s.NAMEDTYPE){let n=e.name;return!(null!==n.next||n.identifier.text.length>0)}return!1}},346:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.compileClassInstanceOf=n.compileRTTI=n.compileVisitMembers=n.compileVisitGlobals=n.function_builtins=n.builtins=n.BuiltinContext=n.BuiltinNames=void 0;const r=t(256),i=t(60),a=t(699),s=t(656),o=t(974),l=t(154),u=t(742),c=t(200),p=t(910);var f;function d(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,1))return t.unreachable();var i=e.typeArguments,o=i?n.compileExpression(e.operands[0],i[0],5):n.compileExpression(e.operands[0],a.Type.i32,4),l=n.currentType;if(l.isValue)switch(l.kind){case 10:case 0:case 5:case 1:case 6:case 2:case 7:return t.unary(s.UnaryOp.ClzI32,o);case 9:case 4:return t.unary(n.options.isWasm64?s.UnaryOp.ClzI64:s.UnaryOp.ClzI32,o);case 3:case 8:return t.unary(s.UnaryOp.ClzI64,o)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"clz",l.toString()),t.unreachable()}function h(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,1))return t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],5):n.compileExpression(i[0],a.Type.i32,4),u=n.currentType;if(u.isValue)switch(u.kind){case 10:case 0:case 5:case 1:case 6:case 2:case 7:return t.unary(s.UnaryOp.CtzI32,l);case 9:case 4:return t.unary(n.options.isWasm64?s.UnaryOp.CtzI64:s.UnaryOp.CtzI32,l);case 3:case 8:return t.unary(s.UnaryOp.CtzI64,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"ctz",u.toString()),t.unreachable()}function g(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,1))return t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],5):n.compileExpression(i[0],a.Type.i32,4),u=n.currentType;if(u.isValue)switch(n.currentType.kind){case 10:return l;case 0:case 5:case 1:case 6:case 2:case 7:return t.unary(s.UnaryOp.PopcntI32,l);case 3:case 8:return t.unary(s.UnaryOp.PopcntI64,l);case 4:case 9:return t.unary(n.options.isWasm64?s.UnaryOp.PopcntI64:s.UnaryOp.PopcntI32,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"popcnt",u.toString()),t.unreachable()}function x(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,2))return t.unreachable();var i=e.operands,o=e.typeArguments,u=o?n.compileExpression(i[0],o[0],5):n.compileExpression(i[0],a.Type.i32,4),c=n.currentType;if(c.isValue){let e=n.compileExpression(i[1],c,1);switch(c.kind){case 10:return u;case 0:case 1:case 5:case 6:{let r=n.currentFlow,i=r.getTempLocal(c,l.findUsedLocals(e));r.setLocalFlag(i.index,l.LocalFlags.WRAPPED);let a=r.getTempLocal(c);r.setLocalFlag(a.index,l.LocalFlags.WRAPPED);let o=t.binary(s.BinaryOp.OrI32,t.binary(s.BinaryOp.ShlI32,t.local_tee(i.index,u,!1),t.binary(s.BinaryOp.AndI32,t.local_tee(a.index,e,!1),t.i32(c.size-1))),t.binary(s.BinaryOp.ShrU32,t.local_get(i.index,s.NativeType.I32),t.binary(s.BinaryOp.AndI32,t.binary(s.BinaryOp.SubI32,t.i32(0),t.local_get(a.index,s.NativeType.I32)),t.i32(c.size-1))));return r.freeTempLocal(a),r.freeTempLocal(i),o}case 2:case 7:return t.binary(s.BinaryOp.RotlI32,u,e);case 9:case 4:return t.binary(n.options.isWasm64?s.BinaryOp.RotlI64:s.BinaryOp.RotlI32,u,e);case 3:case 8:return t.binary(s.BinaryOp.RotlI64,u,e)}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"rotl",c.toString()),t.unreachable()}function m(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,2))return t.unreachable();var i=e.operands,o=e.typeArguments,u=o?n.compileExpression(i[0],o[0],5):n.compileExpression(i[0],a.Type.i32,4),c=n.currentType;if(c.isValue){let e=n.compileExpression(i[1],c,1);switch(c.kind){case 10:return u;case 0:case 1:case 5:case 6:{let r=n.currentFlow,i=r.getTempLocal(c,l.findUsedLocals(e));r.setLocalFlag(i.index,l.LocalFlags.WRAPPED);let a=r.getTempLocal(c);r.setLocalFlag(a.index,l.LocalFlags.WRAPPED);let o=t.binary(s.BinaryOp.OrI32,t.binary(s.BinaryOp.ShrU32,t.local_tee(i.index,u,!1),t.binary(s.BinaryOp.AndI32,t.local_tee(a.index,e,!1),t.i32(c.size-1))),t.binary(s.BinaryOp.ShlI32,t.local_get(i.index,s.NativeType.I32),t.binary(s.BinaryOp.AndI32,t.binary(s.BinaryOp.SubI32,t.i32(0),t.local_get(a.index,s.NativeType.I32)),t.i32(c.size-1))));return r.freeTempLocal(a),r.freeTempLocal(i),o}case 2:case 7:return t.binary(s.BinaryOp.RotrI32,u,e);case 9:case 4:return t.binary(n.options.isWasm64?s.BinaryOp.RotrI64:s.BinaryOp.RotrI32,u,e);case 3:case 8:return t.binary(s.BinaryOp.RotrI64,u,e)}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"rotr",c.toString()),t.unreachable()}function _(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,1))return t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],5):n.compileExpression(i[0],a.Type.auto,4),u=n.currentType;if(u.isValue)switch(u.kind){case 0:case 1:case 2:{let e=n.currentFlow,r=e.getTempLocal(a.Type.i32),i=e.getTempLocal(a.Type.i32),o=t.binary(s.BinaryOp.XorI32,t.binary(s.BinaryOp.AddI32,t.local_tee(i.index,t.binary(s.BinaryOp.ShrI32,t.local_tee(r.index,l,!1),t.i32(31)),!1),t.local_get(r.index,s.NativeType.I32)),t.local_get(i.index,s.NativeType.I32));return e.freeTempLocal(i),e.freeTempLocal(r),o}case 4:{let e=n.options,r=n.currentFlow,i=e.isWasm64,a=r.getTempLocal(e.usizeType),o=r.getTempLocal(e.usizeType),u=t.binary(i?s.BinaryOp.XorI64:s.BinaryOp.XorI32,t.binary(i?s.BinaryOp.AddI64:s.BinaryOp.AddI32,t.local_tee(o.index,t.binary(i?s.BinaryOp.ShrI64:s.BinaryOp.ShrI32,t.local_tee(a.index,l,!1),i?t.i64(63):t.i32(31)),!1),t.local_get(a.index,e.nativeSizeType)),t.local_get(o.index,e.nativeSizeType));return r.freeTempLocal(o),r.freeTempLocal(a),u}case 3:{let e=n.currentFlow,r=e.getTempLocal(a.Type.i64),i=e.getTempLocal(a.Type.i64),o=t.binary(s.BinaryOp.XorI64,t.binary(s.BinaryOp.AddI64,t.local_tee(i.index,t.binary(s.BinaryOp.ShrI64,t.local_tee(r.index,l,!1),t.i64(63)),!1),t.local_get(r.index,s.NativeType.I64)),t.local_get(i.index,s.NativeType.I64));return e.freeTempLocal(i),e.freeTempLocal(r),o}case 9:case 5:case 6:case 7:case 8:case 10:return l;case 11:return t.unary(s.UnaryOp.AbsF32,l);case 12:return t.unary(s.UnaryOp.AbsF64,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"abs",u.toString()),t.unreachable()}function y(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,2))return t.unreachable();var i=e.operands,o=e.typeArguments,u=i[0],c=o?n.compileExpression(u,o[0],5):n.compileExpression(i[0],a.Type.auto,4),p=n.currentType;if(p.isValue){let e;!o&&u.isNumericLiteral?(e=n.compileExpression(i[1],p,4),n.currentType!=p&&(c=n.compileExpression(u,p=n.currentType,5))):e=n.compileExpression(i[1],p,5);let r=-1;switch(p.kind){case 0:case 1:case 2:r=s.BinaryOp.GtI32;break;case 5:case 6:case 7:case 10:r=s.BinaryOp.GtU32;break;case 3:r=s.BinaryOp.GtI64;break;case 8:r=s.BinaryOp.GtU64;break;case 4:r=n.options.isWasm64?s.BinaryOp.GtI64:s.BinaryOp.GtI32;break;case 9:r=n.options.isWasm64?s.BinaryOp.GtU64:s.BinaryOp.GtU32;break;case 11:return t.binary(s.BinaryOp.MaxF32,c,e);case 12:return t.binary(s.BinaryOp.MaxF64,c,e)}if(-1!=r){let i=n.currentFlow,a=p.toNativeType(),s=i.getTempLocal(p,l.findUsedLocals(e));i.setLocalFlag(s.index,l.LocalFlags.WRAPPED);let o=i.getTempLocal(p);i.setLocalFlag(o.index,l.LocalFlags.WRAPPED);let u=t.select(t.local_tee(s.index,c,!1),t.local_tee(o.index,e,!1),t.binary(r,t.local_get(s.index,a),t.local_get(o.index,a)));return i.freeTempLocal(o),i.freeTempLocal(s),u}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"max",p.toString()),t.unreachable()}function E(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,2))return t.unreachable();var i=e.operands,o=e.typeArguments,u=i[0],c=o?n.compileExpression(u,o[0],5):n.compileExpression(i[0],a.Type.auto,4),p=n.currentType;if(p.isValue){let e;!o&&u.isNumericLiteral?(e=n.compileExpression(i[1],p,4),n.currentType!=p&&(c=n.compileExpression(u,p=n.currentType,5))):e=n.compileExpression(i[1],p,5);let r=-1;switch(p.kind){case 0:case 1:case 2:r=s.BinaryOp.LtI32;break;case 5:case 6:case 7:case 10:r=s.BinaryOp.LtU32;break;case 3:r=s.BinaryOp.LtI64;break;case 8:r=s.BinaryOp.LtU64;break;case 4:r=n.options.isWasm64?s.BinaryOp.LtI64:s.BinaryOp.LtI32;break;case 9:r=n.options.isWasm64?s.BinaryOp.LtU64:s.BinaryOp.LtU32;break;case 11:return t.binary(s.BinaryOp.MinF32,c,e);case 12:return t.binary(s.BinaryOp.MinF64,c,e)}if(-1!=r){let i=n.currentFlow,a=p.toNativeType(),s=i.getTempLocal(p,l.findUsedLocals(e));i.setLocalFlag(s.index,l.LocalFlags.WRAPPED);let o=i.getTempLocal(p);i.setLocalFlag(o.index,l.LocalFlags.WRAPPED);let u=t.select(t.local_tee(s.index,c,!1),t.local_tee(o.index,e,!1),t.binary(r,t.local_get(s.index,a),t.local_get(o.index,a)));return i.freeTempLocal(o),i.freeTempLocal(s),u}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"min",p.toString()),t.unreachable()}function T(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,1))return t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],1):n.compileExpression(i[0],a.Type.auto,0),u=n.currentType;if(u.isValue)switch(u.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return l;case 11:return t.unary(s.UnaryOp.CeilF32,l);case 12:return t.unary(s.UnaryOp.CeilF64,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"ceil",u.toString()),t.unreachable()}function b(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,1))return t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],1):n.compileExpression(i[0],a.Type.auto,0),u=n.currentType;if(u.isValue)switch(u.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return l;case 11:return t.unary(s.UnaryOp.FloorF32,l);case 12:return t.unary(s.UnaryOp.FloorF64,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"floor",u.toString()),t.unreachable()}function v(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,2))return t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],1):n.compileExpression(i[0],a.Type.f64,0),u=n.currentType;if(u.isValue){let e=n.compileExpression(i[1],u,1);switch(u.kind){case 11:return t.binary(s.BinaryOp.CopysignF32,l,e);case 12:return t.binary(s.BinaryOp.CopysignF64,l,e)}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"copysign",u.toString()),t.unreachable()}function A(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,1))return t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],1):n.compileExpression(i[0],a.Type.auto,0),u=n.currentType;if(u.isValue)switch(u.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return l;case 11:return t.unary(s.UnaryOp.NearestF32,l);case 12:return t.unary(s.UnaryOp.NearestF64,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"nearest",u.toString()),t.unreachable()}function F(e){var n=e.compiler,t=n.module;if(We(e,!0)|je(e,1))return t.unreachable();var i=e.operands,o=e.typeArguments[0];if(o.isValue)switch(o.kind){case 2:case 7:{let e=n.compileExpression(i[0],a.Type.f32,1);return n.currentType=o,t.unary(s.UnaryOp.ReinterpretF32,e)}case 3:case 8:{let e=n.compileExpression(i[0],a.Type.f64,1);return n.currentType=o,t.unary(s.UnaryOp.ReinterpretF64,e)}case 4:case 9:{let e=n.compileExpression(i[0],n.options.isWasm64?a.Type.f64:a.Type.f32,1);return n.currentType=o,t.unary(n.options.isWasm64?s.UnaryOp.ReinterpretF64:s.UnaryOp.ReinterpretF32,e)}case 11:{let e=n.compileExpression(i[0],a.Type.i32,1);return n.currentType=a.Type.f32,t.unary(s.UnaryOp.ReinterpretI32,e)}case 12:{let e=n.compileExpression(i[0],a.Type.i64,1);return n.currentType=a.Type.f64,t.unary(s.UnaryOp.ReinterpretI64,e)}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"reinterpret",o.toString()),t.unreachable()}function C(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,1))return t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],1):n.compileExpression(i[0],a.Type.f64,0),u=n.currentType;if(u.isValue)switch(u.kind){case 11:return t.unary(s.UnaryOp.SqrtF32,l);case 12:return t.unary(s.UnaryOp.SqrtF64,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"sqrt",u.toString()),t.unreachable()}function I(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,1))return t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],1):n.compileExpression(i[0],a.Type.auto,0),u=n.currentType;if(u.isValue)switch(u.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:return l;case 11:return t.unary(s.UnaryOp.TruncF32,l);case 12:return t.unary(s.UnaryOp.TruncF64,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"trunc",u.toString()),t.unreachable()}function S(e){var n=e.compiler,t=n.module;if(We(e,!0)|qe(e,1,3))return t.unreachable();var r=e.operands,i=e.typeArguments,s=e.contextualType,o=i[0],l=s!=a.Type.auto&&o.isIntegerValue&&s.isIntegerValue&&s.size>o.size?s:o,u=n.compileExpression(r[0],n.options.usizeType,1),c=r.length,p=0,f=o.byteSize;if(c>=2){if((p=Ve(r[1],n))<0)return n.currentType=l,t.unreachable();if(3==c&&(f=Ke(r[2],f,n))<0)return n.currentType=l,t.unreachable()}return n.currentType=l,t.load(o.byteSize,o.isSignedIntegerValue,u,l.toNativeType(),p,f)}function N(e){var n=e.compiler,t=n.module;if(n.currentType=a.Type.void,We(e)|qe(e,2,4))return t.unreachable();var r=e.operands,i=r.length,s=e.typeArguments,o=e.contextualType,l=s[0],u=n.compileExpression(r[0],n.options.usizeType,1),c=e.contextIsExact?n.compileExpression(r[1],o,1):n.compileExpression(r[1],l,l.isIntegerValue?0:1),p=n.currentType;l.isIntegerValue&&(!p.isIntegerValue||p.size<l.size)&&(c=n.convertExpression(c,p,l,!1,r[1]),p=l);var f=0,d=l.byteSize;if(i>=3){if((f=Ve(r[2],n))<0)return n.currentType=a.Type.void,t.unreachable();if(4==i&&(d=Ke(r[3],d,n))<0)return n.currentType=a.Type.void,t.unreachable()}return n.currentType=a.Type.void,t.store(l.byteSize,u,c,p.toNativeType(),f,d)}function O(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,2))return t.unreachable();var i=e.operands,s=e.typeArguments,o=i[0],l=s?n.compileExpression(o,s[0],1):n.compileExpression(i[0],a.Type.auto),u=n.currentType;if(u.isValue){let e;if(!s&&o.isNumericLiteral?(e=n.compileExpression(i[1],u),n.currentType!=u&&(l=n.compileExpression(o,u=n.currentType,1))):e=n.compileExpression(i[1],u,1),u.isNumericValue)return n.makeAdd(l,e,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"add",u.toString()),t.unreachable()}function k(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,2))return t.unreachable();var i=e.operands,s=e.typeArguments,o=i[0],l=s?n.compileExpression(o,s[0],1):n.compileExpression(i[0],a.Type.auto),u=n.currentType;if(u.isValue){let e;if(!s&&o.isNumericLiteral?(e=n.compileExpression(i[1],u),n.currentType!=u&&(l=n.compileExpression(o,u=n.currentType,1))):e=n.compileExpression(i[1],u,1),u.isNumericValue)return n.makeSub(l,e,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"sub",u.toString()),t.unreachable()}function L(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,2))return t.unreachable();var i=e.operands,s=e.typeArguments,o=i[0],l=s?n.compileExpression(o,s[0],1):n.compileExpression(i[0],a.Type.auto),u=n.currentType;if(u.isValue){let e;if(!s&&o.isNumericLiteral?(e=n.compileExpression(i[1],u),n.currentType!=u&&(l=n.compileExpression(o,u=n.currentType,1))):e=n.compileExpression(i[1],u,1),u.isNumericValue)return n.makeMul(l,e,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"mul",u.toString()),t.unreachable()}function B(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,2))return t.unreachable();var i=e.operands,s=e.typeArguments,o=i[0],l=s?n.compileExpression(o,s[0],1):n.compileExpression(i[0],a.Type.auto),u=n.currentType;if(u.isValue){let e;if(!s&&o.isNumericLiteral?(e=n.compileExpression(i[1],u),n.currentType!=u&&(l=n.compileExpression(o,u=n.currentType,1))):e=n.compileExpression(i[1],u,1),u.isNumericValue)return n.makeDiv(l,e,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"div",u.toString()),t.unreachable()}function D(e){var n=e.compiler,t=n.module;if(He(e,32)|We(e,!0)|qe(e,1,2))return t.unreachable();var i=e.operands,a=e.typeArguments,s=e.contextualType,o=a[0],l=o.isIntegerValue&&s.isIntegerValue&&s.size>o.size?s:o;if(!o.isIntegerValue)return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"atomic.load",o.toString()),n.currentType=l,t.unreachable();var u=n.compileExpression(i[0],n.options.usizeType,1),c=2==i.length?Ve(i[1],n):0;return c<0?(n.currentType=l,t.unreachable()):(n.currentType=l,t.atomic_load(o.byteSize,u,l.toNativeType(),c))}function R(e){var n=e.compiler,t=n.module;if(He(e,32)|We(e)|qe(e,2,3))return t.unreachable();var i=e.operands,s=e.typeArguments,o=e.contextualType,l=s[0];if(!l.isIntegerValue)return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"atomic.store",l.toString()),n.currentType=a.Type.void,t.unreachable();var u=n.compileExpression(i[0],n.options.usizeType,1),c=e.contextIsExact?n.compileExpression(i[1],o,1):n.compileExpression(i[1],l,l.isIntegerValue?0:1),p=n.currentType;l.isIntegerValue&&(!p.isIntegerValue||p.size<l.size)&&(c=n.convertExpression(c,p,l,!1,i[1]),p=l);var f=3==i.length?Ve(i[2],n):0;return f<0?(n.currentType=a.Type.void,t.unreachable()):(n.currentType=a.Type.void,t.atomic_store(l.byteSize,u,c,p.toNativeType(),f))}function w(e,n,t){var i=e.compiler,a=i.module;if(He(e,32)|We(e,!0)|qe(e,2,3))return a.unreachable();var s=e.operands,o=e.typeArguments,l=e.contextualType,u=o[0];if(!u.isIntegerValue||u.size<8)return i.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,t,u.toString()),a.unreachable();var c=i.compileExpression(s[0],i.options.usizeType,1),p=e.contextIsExact?i.compileExpression(s[1],l,1):i.compileExpression(s[1],u,u.isIntegerValue?0:1),f=i.currentType;u.isIntegerValue&&(!f.isIntegerValue||f.size<u.size)&&(p=i.convertExpression(p,f,u,!1,s[1]),f=u);var d=3==s.length?Ve(s[2],i):0;return d<0?(i.currentType=f,a.unreachable()):(i.currentType=f,a.atomic_rmw(n,u.byteSize,d,c,p,f.toNativeType()))}function z(e){return w(e,s.AtomicRMWOp.Add,"atomic.add")}function P(e){return w(e,s.AtomicRMWOp.Sub,"atomic.sub")}function U(e){return w(e,s.AtomicRMWOp.And,"atomic.and")}function M(e){return w(e,s.AtomicRMWOp.Or,"atomic.or")}function G(e){return w(e,s.AtomicRMWOp.Xor,"atomic.xor")}function V(e){return w(e,s.AtomicRMWOp.Xchg,"atomic.xchg")}function K(e){var n=e.compiler,t=n.module;if(He(e,32)|We(e,!0)|qe(e,3,4))return t.unreachable();var i=e.operands,a=e.typeArguments,s=e.contextualType,o=a[0];if(!o.isIntegerValue||o.size<8)return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"atomic.cmpxchg",o.toString()),t.unreachable();var l=n.compileExpression(i[0],n.options.usizeType,1),u=e.contextIsExact?n.compileExpression(i[1],s,1):n.compileExpression(i[1],o,o.isIntegerValue?0:1),c=n.currentType,p=n.compileExpression(i[2],c,1);o.isIntegerValue&&(!c.isIntegerValue||c.size<o.size)&&(u=n.convertExpression(u,c,o,!1,i[1]),p=n.convertExpression(p,c,o,!1,i[2]),c=o);var f=4==i.length?Ve(i[3],n):0;return f<0?(n.currentType=c,t.unreachable()):(n.currentType=c,t.atomic_cmpxchg(o.byteSize,f,l,u,p,c.toNativeType()))}function H(e){var n=e.compiler,t=n.module;if(He(e,32)|We(e)|je(e,3))return n.currentType=a.Type.i32,t.unreachable();var i=e.operands,s=e.typeArguments[0],o=n.compileExpression(i[0],n.options.usizeType,1),l=n.compileExpression(i[1],s,1),u=n.compileExpression(i[2],a.Type.i64,1);switch(n.currentType=a.Type.i32,s.kind){case 2:case 3:case 4:case 7:case 8:case 9:return t.atomic_wait(o,l,u,s.toNativeType())}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"atomic.wait",s.toString()),t.unreachable()}function W(e,n){var t=e.compiler,i=t.module;Ye(e);var a=e.operands,s=e.reportNode;return t.emitDiagnostic(r.DiagnosticCode.User_defined_0,n,s.range,null,a.length?a[0].range.toString():s.range.toString()),n==r.DiagnosticCategory.ERROR?i.unreachable():i.nop()}function X(e,n){var t=e.compiler;return Ye(e)|je(e,1)?(t.currentType=n,t.module.unreachable()):t.compileExpression(e.operands[0],n,2)}function Y(e){var n=e.compiler,t=n.module;if(He(e,16)|Ye(e)|je(e,16))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=new Uint8Array(16);for(let e=0;e<16;++e){let l=n.compileExpression(i[e],a.Type.i8,1),u=t.runExpression(l,s.ExpressionRunnerFlags.PreserveSideeffects);u?p.writeI8(s.getConstValueI32(u),o,e):n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,i[e].range)}return n.currentType=a.Type.v128,t.v128(o)}function j(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],o,1);if(n.currentType=a.Type.v128,o.isValue)switch(o.kind){case 0:case 5:return t.unary(s.UnaryOp.SplatI8x16,l);case 1:case 6:return t.unary(s.UnaryOp.SplatI16x8,l);case 2:case 7:return t.unary(s.UnaryOp.SplatI32x4,l);case 3:case 8:return t.unary(s.UnaryOp.SplatI64x2,l);case 4:case 9:return t.unary(n.options.isWasm64?s.UnaryOp.SplatI64x2:s.UnaryOp.SplatI32x4,l);case 11:return t.unary(s.UnaryOp.SplatF32x4,l);case 12:return t.unary(s.UnaryOp.SplatF64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.splat",o.toString()),t.unreachable()}function q(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e,!0)|je(e,2))return t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.u8,1);n.currentType=o;var c=0,p=t.runExpression(u,s.ExpressionRunnerFlags.PreserveSideeffects);if(p?c=s.getConstValueI32(p):n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,i[1].range),o.isValue){let e=16/assert(o.byteSize)-1;switch((c<0||c>e)&&(n.error(r.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,i[1].range,"Lane index","0",e.toString()),c=0),o.kind){case 0:return t.simd_extract(s.SIMDExtractOp.ExtractLaneI8x16,l,c);case 5:return t.simd_extract(s.SIMDExtractOp.ExtractLaneU8x16,l,c);case 1:return t.simd_extract(s.SIMDExtractOp.ExtractLaneI16x8,l,c);case 6:return t.simd_extract(s.SIMDExtractOp.ExtractLaneU16x8,l,c);case 2:case 7:return t.simd_extract(s.SIMDExtractOp.ExtractLaneI32x4,l,c);case 3:case 8:return t.simd_extract(s.SIMDExtractOp.ExtractLaneI64x2,l,c);case 4:case 9:return t.simd_extract(n.options.isWasm64?s.SIMDExtractOp.ExtractLaneI64x2:s.SIMDExtractOp.ExtractLaneI32x4,l,c);case 11:return t.simd_extract(s.SIMDExtractOp.ExtractLaneF32x4,l,c);case 12:return t.simd_extract(s.SIMDExtractOp.ExtractLaneF64x2,l,c)}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.extract_lane",o.toString()),t.unreachable()}function Q(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,3))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.u8,1),c=n.compileExpression(i[2],o,1);n.currentType=a.Type.v128;var p=0,f=t.runExpression(u,s.ExpressionRunnerFlags.PreserveSideeffects);if(f?p=s.getConstValueI32(f):n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,i[1].range),o.isValue){let e=16/assert(o.byteSize)-1;switch((p<0||p>e)&&(n.error(r.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,i[1].range,"Lane index","0",e.toString()),p=0),o.kind){case 0:case 5:return t.simd_replace(s.SIMDReplaceOp.ReplaceLaneI8x16,l,p,c);case 1:case 6:return t.simd_replace(s.SIMDReplaceOp.ReplaceLaneI16x8,l,p,c);case 2:case 7:return t.simd_replace(s.SIMDReplaceOp.ReplaceLaneI32x4,l,p,c);case 3:case 8:return t.simd_replace(s.SIMDReplaceOp.ReplaceLaneI64x2,l,p,c);case 4:case 9:return t.simd_replace(n.options.isWasm64?s.SIMDReplaceOp.ReplaceLaneI64x2:s.SIMDReplaceOp.ReplaceLaneI32x4,l,p,c);case 11:return t.simd_replace(s.SIMDReplaceOp.ReplaceLaneF32x4,l,p,c);case 12:return t.simd_replace(s.SIMDReplaceOp.ReplaceLaneF64x2,l,p,c)}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.replace_lane",o.toString()),t.unreachable()}function Z(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0];if(o.isValue){let l=o.byteSize,u=16/l;if(assert(isInteger(u)&&p.isPowerOf2(u)),je(e,2+u))return n.currentType=a.Type.v128,t.unreachable();let c=n.compileExpression(i[0],a.Type.v128,1),f=n.compileExpression(i[1],a.Type.v128,1);switch(o.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 11:case 12:{let e=new Uint8Array(16),o=(u<<1)-1;for(let c=0;c<u;++c){let u=i[2+c],f=n.compileExpression(u,a.Type.u8,1),d=t.runExpression(f,s.ExpressionRunnerFlags.PreserveSideeffects),h=0;switch(d?(h=s.getConstValueI32(d),(h<0||h>o)&&(n.error(r.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,u.range,"Lane index","0",o.toString()),h=0)):n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,u.range),l){case 1:p.writeI8(h,e,c);break;case 2:{let n=c<<1,t=h<<1;p.writeI8(t,e,n),p.writeI8(t+1,e,n+1);break}case 4:{let n=c<<2,t=h<<2;p.writeI8(t,e,n),p.writeI8(t+1,e,n+1),p.writeI8(t+2,e,n+2),p.writeI8(t+3,e,n+3);break}case 8:{let n=c<<3,t=h<<3;p.writeI8(t,e,n),p.writeI8(t+1,e,n+1),p.writeI8(t+2,e,n+2),p.writeI8(t+3,e,n+3),p.writeI8(t+4,e,n+4),p.writeI8(t+5,e,n+5),p.writeI8(t+6,e,n+6),p.writeI8(t+7,e,n+7);break}default:assert(!1)}}return n.currentType=a.Type.v128,t.simd_shuffle(c,f,e)}}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.shuffle",o.toString()),n.currentType=a.Type.v128,t.unreachable()}function J(e){var n=e.compiler,t=n.module;if(He(e,16)|Ye(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var r=e.operands,i=n.compileExpression(r[0],a.Type.v128,1),o=n.compileExpression(r[1],a.Type.v128,1);return t.binary(s.BinaryOp.SwizzleV8x16,i,o)}function $(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e,!0)|qe(e,1,3))return t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],n.options.usizeType,1),u=i.length,c=0,p=o.byteSize;if(u>=2){if((c=Ve(i[1],n))<0)return n.currentType=a.Type.v128,t.unreachable();if(3==u&&(p=Ke(i[2],p,n))<0)return n.currentType=a.Type.v128,t.unreachable()}if(n.currentType=a.Type.v128,o.isValue)switch(o.kind){case 0:case 5:return t.simd_load(s.SIMDLoadOp.LoadSplatV8x16,l,c,p);case 1:case 6:return t.simd_load(s.SIMDLoadOp.LoadSplatV16x8,l,c,p);case 2:case 7:case 11:return t.simd_load(s.SIMDLoadOp.LoadSplatV32x4,l,c,p);case 4:case 9:if(!n.options.isWasm64)return t.simd_load(s.SIMDLoadOp.LoadSplatV32x4,l,c,p);case 3:case 8:case 12:return t.simd_load(s.SIMDLoadOp.LoadSplatV64x2,l,c,p)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.load_splat",o.toString()),t.unreachable()}function ee(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e,!0)|qe(e,1,3))return t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],n.options.usizeType,1),u=i.length,c=0,p=o.byteSize;if(u>=2){if((c=Ve(i[1],n))<0)return n.currentType=a.Type.v128,t.unreachable();if(3==u&&(p=Ke(i[2],p,n))<0)return n.currentType=a.Type.v128,t.unreachable()}if(n.currentType=a.Type.v128,o.isValue)switch(o.kind){case 0:return t.simd_load(s.SIMDLoadOp.LoadI8ToI16x8,l,c,p);case 5:return t.simd_load(s.SIMDLoadOp.LoadU8ToU16x8,l,c,p);case 1:return t.simd_load(s.SIMDLoadOp.LoadI16ToI32x4,l,c,p);case 6:return t.simd_load(s.SIMDLoadOp.LoadU16ToU32x4,l,c,p);case 4:if(n.options.isWasm64)break;case 2:return t.simd_load(s.SIMDLoadOp.LoadI32ToI64x2,l,c,p);case 9:if(n.options.isWasm64)break;case 7:return t.simd_load(s.SIMDLoadOp.LoadU32ToU64x2,l,c,p)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.load_ext",o.toString()),t.unreachable()}function ne(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:case 5:return t.binary(s.BinaryOp.AddI8x16,l,u);case 1:case 6:return t.binary(s.BinaryOp.AddI16x8,l,u);case 2:case 7:return t.binary(s.BinaryOp.AddI32x4,l,u);case 3:case 8:return t.binary(s.BinaryOp.AddI64x2,l,u);case 4:case 9:return t.binary(n.options.isWasm64?s.BinaryOp.AddI64x2:s.BinaryOp.AddI32x4,l,u);case 11:return t.binary(s.BinaryOp.AddF32x4,l,u);case 12:return t.binary(s.BinaryOp.AddF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.add",o.toString()),t.unreachable()}function te(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:case 5:return t.binary(s.BinaryOp.SubI8x16,l,u);case 1:case 6:return t.binary(s.BinaryOp.SubI16x8,l,u);case 2:case 7:return t.binary(s.BinaryOp.SubI32x4,l,u);case 3:case 8:return t.binary(s.BinaryOp.SubI64x2,l,u);case 4:case 9:return t.binary(n.options.isWasm64?s.BinaryOp.SubI64x2:s.BinaryOp.SubI32x4,l,u);case 11:return t.binary(s.BinaryOp.SubF32x4,l,u);case 12:return t.binary(s.BinaryOp.SubF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.sub",o.toString()),t.unreachable()}function re(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:case 5:return t.binary(s.BinaryOp.MulI8x16,l,u);case 1:case 6:return t.binary(s.BinaryOp.MulI16x8,l,u);case 2:case 7:return t.binary(s.BinaryOp.MulI32x4,l,u);case 4:case 9:if(!n.options.isWasm64)return t.binary(s.BinaryOp.MulI32x4,l,u);break;case 11:return t.binary(s.BinaryOp.MulF32x4,l,u);case 12:return t.binary(s.BinaryOp.MulF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.mul",o.toString()),t.unreachable()}function ie(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.binary(s.BinaryOp.DivF32x4,l,u);case 12:return t.binary(s.BinaryOp.DivF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.div",o.toString()),t.unreachable()}function ae(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.binary(s.BinaryOp.AddSatI8x16,l,u);case 5:return t.binary(s.BinaryOp.AddSatU8x16,l,u);case 1:return t.binary(s.BinaryOp.AddSatI16x8,l,u);case 6:return t.binary(s.BinaryOp.AddSatU16x8,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.add_saturate",o.toString()),t.unreachable()}function se(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.binary(s.BinaryOp.SubSatI8x16,l,u);case 5:return t.binary(s.BinaryOp.SubSatU8x16,l,u);case 1:return t.binary(s.BinaryOp.SubSatI16x8,l,u);case 6:return t.binary(s.BinaryOp.SubSatU16x8,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.sub_saturate",o.toString()),t.unreachable()}function oe(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.binary(s.BinaryOp.MinI8x16,l,u);case 5:return t.binary(s.BinaryOp.MinU8x16,l,u);case 1:return t.binary(s.BinaryOp.MinI16x8,l,u);case 6:return t.binary(s.BinaryOp.MinU16x8,l,u);case 4:if(n.options.isWasm64)break;case 2:return t.binary(s.BinaryOp.MinI32x4,l,u);case 9:if(n.options.isWasm64)break;case 7:return t.binary(s.BinaryOp.MinU32x4,l,u);case 11:return t.binary(s.BinaryOp.MinF32x4,l,u);case 12:return t.binary(s.BinaryOp.MinF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.min",o.toString()),t.unreachable()}function le(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.binary(s.BinaryOp.MaxI8x16,l,u);case 5:return t.binary(s.BinaryOp.MaxU8x16,l,u);case 1:return t.binary(s.BinaryOp.MaxI16x8,l,u);case 6:return t.binary(s.BinaryOp.MaxU16x8,l,u);case 4:if(n.options.isWasm64)break;case 2:return t.binary(s.BinaryOp.MaxI32x4,l,u);case 9:if(n.options.isWasm64)break;case 7:return t.binary(s.BinaryOp.MaxU32x4,l,u);case 11:return t.binary(s.BinaryOp.MaxF32x4,l,u);case 12:return t.binary(s.BinaryOp.MaxF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.max",o.toString()),t.unreachable()}function ue(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.binary(s.BinaryOp.PminF32x4,l,u);case 12:return t.binary(s.BinaryOp.PminF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.pmin",o.toString()),t.unreachable()}function ce(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.binary(s.BinaryOp.PmaxF32x4,l,u);case 12:return t.binary(s.BinaryOp.PmaxF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.pmax",o.toString()),t.unreachable()}function pe(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 1:return t.binary(s.BinaryOp.DotI16x8,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.dot",o.toString()),t.unreachable()}function fe(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 5:return t.binary(s.BinaryOp.AvgrU8x16,l,u);case 6:return t.binary(s.BinaryOp.AvgrU16x8,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.avgr",o.toString()),t.unreachable()}function de(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:case 5:return t.binary(s.BinaryOp.EqI8x16,l,u);case 1:case 6:return t.binary(s.BinaryOp.EqI16x8,l,u);case 2:case 7:return t.binary(s.BinaryOp.EqI32x4,l,u);case 4:case 9:if(!n.options.isWasm64)return t.binary(s.BinaryOp.EqI32x4,l,u);break;case 11:return t.binary(s.BinaryOp.EqF32x4,l,u);case 12:return t.binary(s.BinaryOp.EqF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.eq",o.toString()),t.unreachable()}function he(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:case 5:return t.binary(s.BinaryOp.NeI8x16,l,u);case 1:case 6:return t.binary(s.BinaryOp.NeI16x8,l,u);case 2:case 7:return t.binary(s.BinaryOp.NeI32x4,l,u);case 4:case 9:if(!n.options.isWasm64)return t.binary(s.BinaryOp.NeI32x4,l,u);break;case 11:return t.binary(s.BinaryOp.NeF32x4,l,u);case 12:return t.binary(s.BinaryOp.NeF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.ne",o.toString()),t.unreachable()}function ge(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.binary(s.BinaryOp.LtI8x16,l,u);case 5:return t.binary(s.BinaryOp.LtU8x16,l,u);case 1:return t.binary(s.BinaryOp.LtI16x8,l,u);case 6:return t.binary(s.BinaryOp.LtU16x8,l,u);case 2:return t.binary(s.BinaryOp.LtI32x4,l,u);case 7:return t.binary(s.BinaryOp.LtU32x4,l,u);case 4:if(!n.options.isWasm64)return t.binary(s.BinaryOp.LtI32x4,l,u);break;case 9:if(!n.options.isWasm64)return t.binary(s.BinaryOp.LtU32x4,l,u);break;case 11:return t.binary(s.BinaryOp.LtF32x4,l,u);case 12:return t.binary(s.BinaryOp.LtF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.lt",o.toString()),t.unreachable()}function xe(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.binary(s.BinaryOp.LeI8x16,l,u);case 5:return t.binary(s.BinaryOp.LeU8x16,l,u);case 1:return t.binary(s.BinaryOp.LeI16x8,l,u);case 6:return t.binary(s.BinaryOp.LeU16x8,l,u);case 2:return t.binary(s.BinaryOp.LeI32x4,l,u);case 7:return t.binary(s.BinaryOp.LeU32x4,l,u);case 4:if(!n.options.isWasm64)return t.binary(s.BinaryOp.LeI32x4,l,u);break;case 9:if(!n.options.isWasm64)return t.binary(s.BinaryOp.LeU32x4,l,u);break;case 11:return t.binary(s.BinaryOp.LeF32x4,l,u);case 12:return t.binary(s.BinaryOp.LeF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.le",o.toString()),t.unreachable()}function me(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.binary(s.BinaryOp.GtI8x16,l,u);case 5:return t.binary(s.BinaryOp.GtU8x16,l,u);case 1:return t.binary(s.BinaryOp.GtI16x8,l,u);case 6:return t.binary(s.BinaryOp.GtU16x8,l,u);case 2:return t.binary(s.BinaryOp.GtI32x4,l,u);case 7:return t.binary(s.BinaryOp.GtU32x4,l,u);case 4:if(!n.options.isWasm64)return t.binary(s.BinaryOp.GtI32x4,l,u);break;case 9:if(!n.options.isWasm64)return t.binary(s.BinaryOp.GtU32x4,l,u);break;case 11:return t.binary(s.BinaryOp.GtF32x4,l,u);case 12:return t.binary(s.BinaryOp.GtF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.gt",o.toString()),t.unreachable()}function _e(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.binary(s.BinaryOp.GeI8x16,l,u);case 5:return t.binary(s.BinaryOp.GeU8x16,l,u);case 1:return t.binary(s.BinaryOp.GeI16x8,l,u);case 6:return t.binary(s.BinaryOp.GeU16x8,l,u);case 2:return t.binary(s.BinaryOp.GeI32x4,l,u);case 7:return t.binary(s.BinaryOp.GeU32x4,l,u);case 4:if(!n.options.isWasm64)return t.binary(s.BinaryOp.GeI32x4,l,u);break;case 9:if(!n.options.isWasm64)return t.binary(s.BinaryOp.GeU32x4,l,u);break;case 11:return t.binary(s.BinaryOp.GeF32x4,l,u);case 12:return t.binary(s.BinaryOp.GeF64x2,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.ge",o.toString()),t.unreachable()}function ye(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1);if(o.isValue)switch(o.kind){case 1:return t.binary(s.BinaryOp.NarrowI16x8ToI8x16,l,u);case 6:return t.binary(s.BinaryOp.NarrowU16x8ToU8x16,l,u);case 2:return t.binary(s.BinaryOp.NarrowI32x4ToI16x8,l,u);case 7:return t.binary(s.BinaryOp.NarrowU32x4ToU16x8,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.narrow",o.toString()),t.unreachable()}function Ee(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:case 5:return t.unary(s.UnaryOp.NegI8x16,l);case 1:case 6:return t.unary(s.UnaryOp.NegI16x8,l);case 2:case 7:return t.unary(s.UnaryOp.NegI32x4,l);case 3:case 8:return t.unary(s.UnaryOp.NegI64x2,l);case 4:case 9:return t.unary(n.options.isWasm64?s.UnaryOp.NegI64x2:s.UnaryOp.NegI32x4,l);case 11:return t.unary(s.UnaryOp.NegF32x4,l);case 12:return t.unary(s.UnaryOp.NegF64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.neg",o.toString()),t.unreachable()}function Te(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.unary(s.UnaryOp.AbsI8x16,l);case 1:return t.unary(s.UnaryOp.AbsI16x8,l);case 4:if(n.options.isWasm64)break;case 2:return t.unary(s.UnaryOp.AbsI32x4,l);case 9:if(n.options.isWasm64)break;case 5:case 6:case 7:return l;case 11:return t.unary(s.UnaryOp.AbsF32x4,l);case 12:return t.unary(s.UnaryOp.AbsF64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.abs",o.toString()),t.unreachable()}function be(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.unary(s.UnaryOp.SqrtF32x4,l);case 12:return t.unary(s.UnaryOp.SqrtF64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.sqrt",o.toString()),t.unreachable()}function ve(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.unary(s.UnaryOp.CeilF32x4,l);case 12:return t.unary(s.UnaryOp.CeilF64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.ceil",o.toString()),t.unreachable()}function Ae(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.unary(s.UnaryOp.FloorF32x4,l);case 12:return t.unary(s.UnaryOp.FloorF64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.floor",o.toString()),t.unreachable()}function Fe(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.unary(s.UnaryOp.TruncF32x4,l);case 12:return t.unary(s.UnaryOp.TruncF64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.trunc",o.toString()),t.unreachable()}function Ce(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.unary(s.UnaryOp.NearestF32x4,l);case 12:return t.unary(s.UnaryOp.NearestF64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.nearest",o.toString()),t.unreachable()}function Ie(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 2:return t.unary(s.UnaryOp.ConvertI32x4ToF32x4,l);case 7:return t.unary(s.UnaryOp.ConvertU32x4ToF32x4,l);case 3:return t.unary(s.UnaryOp.ConvertI64x2ToF64x2,l);case 8:return t.unary(s.UnaryOp.ConvertU64x2ToF64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.convert",o.toString()),t.unreachable()}function Se(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 2:return t.unary(s.UnaryOp.TruncSatF32x4ToI32x4,l);case 7:return t.unary(s.UnaryOp.TruncSatF32x4ToU32x4,l);case 3:return t.unary(s.UnaryOp.TruncSatF64x2ToI64x2,l);case 8:return t.unary(s.UnaryOp.TruncSatF64x2ToU64x2,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.trunc_sat",o.toString()),t.unreachable()}function Ne(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.unary(s.UnaryOp.WidenLowI8x16ToI16x8,l);case 5:return t.unary(s.UnaryOp.WidenLowU8x16ToU16x8,l);case 1:return t.unary(s.UnaryOp.WidenLowI16x8ToI32x4,l);case 6:return t.unary(s.UnaryOp.WidenLowU16x8ToU32x4,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.widen_low",o.toString()),t.unreachable()}function Oe(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(o.isValue)switch(o.kind){case 0:return t.unary(s.UnaryOp.WidenHighI8x16ToI16x8,l);case 5:return t.unary(s.UnaryOp.WidenHighU8x16ToU16x8,l);case 1:return t.unary(s.UnaryOp.WidenHighI16x8ToI32x4,l);case 6:return t.unary(s.UnaryOp.WidenHighU16x8ToU32x4,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.widen_high",o.toString()),t.unreachable()}function ke(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.i32,1);if(n.currentType=a.Type.v128,o.isValue)switch(o.kind){case 0:case 5:return t.simd_shift(s.SIMDShiftOp.ShlI8x16,l,u);case 1:case 6:return t.simd_shift(s.SIMDShiftOp.ShlI16x8,l,u);case 2:case 7:return t.simd_shift(s.SIMDShiftOp.ShlI32x4,l,u);case 3:case 8:return t.simd_shift(s.SIMDShiftOp.ShlI64x2,l,u);case 4:case 9:return t.simd_shift(n.options.isWasm64?s.SIMDShiftOp.ShlI64x2:s.SIMDShiftOp.ShlI32x4,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.shl",o.toString()),t.unreachable()}function Le(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.i32,1);if(n.currentType=a.Type.v128,o.isValue)switch(o.kind){case 0:return t.simd_shift(s.SIMDShiftOp.ShrI8x16,l,u);case 5:return t.simd_shift(s.SIMDShiftOp.ShrU8x16,l,u);case 1:return t.simd_shift(s.SIMDShiftOp.ShrI16x8,l,u);case 6:return t.simd_shift(s.SIMDShiftOp.ShrU16x8,l,u);case 2:return t.simd_shift(s.SIMDShiftOp.ShrI32x4,l,u);case 7:return t.simd_shift(s.SIMDShiftOp.ShrU32x4,l,u);case 3:return t.simd_shift(s.SIMDShiftOp.ShrI64x2,l,u);case 8:return t.simd_shift(s.SIMDShiftOp.ShrU64x2,l,u);case 4:return t.simd_shift(n.options.isWasm64?s.SIMDShiftOp.ShrI64x2:s.SIMDShiftOp.ShrI32x4,l,u);case 9:return t.simd_shift(n.options.isWasm64?s.SIMDShiftOp.ShrU64x2:s.SIMDShiftOp.ShrU32x4,l,u)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.shr",o.toString()),t.unreachable()}function Be(e,n){var t=e.compiler,r=t.module;if(He(e,16)|Ye(e)|je(e,2))return t.currentType=a.Type.v128,r.unreachable();var i=e.operands,s=t.compileExpression(i[0],a.Type.v128,1),o=t.compileExpression(i[1],a.Type.v128,1);return r.binary(n,s,o)}function De(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.bool,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(n.currentType=a.Type.bool,o.isValue)switch(o.kind){case 0:case 5:return t.unary(s.UnaryOp.AnyTrueI8x16,l);case 1:case 6:return t.unary(s.UnaryOp.AnyTrueI16x8,l);case 2:case 7:return t.unary(s.UnaryOp.AnyTrueI32x4,l);case 3:case 8:return t.unary(s.UnaryOp.AnyTrueI64x2,l);case 4:case 9:return t.unary(n.options.isWasm64?s.UnaryOp.AnyTrueI64x2:s.UnaryOp.AnyTrueI32x4,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.any_true",o.toString()),t.unreachable()}function Re(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.bool,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(n.currentType=a.Type.bool,o.isValue)switch(o.kind){case 0:case 5:return t.unary(s.UnaryOp.AllTrueI8x16,l);case 1:case 6:return t.unary(s.UnaryOp.AllTrueI16x8,l);case 2:case 7:return t.unary(s.UnaryOp.AllTrueI32x4,l);case 3:case 8:return t.unary(s.UnaryOp.AllTrueI64x2,l);case 4:case 9:return t.unary(n.options.isWasm64?s.UnaryOp.AllTrueI64x2:s.UnaryOp.AllTrueI32x4,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.all_true",o.toString()),t.unreachable()}function we(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,1))return n.currentType=a.Type.i32,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1);if(n.currentType=a.Type.i32,o.isValue)switch(o.kind){case 0:case 5:return t.unary(s.UnaryOp.BitmaskI8x16,l);case 1:case 6:return t.unary(s.UnaryOp.BitmaskI16x8,l);case 4:case 9:if(n.options.isWasm64)break;case 2:case 7:return t.unary(s.UnaryOp.BitmaskI32x4,l)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.bitmask",o.toString()),t.unreachable()}function ze(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,3))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1),c=n.compileExpression(i[2],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.simd_ternary(s.SIMDTernaryOp.QFMAF32x4,l,u,c);case 12:return t.simd_ternary(s.SIMDTernaryOp.QFMAF64x2,l,u,c)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.qfma",o.toString()),t.unreachable()}function Pe(e){var n=e.compiler,t=n.module;if(He(e,16)|We(e)|je(e,3))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=e.typeArguments[0],l=n.compileExpression(i[0],a.Type.v128,1),u=n.compileExpression(i[1],a.Type.v128,1),c=n.compileExpression(i[2],a.Type.v128,1);if(o.isValue)switch(o.kind){case 11:return t.simd_ternary(s.SIMDTernaryOp.QFMSF32x4,l,u,c);case 12:return t.simd_ternary(s.SIMDTernaryOp.QFMSF64x2,l,u,c)}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"v128.qfms",o.toString()),t.unreachable()}function Ue(e,n){if(assert(n.type.isManaged),!n.visitRef){var t=e.program,r=e.module,i=t.options.usizeType,l=i.toNativeType(),u=i.byteSize,c=assert(t.visitInstance),p=new Array,f=n.base;f&&p.push(r.call(f.internalName+"~visit",[r.local_get(0,l),r.local_get(1,s.NativeType.I32)],s.NativeType.None));var d=!1;if(n.isDeclaredInLibrary){let i=n.lookupInSelf("__visit");if(i){assert(i.kind==o.ElementKind.FUNCTION_PROTOTYPE);let u=t.resolver.resolveFunction(i,null);if(u&&e.compileFunction(u)){let e=u.signature,t=assert(e.thisType);assert(1==e.parameterTypes.length&&e.parameterTypes[0]==a.Type.u32&&e.returnType==a.Type.void&&n.type.isStrictlyAssignableTo(t)),p.push(r.call(u.internalName,[r.local_get(0,l),r.local_get(1,s.NativeType.I32)],s.NativeType.None))}else p.push(r.unreachable());d=!0}}var h=!1;if(!d){let e=n.members;if(e)for(let t=Map_values(e),i=0,a=t.length;i<a;++i){let e=unchecked(t[i]);if(e.kind==o.ElementKind.FIELD&&e.parent===n&&e.type.isManaged){let n=e.memoryOffset;assert(n>=0),h=!0,p.push(r.if(r.local_tee(2,r.load(u,!1,r.local_get(0,l),l,n),!1),r.call(c.internalName,[r.local_get(2,l),r.local_get(1,s.NativeType.I32)],s.NativeType.None)))}}}n.visitRef=r.addFunction(n.internalName+"~visit",s.createType([l,s.NativeType.I32]),s.NativeType.None,h?[l]:null,r.flatten(p,s.NativeType.None)),f&&Ue(e,f)}}function Me(e){var n=64*(1<<e.alignLog2);return e.is(1)&&(n|=2048),e.is(8)&&(n|=4096),e.is(512)&&(n|=8192),e.isManaged&&(n|=16384),n/64}function Ge(e){var n=e.compiler,t=e.operands,i=e.typeArguments;if(0==t.length)return i&&1==i.length?i[0]:(n.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.reportNode.typeArgumentsRange,"1",i?i.length.toString():"0"),null);if(1==t.length){if(null!==i&&i.length>0){if(i.length>1)return n.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.reportNode.typeArgumentsRange,"1",i.length.toString()),null;n.compileExpression(t[0],i[0],1)}else n.compileExpression(t[0],a.Type.auto);return n.currentType}return null!==i&&i.length>1&&n.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.reportNode.typeArgumentsRange,"1",i.length.toString()),n.error(r.DiagnosticCode.Expected_0_arguments_but_got_1,e.reportNode.argumentsRange,"1",t.length.toString()),null}function Ve(e,n){var t,i=n.module;if(n.options.isWasm64){let o=n.compileExpression(e,a.Type.usize64,1),l=i.runExpression(o,s.ExpressionRunnerFlags.PreserveSideeffects);l?(assert(0==s.getConstValueI64High(l)),t=s.getConstValueI64Low(l)):(n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,e.range),t=-1)}else{let o=n.compileExpression(e,a.Type.usize32,1),l=i.runExpression(o,s.ExpressionRunnerFlags.PreserveSideeffects);l?t=s.getConstValueI32(l):(n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,e.range),t=-1)}return t}function Ke(e,n,t){var i=Ve(e,t);return i<0?i:i<1||n>16?(t.error(r.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,e.range,"Alignment","1",n.toString()),-1):p.isPowerOf2(i)?i:(t.error(r.DiagnosticCode._0_must_be_a_power_of_two,e.range,"Alignment"),-1)}function He(e,n){var t=e.compiler;return t.options.hasFeature(n)?0:(t.error(r.DiagnosticCode.Feature_0_is_not_enabled,e.reportNode.range,c.featureToString(n)),1)}function We(e,n=!1){var t=e.compiler,i=e.typeArguments;if(i){let a=i.length;if(1==a)return 0;assert(a),n&&(t.currentType=i[0]),t.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.reportNode.typeArgumentsRange,"1",a.toString())}else t.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.reportNode.range,"1","0");return 1}function Xe(e,n=!1){var t=e.typeArguments;if(t){let i=e.compiler,a=t.length;return 1==a?0:(assert(a),n&&(i.currentType=t[0]),i.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.reportNode.typeArgumentsRange,"1",a.toString()),1)}return 0}function Ye(e){if(e.typeArguments){let n=e.prototype;return n.program.error(r.DiagnosticCode.Type_0_is_not_generic,e.reportNode.typeArgumentsRange,n.internalName),1}return 0}function je(e,n){var t=e.operands;return t.length!=n?(e.compiler.error(r.DiagnosticCode.Expected_0_arguments_but_got_1,e.reportNode.range,n.toString(),t.length.toString()),1):0}function qe(e,n,t){var i=e.operands.length;return i<n?(e.compiler.error(r.DiagnosticCode.Expected_at_least_0_arguments_but_got_1,e.reportNode.range,n.toString(),i.toString()),1):i>t?(e.compiler.error(r.DiagnosticCode.Expected_0_arguments_but_got_1,e.reportNode.range,t.toString(),i.toString()),1):0}function Qe(e,n,t){var r=e.module;if(t!=a.Type.auto&&t.isIntegerValue)switch(t.kind){case 2:if(i64_is_i32(n))return e.currentType=a.Type.i32,r.i32(i64_low(n));break;case 7:if(i64_is_u32(n))return e.currentType=a.Type.u32,r.i32(i64_low(n));break;case 3:case 8:return e.currentType=t,r.i64(i64_low(n),i64_high(n))}return e.options.isWasm64?(e.currentType=a.Type.usize64,r.i64(i64_low(n),i64_high(n))):(e.currentType=a.Type.usize32,assert(!i64_high(n)),r.i32(i64_low(n)))}!function(e){e.start="~start",e.started="~started",e.argumentsLength="~argumentsLength",e.setArgumentsLength="~setArgumentsLength",e.abort="~lib/builtins/abort",e.trace="~lib/builtins/trace",e.seed="~lib/builtins/seed",e.isInteger="~lib/builtins/isInteger",e.isFloat="~lib/builtins/isFloat",e.isBoolean="~lib/builtins/isBoolean",e.isSigned="~lib/builtins/isSigned",e.isReference="~lib/builtins/isReference",e.isString="~lib/builtins/isString",e.isArray="~lib/builtins/isArray",e.isArrayLike="~lib/builtins/isArrayLike",e.isFunction="~lib/builtins/isFunction",e.isNullable="~lib/builtins/isNullable",e.isDefined="~lib/builtins/isDefined",e.isConstant="~lib/builtins/isConstant",e.isManaged="~lib/builtins/isManaged",e.isVoid="~lib/builtins/isVoid",e.add="~lib/builtins/add",e.sub="~lib/builtins/sub",e.mul="~lib/builtins/mul",e.div="~lib/builtins/div",e.clz="~lib/builtins/clz",e.ctz="~lib/builtins/ctz",e.popcnt="~lib/builtins/popcnt",e.rotl="~lib/builtins/rotl",e.rotr="~lib/builtins/rotr",e.abs="~lib/builtins/abs",e.max="~lib/builtins/max",e.min="~lib/builtins/min",e.ceil="~lib/builtins/ceil",e.floor="~lib/builtins/floor",e.copysign="~lib/builtins/copysign",e.nearest="~lib/builtins/nearest",e.reinterpret="~lib/builtins/reinterpret",e.sqrt="~lib/builtins/sqrt",e.trunc="~lib/builtins/trunc",e.load="~lib/builtins/load",e.store="~lib/builtins/store",e.atomic_load="~lib/builtins/atomic.load",e.atomic_store="~lib/builtins/atomic.store",e.atomic_add="~lib/builtins/atomic.add",e.atomic_sub="~lib/builtins/atomic.sub",e.atomic_and="~lib/builtins/atomic.and",e.atomic_or="~lib/builtins/atomic.or",e.atomic_xor="~lib/builtins/atomic.xor",e.atomic_xchg="~lib/builtins/atomic.xchg",e.atomic_cmpxchg="~lib/builtins/atomic.cmpxchg",e.atomic_wait="~lib/builtins/atomic.wait",e.atomic_notify="~lib/builtins/atomic.notify",e.atomic_fence="~lib/builtins/atomic.fence",e.sizeof="~lib/builtins/sizeof",e.alignof="~lib/builtins/alignof",e.offsetof="~lib/builtins/offsetof",e.nameof="~lib/builtins/nameof",e.lengthof="~lib/builtins/lengthof",e.select="~lib/builtins/select",e.unreachable="~lib/builtins/unreachable",e.changetype="~lib/builtins/changetype",e.assert="~lib/builtins/assert",e.call_indirect="~lib/builtins/call_indirect",e.unchecked="~lib/builtins/unchecked",e.instantiate="~lib/builtins/instantiate",e.idof="~lib/builtins/idof",e.i8="~lib/builtins/i8",e.i16="~lib/builtins/i16",e.i32="~lib/builtins/i32",e.i64="~lib/builtins/i64",e.isize="~lib/builtins/isize",e.u8="~lib/builtins/u8",e.u16="~lib/builtins/u16",e.u32="~lib/builtins/u32",e.u64="~lib/builtins/u64",e.usize="~lib/builtins/usize",e.bool="~lib/builtins/bool",e.f32="~lib/builtins/f32",e.f64="~lib/builtins/f64",e.v128="~lib/builtins/v128",e.i32_clz="~lib/builtins/i32.clz",e.i64_clz="~lib/builtins/i64.clz",e.i32_ctz="~lib/builtins/i32.ctz",e.i64_ctz="~lib/builtins/i64.ctz",e.i32_popcnt="~lib/builtins/i32.popcnt",e.i64_popcnt="~lib/builtins/i64.popcnt",e.i32_rotl="~lib/builtins/i32.rotl",e.i64_rotl="~lib/builtins/i64.rotl",e.i32_rotr="~lib/builtins/i32.rotr",e.i64_rotr="~lib/builtins/i64.rotr",e.f32_abs="~lib/builtins/f32.abs",e.f64_abs="~lib/builtins/f64.abs",e.f32_max="~lib/builtins/f32.max",e.f64_max="~lib/builtins/f64.max",e.f32_min="~lib/builtins/f32.min",e.f64_min="~lib/builtins/f64.min",e.f32_ceil="~lib/builtins/f32.ceil",e.f64_ceil="~lib/builtins/f64.ceil",e.f32_floor="~lib/builtins/f32.floor",e.f64_floor="~lib/builtins/f64.floor",e.f32_copysign="~lib/builtins/f32.copysign",e.f64_copysign="~lib/builtins/f64.copysign",e.f32_nearest="~lib/builtins/f32.nearest",e.f64_nearest="~lib/builtins/f64.nearest",e.i32_reinterpret_f32="~lib/builtins/i32.reinterpret_f32",e.i64_reinterpret_f64="~lib/builtins/i64.reinterpret_f64",e.f32_reinterpret_i32="~lib/builtins/f32.reinterpret_i32",e.f64_reinterpret_i64="~lib/builtins/f64.reinterpret_i64",e.f32_sqrt="~lib/builtins/f32.sqrt",e.f64_sqrt="~lib/builtins/f64.sqrt",e.f32_trunc="~lib/builtins/f32.trunc",e.f64_trunc="~lib/builtins/f64.trunc",e.i32_add="~lib/builtins/i32.add",e.i64_add="~lib/builtins/i64.add",e.f32_add="~lib/builtins/f32.add",e.f64_add="~lib/builtins/f64.add",e.i32_sub="~lib/builtins/i32.sub",e.i64_sub="~lib/builtins/i64.sub",e.f32_sub="~lib/builtins/f32.sub",e.f64_sub="~lib/builtins/f64.sub",e.i32_mul="~lib/builtins/i32.mul",e.i64_mul="~lib/builtins/i64.mul",e.f32_mul="~lib/builtins/f32.mul",e.f64_mul="~lib/builtins/f64.mul",e.i32_div_s="~lib/builtins/i32.div_s",e.i32_div_u="~lib/builtins/i32.div_u",e.i64_div_s="~lib/builtins/i64.div_s",e.i64_div_u="~lib/builtins/i64.div_u",e.f32_div="~lib/builtins/f32.div",e.f64_div="~lib/builtins/f64.div",e.i32_load8_s="~lib/builtins/i32.load8_s",e.i32_load8_u="~lib/builtins/i32.load8_u",e.i32_load16_s="~lib/builtins/i32.load16_s",e.i32_load16_u="~lib/builtins/i32.load16_u",e.i32_load="~lib/builtins/i32.load",e.i64_load8_s="~lib/builtins/i64.load8_s",e.i64_load8_u="~lib/builtins/i64.load8_u",e.i64_load16_s="~lib/builtins/i64.load16_s",e.i64_load16_u="~lib/builtins/i64.load16_u",e.i64_load32_s="~lib/builtins/i64.load32_s",e.i64_load32_u="~lib/builtins/i64.load32_u",e.i64_load="~lib/builtins/i64.load",e.f32_load="~lib/builtins/f32.load",e.f64_load="~lib/builtins/f64.load",e.i32_store8="~lib/builtins/i32.store8",e.i32_store16="~lib/builtins/i32.store16",e.i32_store="~lib/builtins/i32.store",e.i64_store8="~lib/builtins/i64.store8",e.i64_store16="~lib/builtins/i64.store16",e.i64_store32="~lib/builtins/i64.store32",e.i64_store="~lib/builtins/i64.store",e.f32_store="~lib/builtins/f32.store",e.f64_store="~lib/builtins/f64.store",e.i32_atomic_load8_u="~lib/builtins/i32.atomic.load8_u",e.i32_atomic_load16_u="~lib/builtins/i32.atomic.load16_u",e.i32_atomic_load="~lib/builtins/i32.atomic.load",e.i64_atomic_load8_u="~lib/builtins/i64.atomic.load8_u",e.i64_atomic_load16_u="~lib/builtins/i64.atomic.load16_u",e.i64_atomic_load32_u="~lib/builtins/i64.atomic.load32_u",e.i64_atomic_load="~lib/builtins/i64.atomic.load",e.i32_atomic_store8="~lib/builtins/i32.atomic.store8",e.i32_atomic_store16="~lib/builtins/i32.atomic.store16",e.i32_atomic_store="~lib/builtins/i32.atomic.store",e.i64_atomic_store8="~lib/builtins/i64.atomic.store8",e.i64_atomic_store16="~lib/builtins/i64.atomic.store16",e.i64_atomic_store32="~lib/builtins/i64.atomic.store32",e.i64_atomic_store="~lib/builtins/i64.atomic.store",e.i32_atomic_rmw8_add_u="~lib/builtins/i32.atomic.rmw8.add_u",e.i32_atomic_rmw16_add_u="~lib/builtins/i32.atomic.rmw16.add_u",e.i32_atomic_rmw_add="~lib/builtins/i32.atomic.rmw.add",e.i64_atomic_rmw8_add_u="~lib/builtins/i64.atomic.rmw8.add_u",e.i64_atomic_rmw16_add_u="~lib/builtins/i64.atomic.rmw16.add_u",e.i64_atomic_rmw32_add_u="~lib/builtins/i64.atomic.rmw32.add_u",e.i64_atomic_rmw_add="~lib/builtins/i64.atomic.rmw.add",e.i32_atomic_rmw8_sub_u="~lib/builtins/i32.atomic.rmw8.sub_u",e.i32_atomic_rmw16_sub_u="~lib/builtins/i32.atomic.rmw16.sub_u",e.i32_atomic_rmw_sub="~lib/builtins/i32.atomic.rmw.sub",e.i64_atomic_rmw8_sub_u="~lib/builtins/i64.atomic.rmw8.sub_u",e.i64_atomic_rmw16_sub_u="~lib/builtins/i64.atomic.rmw16.sub_u",e.i64_atomic_rmw32_sub_u="~lib/builtins/i64.atomic.rmw32.sub_u",e.i64_atomic_rmw_sub="~lib/builtins/i64.atomic.rmw.sub",e.i32_atomic_rmw8_and_u="~lib/builtins/i32.atomic.rmw8.and_u",e.i32_atomic_rmw16_and_u="~lib/builtins/i32.atomic.rmw16.and_u",e.i32_atomic_rmw_and="~lib/builtins/i32.atomic.rmw.and",e.i64_atomic_rmw8_and_u="~lib/builtins/i64.atomic.rmw8.and_u",e.i64_atomic_rmw16_and_u="~lib/builtins/i64.atomic.rmw16.and_u",e.i64_atomic_rmw32_and_u="~lib/builtins/i64.atomic.rmw32.and_u",e.i64_atomic_rmw_and="~lib/builtins/i64.atomic.rmw.and",e.i32_atomic_rmw8_or_u="~lib/builtins/i32.atomic.rmw8.or_u",e.i32_atomic_rmw16_or_u="~lib/builtins/i32.atomic.rmw16.or_u",e.i32_atomic_rmw_or="~lib/builtins/i32.atomic.rmw.or",e.i64_atomic_rmw8_or_u="~lib/builtins/i64.atomic.rmw8.or_u",e.i64_atomic_rmw16_or_u="~lib/builtins/i64.atomic.rmw16.or_u",e.i64_atomic_rmw32_or_u="~lib/builtins/i64.atomic.rmw32.or_u",e.i64_atomic_rmw_or="~lib/builtins/i64.atomic.rmw.or",e.i32_atomic_rmw8_xor_u="~lib/builtins/i32.atomic.rmw8.xor_u",e.i32_atomic_rmw16_xor_u="~lib/builtins/i32.atomic.rmw16.xor_u",e.i32_atomic_rmw_xor="~lib/builtins/i32.atomic.rmw.xor",e.i64_atomic_rmw8_xor_u="~lib/builtins/i64.atomic.rmw8.xor_u",e.i64_atomic_rmw16_xor_u="~lib/builtins/i64.atomic.rmw16.xor_u",e.i64_atomic_rmw32_xor_u="~lib/builtins/i64.atomic.rmw32.xor_u",e.i64_atomic_rmw_xor="~lib/builtins/i64.atomic.rmw.xor",e.i32_atomic_rmw8_xchg_u="~lib/builtins/i32.atomic.rmw8.xchg_u",e.i32_atomic_rmw16_xchg_u="~lib/builtins/i32.atomic.rmw16.xchg_u",e.i32_atomic_rmw_xchg="~lib/builtins/i32.atomic.rmw.xchg",e.i64_atomic_rmw8_xchg_u="~lib/builtins/i64.atomic.rmw8.xchg_u",e.i64_atomic_rmw16_xchg_u="~lib/builtins/i64.atomic.rmw16.xchg_u",e.i64_atomic_rmw32_xchg_u="~lib/builtins/i64.atomic.rmw32.xchg_u",e.i64_atomic_rmw_xchg="~lib/builtins/i64.atomic.rmw.xchg",e.i32_atomic_rmw8_cmpxchg_u="~lib/builtins/i32.atomic.rmw8.cmpxchg_u",e.i32_atomic_rmw16_cmpxchg_u="~lib/builtins/i32.atomic.rmw16.cmpxchg_u",e.i32_atomic_rmw_cmpxchg="~lib/builtins/i32.atomic.rmw.cmpxchg",e.i64_atomic_rmw8_cmpxchg_u="~lib/builtins/i64.atomic.rmw8.cmpxchg_u",e.i64_atomic_rmw16_cmpxchg_u="~lib/builtins/i64.atomic.rmw16.cmpxchg_u",e.i64_atomic_rmw32_cmpxchg_u="~lib/builtins/i64.atomic.rmw32.cmpxchg_u",e.i64_atomic_rmw_cmpxchg="~lib/builtins/i64.atomic.rmw.cmpxchg",e.i32_wait="~lib/builtins/i32.wait",e.i64_wait="~lib/builtins/i64.wait",e.v128_splat="~lib/builtins/v128.splat",e.v128_extract_lane="~lib/builtins/v128.extract_lane",e.v128_replace_lane="~lib/builtins/v128.replace_lane",e.v128_shuffle="~lib/builtins/v128.shuffle",e.v128_swizzle="~lib/builtins/v128.swizzle",e.v128_load_splat="~lib/builtins/v128.load_splat",e.v128_load_ext="~lib/builtins/v128.load_ext",e.v128_load="~lib/builtins/v128.load",e.v128_store="~lib/builtins/v128.store",e.v128_add="~lib/builtins/v128.add",e.v128_sub="~lib/builtins/v128.sub",e.v128_mul="~lib/builtins/v128.mul",e.v128_div="~lib/builtins/v128.div",e.v128_neg="~lib/builtins/v128.neg",e.v128_add_saturate="~lib/builtins/v128.add_saturate",e.v128_sub_saturate="~lib/builtins/v128.sub_saturate",e.v128_shl="~lib/builtins/v128.shl",e.v128_shr="~lib/builtins/v128.shr",e.v128_and="~lib/builtins/v128.and",e.v128_or="~lib/builtins/v128.or",e.v128_xor="~lib/builtins/v128.xor",e.v128_andnot="~lib/builtins/v128.andnot",e.v128_not="~lib/builtins/v128.not",e.v128_bitselect="~lib/builtins/v128.bitselect",e.v128_any_true="~lib/builtins/v128.any_true",e.v128_all_true="~lib/builtins/v128.all_true",e.v128_bitmask="~lib/builtins/v128.bitmask",e.v128_min="~lib/builtins/v128.min",e.v128_max="~lib/builtins/v128.max",e.v128_pmin="~lib/builtins/v128.pmin",e.v128_pmax="~lib/builtins/v128.pmax",e.v128_dot="~lib/builtins/v128.dot",e.v128_avgr="~lib/builtins/v128.avgr",e.v128_abs="~lib/builtins/v128.abs",e.v128_sqrt="~lib/builtins/v128.sqrt",e.v128_ceil="~lib/builtins/v128.ceil",e.v128_floor="~lib/builtins/v128.floor",e.v128_trunc="~lib/builtins/v128.trunc",e.v128_nearest="~lib/builtins/v128.nearest",e.v128_eq="~lib/builtins/v128.eq",e.v128_ne="~lib/builtins/v128.ne",e.v128_lt="~lib/builtins/v128.lt",e.v128_le="~lib/builtins/v128.le",e.v128_gt="~lib/builtins/v128.gt",e.v128_ge="~lib/builtins/v128.ge",e.v128_convert="~lib/builtins/v128.convert",e.v128_trunc_sat="~lib/builtins/v128.trunc_sat",e.v128_narrow="~lib/builtins/v128.narrow",e.v128_widen_low="~lib/builtins/v128.widen_low",e.v128_widen_high="~lib/builtins/v128.widen_high",e.v128_qfma="~lib/builtins/v128.qfma",e.v128_qfms="~lib/builtins/v128.qfms",e.i8x16="~lib/builtins/i8x16",e.i16x8="~lib/builtins/i16x8",e.i32x4="~lib/builtins/i32x4",e.i64x2="~lib/builtins/i64x2",e.f32x4="~lib/builtins/f32x4",e.f64x2="~lib/builtins/f64x2",e.i8x16_splat="~lib/builtins/i8x16.splat",e.i8x16_extract_lane_s="~lib/builtins/i8x16.extract_lane_s",e.i8x16_extract_lane_u="~lib/builtins/i8x16.extract_lane_u",e.i8x16_replace_lane="~lib/builtins/i8x16.replace_lane",e.i8x16_add="~lib/builtins/i8x16.add",e.i8x16_sub="~lib/builtins/i8x16.sub",e.i8x16_mul="~lib/builtins/i8x16.mul",e.i8x16_min_s="~lib/builtins/i8x16.min_s",e.i8x16_min_u="~lib/builtins/i8x16.min_u",e.i8x16_max_s="~lib/builtins/i8x16.max_s",e.i8x16_max_u="~lib/builtins/i8x16.max_u",e.i8x16_avgr_u="~lib/builtins/i8x16.avgr_u",e.i8x16_abs="~lib/builtins/i8x16.abs",e.i8x16_neg="~lib/builtins/i8x16.neg",e.i8x16_add_saturate_s="~lib/builtins/i8x16.add_saturate_s",e.i8x16_add_saturate_u="~lib/builtins/i8x16.add_saturate_u",e.i8x16_sub_saturate_s="~lib/builtins/i8x16.sub_saturate_s",e.i8x16_sub_saturate_u="~lib/builtins/i8x16.sub_saturate_u",e.i8x16_shl="~lib/builtins/i8x16.shl",e.i8x16_shr_s="~lib/builtins/i8x16.shr_s",e.i8x16_shr_u="~lib/builtins/i8x16.shr_u",e.i8x16_any_true="~lib/builtins/i8x16.any_true",e.i8x16_all_true="~lib/builtins/i8x16.all_true",e.i8x16_bitmask="~lib/builtins/i8x16.bitmask",e.i8x16_eq="~lib/builtins/i8x16.eq",e.i8x16_ne="~lib/builtins/i8x16.ne",e.i8x16_lt_s="~lib/builtins/i8x16.lt_s",e.i8x16_lt_u="~lib/builtins/i8x16.lt_u",e.i8x16_le_s="~lib/builtins/i8x16.le_s",e.i8x16_le_u="~lib/builtins/i8x16.le_u",e.i8x16_gt_s="~lib/builtins/i8x16.gt_s",e.i8x16_gt_u="~lib/builtins/i8x16.gt_u",e.i8x16_ge_s="~lib/builtins/i8x16.ge_s",e.i8x16_ge_u="~lib/builtins/i8x16.ge_u",e.i8x16_narrow_i16x8_s="~lib/builtins/i8x16.narrow_i16x8_s",e.i8x16_narrow_i16x8_u="~lib/builtins/i8x16.narrow_i16x8_u",e.i16x8_splat="~lib/builtins/i16x8.splat",e.i16x8_extract_lane_s="~lib/builtins/i16x8.extract_lane_s",e.i16x8_extract_lane_u="~lib/builtins/i16x8.extract_lane_u",e.i16x8_replace_lane="~lib/builtins/i16x8.replace_lane",e.i16x8_add="~lib/builtins/i16x8.add",e.i16x8_sub="~lib/builtins/i16x8.sub",e.i16x8_mul="~lib/builtins/i16x8.mul",e.i16x8_min_s="~lib/builtins/i16x8.min_s",e.i16x8_min_u="~lib/builtins/i16x8.min_u",e.i16x8_max_s="~lib/builtins/i16x8.max_s",e.i16x8_max_u="~lib/builtins/i16x8.max_u",e.i16x8_avgr_u="~lib/builtins/i16x8.avgr_u",e.i16x8_abs="~lib/builtins/i16x8.abs",e.i16x8_neg="~lib/builtins/i16x8.neg",e.i16x8_add_saturate_s="~lib/builtins/i16x8.add_saturate_s",e.i16x8_add_saturate_u="~lib/builtins/i16x8.add_saturate_u",e.i16x8_sub_saturate_s="~lib/builtins/i16x8.sub_saturate_s",e.i16x8_sub_saturate_u="~lib/builtins/i16x8.sub_saturate_u",e.i16x8_shl="~lib/builtins/i16x8.shl",e.i16x8_shr_s="~lib/builtins/i16x8.shr_s",e.i16x8_shr_u="~lib/builtins/i16x8.shr_u",e.i16x8_any_true="~lib/builtins/i16x8.any_true",e.i16x8_all_true="~lib/builtins/i16x8.all_true",e.i16x8_bitmask="~lib/builtins/i16x8.bitmask",e.i16x8_eq="~lib/builtins/i16x8.eq",e.i16x8_ne="~lib/builtins/i16x8.ne",e.i16x8_lt_s="~lib/builtins/i16x8.lt_s",e.i16x8_lt_u="~lib/builtins/i16x8.lt_u",e.i16x8_le_s="~lib/builtins/i16x8.le_s",e.i16x8_le_u="~lib/builtins/i16x8.le_u",e.i16x8_gt_s="~lib/builtins/i16x8.gt_s",e.i16x8_gt_u="~lib/builtins/i16x8.gt_u",e.i16x8_ge_s="~lib/builtins/i16x8.ge_s",e.i16x8_ge_u="~lib/builtins/i16x8.ge_u",e.i16x8_narrow_i32x4_s="~lib/builtins/i16x8.narrow_i32x4_s",e.i16x8_narrow_i32x4_u="~lib/builtins/i16x8.narrow_i32x4_u",e.i16x8_widen_low_i8x16_s="~lib/builtins/i16x8.widen_low_i8x16_s",e.i16x8_widen_low_i8x16_u="~lib/builtins/i16x8.widen_low_i8x16_u",e.i16x8_widen_high_i8x16_s="~lib/builtins/i16x8.widen_high_i8x16_s",e.i16x8_widen_high_i8x16_u="~lib/builtins/i16x8.widen_high_i8x16_u",e.i16x8_load8x8_s="~lib/builtins/i16x8.load8x8_s",e.i16x8_load8x8_u="~lib/builtins/i16x8.load8x8_u",e.i32x4_splat="~lib/builtins/i32x4.splat",e.i32x4_extract_lane="~lib/builtins/i32x4.extract_lane",e.i32x4_replace_lane="~lib/builtins/i32x4.replace_lane",e.i32x4_add="~lib/builtins/i32x4.add",e.i32x4_sub="~lib/builtins/i32x4.sub",e.i32x4_mul="~lib/builtins/i32x4.mul",e.i32x4_min_s="~lib/builtins/i32x4.min_s",e.i32x4_min_u="~lib/builtins/i32x4.min_u",e.i32x4_max_s="~lib/builtins/i32x4.max_s",e.i32x4_max_u="~lib/builtins/i32x4.max_u",e.i32x4_dot_i16x8_s="~lib/builtins/i32x4.dot_i16x8_s",e.i32x4_abs="~lib/builtins/i32x4.abs",e.i32x4_neg="~lib/builtins/i32x4.neg",e.i32x4_shl="~lib/builtins/i32x4.shl",e.i32x4_shr_s="~lib/builtins/i32x4.shr_s",e.i32x4_shr_u="~lib/builtins/i32x4.shr_u",e.i32x4_any_true="~lib/builtins/i32x4.any_true",e.i32x4_all_true="~lib/builtins/i32x4.all_true",e.i32x4_bitmask="~lib/builtins/i32x4.bitmask",e.i32x4_eq="~lib/builtins/i32x4.eq",e.i32x4_ne="~lib/builtins/i32x4.ne",e.i32x4_lt_s="~lib/builtins/i32x4.lt_s",e.i32x4_lt_u="~lib/builtins/i32x4.lt_u",e.i32x4_le_s="~lib/builtins/i32x4.le_s",e.i32x4_le_u="~lib/builtins/i32x4.le_u",e.i32x4_gt_s="~lib/builtins/i32x4.gt_s",e.i32x4_gt_u="~lib/builtins/i32x4.gt_u",e.i32x4_ge_s="~lib/builtins/i32x4.ge_s",e.i32x4_ge_u="~lib/builtins/i32x4.ge_u",e.i32x4_trunc_sat_f32x4_s="~lib/builtins/i32x4.trunc_sat_f32x4_s",e.i32x4_trunc_sat_f32x4_u="~lib/builtins/i32x4.trunc_sat_f32x4_u",e.i32x4_widen_low_i16x8_s="~lib/builtins/i32x4.widen_low_i16x8_s",e.i32x4_widen_low_i16x8_u="~lib/builtins/i32x4.widen_low_i16x8_u",e.i32x4_widen_high_i16x8_s="~lib/builtins/i32x4.widen_high_i16x8_s",e.i32x4_widen_high_i16x8_u="~lib/builtins/i32x4.widen_high_i16x8_u",e.i32x4_load16x4_s="~lib/builtins/i32x4.load16x4_s",e.i32x4_load16x4_u="~lib/builtins/i32x4.load16x4_u",e.i64x2_splat="~lib/builtins/i64x2.splat",e.i64x2_extract_lane="~lib/builtins/i64x2.extract_lane",e.i64x2_replace_lane="~lib/builtins/i64x2.replace_lane",e.i64x2_add="~lib/builtins/i64x2.add",e.i64x2_sub="~lib/builtins/i64x2.sub",e.i64x2_neg="~lib/builtins/i64x2.neg",e.i64x2_shl="~lib/builtins/i64x2.shl",e.i64x2_shr_s="~lib/builtins/i64x2.shr_s",e.i64x2_shr_u="~lib/builtins/i64x2.shr_u",e.i64x2_any_true="~lib/builtins/i64x2.any_true",e.i64x2_all_true="~lib/builtins/i64x2.all_true",e.i64x2_trunc_sat_f64x2_s="~lib/builtins/i64x2.trunc_sat_f64x2_s",e.i64x2_trunc_sat_f64x2_u="~lib/builtins/i64x2.trunc_sat_f64x2_u",e.i64x2_load32x2_s="~lib/builtins/i64x2.load32x2_s",e.i64x2_load32x2_u="~lib/builtins/i64x2.load32x2_u",e.f32x4_splat="~lib/builtins/f32x4.splat",e.f32x4_extract_lane="~lib/builtins/f32x4.extract_lane",e.f32x4_replace_lane="~lib/builtins/f32x4.replace_lane",e.f32x4_add="~lib/builtins/f32x4.add",e.f32x4_sub="~lib/builtins/f32x4.sub",e.f32x4_mul="~lib/builtins/f32x4.mul",e.f32x4_div="~lib/builtins/f32x4.div",e.f32x4_neg="~lib/builtins/f32x4.neg",e.f32x4_min="~lib/builtins/f32x4.min",e.f32x4_max="~lib/builtins/f32x4.max",e.f32x4_pmin="~lib/builtins/f32x4.pmin",e.f32x4_pmax="~lib/builtins/f32x4.pmax",e.f32x4_abs="~lib/builtins/f32x4.abs",e.f32x4_sqrt="~lib/builtins/f32x4.sqrt",e.f32x4_ceil="~lib/builtins/f32x4.ceil",e.f32x4_floor="~lib/builtins/f32x4.floor",e.f32x4_trunc="~lib/builtins/f32x4.trunc",e.f32x4_nearest="~lib/builtins/f32x4.nearest",e.f32x4_eq="~lib/builtins/f32x4.eq",e.f32x4_ne="~lib/builtins/f32x4.ne",e.f32x4_lt="~lib/builtins/f32x4.lt",e.f32x4_le="~lib/builtins/f32x4.le",e.f32x4_gt="~lib/builtins/f32x4.gt",e.f32x4_ge="~lib/builtins/f32x4.ge",e.f32x4_convert_i32x4_s="~lib/builtins/f32x4.convert_i32x4_s",e.f32x4_convert_i32x4_u="~lib/builtins/f32x4.convert_i32x4_u",e.f32x4_qfma="~lib/builtins/f32x4.qfma",e.f32x4_qfms="~lib/builtins/f32x4.qfms",e.f64x2_splat="~lib/builtins/f64x2.splat",e.f64x2_extract_lane="~lib/builtins/f64x2.extract_lane",e.f64x2_replace_lane="~lib/builtins/f64x2.replace_lane",e.f64x2_add="~lib/builtins/f64x2.add",e.f64x2_sub="~lib/builtins/f64x2.sub",e.f64x2_mul="~lib/builtins/f64x2.mul",e.f64x2_div="~lib/builtins/f64x2.div",e.f64x2_neg="~lib/builtins/f64x2.neg",e.f64x2_min="~lib/builtins/f64x2.min",e.f64x2_max="~lib/builtins/f64x2.max",e.f64x2_pmin="~lib/builtins/f64x2.pmin",e.f64x2_pmax="~lib/builtins/f64x2.pmax",e.f64x2_abs="~lib/builtins/f64x2.abs",e.f64x2_sqrt="~lib/builtins/f64x2.sqrt",e.f64x2_ceil="~lib/builtins/f64x2.ceil",e.f64x2_floor="~lib/builtins/f64x2.floor",e.f64x2_trunc="~lib/builtins/f64x2.trunc",e.f64x2_nearest="~lib/builtins/f64x2.nearest",e.f64x2_eq="~lib/builtins/f64x2.eq",e.f64x2_ne="~lib/builtins/f64x2.ne",e.f64x2_lt="~lib/builtins/f64x2.lt",e.f64x2_le="~lib/builtins/f64x2.le",e.f64x2_gt="~lib/builtins/f64x2.gt",e.f64x2_ge="~lib/builtins/f64x2.ge",e.f64x2_convert_i64x2_s="~lib/builtins/f64x2.convert_i64x2_s",e.f64x2_convert_i64x2_u="~lib/builtins/f64x2.convert_i64x2_u",e.f64x2_qfma="~lib/builtins/f64x2.qfma",e.f64x2_qfms="~lib/builtins/f64x2.qfms",e.v8x16_shuffle="~lib/builtins/v8x16.shuffle",e.v8x16_swizzle="~lib/builtins/v8x16.swizzle",e.v8x16_load_splat="~lib/builtins/v8x16.load_splat",e.v16x8_load_splat="~lib/builtins/v16x8.load_splat",e.v32x4_load_splat="~lib/builtins/v32x4.load_splat",e.v64x2_load_splat="~lib/builtins/v64x2.load_splat",e.data_end="~lib/memory/__data_end",e.stack_pointer="~lib/memory/__stack_pointer",e.heap_base="~lib/memory/__heap_base",e.rtti_base="~lib/rt/__rtti_base",e.visit_globals="~lib/rt/__visit_globals",e.visit_members="~lib/rt/__visit_members",e.tostack="~lib/rt/__tostack",e.isNaN="~lib/number/isNaN",e.isFinite="~lib/number/isFinite",e.ERROR="~lib/diagnostics/ERROR",e.WARNING="~lib/diagnostics/WARNING",e.INFO="~lib/diagnostics/INFO",e.Function="~lib/function/Function",e.memory_size="~lib/memory/memory.size",e.memory_grow="~lib/memory/memory.grow",e.memory_copy="~lib/memory/memory.copy",e.memory_fill="~lib/memory/memory.fill",e.memory_data="~lib/memory/memory.data",e.Int8Array="~lib/typedarray/Int8Array",e.Uint8Array="~lib/typedarray/Uint8Array",e.Uint8ClampedArray="~lib/typedarray/Uint8ClampedArray",e.Int16Array="~lib/typedarray/Int16Array",e.Uint16Array="~lib/typedarray/Uint16Array",e.Int32Array="~lib/typedarray/Int32Array",e.Uint32Array="~lib/typedarray/Uint32Array",e.Int64Array="~lib/typedarray/Int64Array",e.Uint64Array="~lib/typedarray/Uint64Array",e.Float32Array="~lib/typedarray/Float32Array",e.Float64Array="~lib/typedarray/Float64Array",e.wasiAbort="~lib/wasi/index/abort",e.wasiTrace="~lib/wasi/index/trace",e.wasiSeed="~lib/wasi/index/seed"}(f=n.BuiltinNames||(n.BuiltinNames={})),n.BuiltinContext=class{constructor(e,n,t,r,i,a,s,o){this.compiler=e,this.prototype=n,this.typeArguments=t,this.operands=r,this.thisOperand=i,this.contextualType=a,this.reportNode=s,this.contextIsExact=o}},n.builtins=new Map,n.function_builtins=new Map,n.builtins.set(f.isInteger,(function(e){var n=e.compiler,t=n.module,r=Ge(e);return n.currentType=a.Type.bool,r?t.i32(r.isIntegerValue?1:0):t.unreachable()})),n.builtins.set(f.isFloat,(function(e){var n=e.compiler,t=n.module,r=Ge(e);return n.currentType=a.Type.bool,r?t.i32(r.isFloatValue?1:0):t.unreachable()})),n.builtins.set(f.isBoolean,(function(e){var n=e.compiler,t=n.module,r=Ge(e);return n.currentType=a.Type.bool,r?t.i32(r.isBooleanValue?1:0):t.unreachable()})),n.builtins.set(f.isSigned,(function(e){var n=e.compiler,t=n.module,r=Ge(e);return n.currentType=a.Type.bool,r?t.i32(r.isSignedIntegerValue?1:0):t.unreachable()})),n.builtins.set(f.isReference,(function(e){var n=e.compiler,t=n.module,r=Ge(e);return n.currentType=a.Type.bool,r?t.i32(r.isReference?1:0):t.unreachable()})),n.builtins.set(f.isString,(function(e){var n=e.compiler,t=n.module,r=Ge(e);if(n.currentType=a.Type.bool,!r)return t.unreachable();var i=r.getClass();return t.i32(null!==i&&i.isAssignableTo(n.program.stringInstance)?1:0)})),n.builtins.set(f.isArray,(function(e){var n=e.compiler,t=n.module,r=Ge(e);if(n.currentType=a.Type.bool,!r)return t.unreachable();var i=r.getClass();return t.i32(null!==i&&i.extends(n.program.arrayPrototype)?1:0)})),n.builtins.set(f.isArrayLike,(function(e){var n=e.compiler,t=n.module,r=Ge(e);if(n.currentType=a.Type.bool,!r)return t.unreachable();var i=r.getClass();return t.i32(null!==i&&i.isArrayLike?1:0)})),n.builtins.set(f.isFunction,(function(e){var n=e.compiler,t=n.module,r=Ge(e);return n.currentType=a.Type.bool,r?t.i32(r.isFunction?1:0):t.unreachable()})),n.builtins.set(f.isNullable,(function(e){var n=e.compiler,t=n.module,r=Ge(e);return n.currentType=a.Type.bool,r?t.i32(r.isNullableReference?1:0):t.unreachable()})),n.builtins.set(f.isDefined,(function(e){var n=e.compiler,t=n.module;if(n.currentType=a.Type.bool,Ye(e)|je(e,1))return t.unreachable();var r=n.resolver.lookupExpression(e.operands[0],n.currentFlow,a.Type.auto,u.ReportMode.SWALLOW);return t.i32(null!==r?1:0)})),n.builtins.set(f.isConstant,(function(e){var n=e.compiler,t=n.module;if(n.currentType=a.Type.bool,Ye(e)|je(e,1))return t.unreachable();var r=n.compileExpression(e.operands[0],a.Type.auto);return n.currentType=a.Type.bool,t.i32(s.getExpressionId(r)==s.ExpressionId.Const?1:0)})),n.builtins.set(f.isManaged,(function(e){var n=e.compiler,t=n.module,r=Ge(e);return n.currentType=a.Type.bool,r?t.i32(r.isManaged?1:0):t.unreachable()})),n.builtins.set(f.isVoid,(function(e){var n=e.compiler,t=n.module,r=Ge(e);return n.currentType=a.Type.bool,r?t.i32(18==r.kind?1:0):t.unreachable()})),n.builtins.set(f.lengthof,(function(e){var n=e.compiler,t=n.module,i=Ge(e);if(n.currentType=a.Type.i32,!i)return t.unreachable();var s=i.signatureReference;return s?t.i32(s.parameterTypes.length):(n.error(r.DiagnosticCode.Type_0_has_no_call_signatures,e.reportNode.range,i.toString()),t.unreachable())})),n.builtins.set(f.sizeof,(function(e){var n=e.compiler,t=n.module;if(n.currentType=n.options.usizeType,We(e)|je(e,0))return t.unreachable();var i=e.typeArguments[0],a=i.byteSize;return a?Qe(n,i64_new(a),e.contextualType):(n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"sizeof",i.toString()),t.unreachable())})),n.builtins.set(f.alignof,(function(e){var n=e.compiler,t=n.module;if(n.currentType=n.options.usizeType,We(e)|je(e,0))return t.unreachable();var i=e.typeArguments[0],a=i.byteSize;return p.isPowerOf2(a)?Qe(n,i64_new(ctz(a)),e.contextualType):(n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"alignof",i.toString()),t.unreachable())})),n.builtins.set(f.offsetof,(function(e){var n=e.compiler,t=n.module;if(n.currentType=n.options.usizeType,We(e)|qe(e,0,1))return t.unreachable();var s=e.operands,l=e.contextualType,u=e.typeArguments[0],c=u.getClassOrWrapper(n.program);if(!c)return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"offsetof",u.toString()),n.options.isWasm64?l.isIntegerValue&&l.size<=32&&(n.currentType=a.Type.u32):l.isIntegerValue&&64==l.size&&(n.currentType=a.Type.u64),t.unreachable();if(s.length){let e=s[0];if(!e.isLiteralKind(i.LiteralKind.STRING))return n.error(r.DiagnosticCode.String_literal_expected,s[0].range),t.unreachable();let a=e.value,u=c.members;if(null!==u&&u.has(a)){let e=assert(u.get(a));if(e.kind==o.ElementKind.FIELD)return Qe(n,i64_new(e.memoryOffset),l)}return n.error(r.DiagnosticCode.Type_0_has_no_property_1,e.range,c.internalName,a),t.unreachable()}return Qe(n,i64_new(c.nextMemoryOffset),l)})),n.builtins.set(f.nameof,(function(e){var n,t=e.compiler,r=t.module,i=Ge(e);if(!i)return t.currentType=t.program.stringInstance.type,r.unreachable();if(i.isInternalReference){let e=i.getClass();e?n=e.name:(assert(i.getSignature()),n="Function")}else n=i.toString();return t.ensureStaticString(n)})),n.builtins.set(f.idof,(function(e){var n=e.compiler,t=n.module,i=Ge(e);if(n.currentType=a.Type.u32,!i)return t.unreachable();let s=i.getSignature();if(s)return t.i32(s.id);let l=i.getClassOrWrapper(n.program);return null===l||l.hasDecorator(o.DecoratorFlags.UNMANAGED)?(n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"idof",i.toString()),t.unreachable()):t.i32(l.id)})),n.builtins.set(f.clz,d),n.builtins.set(f.ctz,h),n.builtins.set(f.popcnt,g),n.builtins.set(f.rotl,x),n.builtins.set(f.rotr,m),n.builtins.set(f.abs,_),n.builtins.set(f.max,y),n.builtins.set(f.min,E),n.builtins.set(f.ceil,T),n.builtins.set(f.floor,b),n.builtins.set(f.copysign,v),n.builtins.set(f.nearest,A),n.builtins.set(f.reinterpret,F),n.builtins.set(f.sqrt,C),n.builtins.set(f.trunc,I),n.builtins.set(f.isNaN,(function(e){var n=e.compiler,t=n.module;if(Xe(e)|je(e,1))return n.currentType=a.Type.bool,t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],1):n.compileExpression(i[0],a.Type.auto),u=n.currentType;if(n.currentType=a.Type.bool,u.isValue)switch(u.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:return t.maybeDropCondition(l,t.i32(0));case 11:{if(s.getExpressionId(l)==s.ExpressionId.LocalGet)return t.binary(s.BinaryOp.NeF32,l,t.local_get(s.getLocalGetIndex(l),s.NativeType.F32));let e=n.currentFlow,r=e.getTempLocal(a.Type.f32),i=t.binary(s.BinaryOp.NeF32,t.local_tee(r.index,l,!1),t.local_get(r.index,s.NativeType.F32));return e.freeTempLocal(r),i}case 12:{if(s.getExpressionId(l)==s.ExpressionId.LocalGet)return t.binary(s.BinaryOp.NeF64,l,t.local_get(s.getLocalGetIndex(l),s.NativeType.F64));let e=n.currentFlow,r=e.getTempLocal(a.Type.f64),i=t.binary(s.BinaryOp.NeF64,t.local_tee(r.index,l,!1),t.local_get(r.index,s.NativeType.F64));return e.freeTempLocal(r),i}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"isNaN",u.toString()),t.unreachable()})),n.builtins.set(f.isFinite,(function(e){var n=e.compiler,t=n.module;if(Xe(e)|je(e,1))return n.currentType=a.Type.bool,t.unreachable();var i=e.operands,o=e.typeArguments,l=o?n.compileExpression(i[0],o[0],1):n.compileExpression(i[0],a.Type.auto),u=n.currentType;if(n.currentType=a.Type.bool,u.isValue)switch(u.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:return t.maybeDropCondition(l,t.i32(1));case 11:{if(s.getExpressionId(l)==s.ExpressionId.LocalGet)return t.binary(s.BinaryOp.EqF32,t.binary(s.BinaryOp.SubF32,l,t.local_get(s.getLocalGetIndex(l),s.NativeType.F32)),t.f32(0));let e=n.currentFlow,r=e.getTempLocal(a.Type.f32),i=t.binary(s.BinaryOp.EqF32,t.binary(s.BinaryOp.SubF32,t.local_tee(r.index,l,!1),t.local_get(r.index,s.NativeType.F32)),t.f32(0));return e.freeTempLocal(r),i}case 12:{if(s.getExpressionId(l)==s.ExpressionId.LocalGet)return t.binary(s.BinaryOp.EqF64,t.binary(s.BinaryOp.SubF64,l,t.local_get(s.getLocalGetIndex(l),s.NativeType.F64)),t.f64(0));let e=n.currentFlow,r=e.getTempLocal(a.Type.f64),i=t.binary(s.BinaryOp.EqF64,t.binary(s.BinaryOp.SubF64,t.local_tee(r.index,l,!1),t.local_get(r.index,s.NativeType.F64)),t.f64(0));return e.freeTempLocal(r),i}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"isFinite",u.toString()),t.unreachable()})),n.builtins.set(f.load,S),n.builtins.set(f.store,N),n.builtins.set(f.add,O),n.builtins.set(f.sub,k),n.builtins.set(f.mul,L),n.builtins.set(f.div,B),n.builtins.set(f.atomic_load,D),n.builtins.set(f.atomic_store,R),n.builtins.set(f.atomic_add,z),n.builtins.set(f.atomic_sub,P),n.builtins.set(f.atomic_and,U),n.builtins.set(f.atomic_or,M),n.builtins.set(f.atomic_xor,G),n.builtins.set(f.atomic_xchg,V),n.builtins.set(f.atomic_cmpxchg,K),n.builtins.set(f.atomic_wait,H),n.builtins.set(f.atomic_notify,(function(e){var n=e.compiler,t=n.module;if(He(e,32)|Ye(e)|je(e,2))return n.currentType=a.Type.i32,t.unreachable();var r=e.operands,i=n.compileExpression(r[0],n.options.usizeType,1),s=n.compileExpression(r[1],a.Type.i32,1);return n.currentType=a.Type.i32,t.atomic_notify(i,s)})),n.builtins.set(f.atomic_fence,(function(e){var n=e.compiler,t=n.module;return n.currentType=a.Type.void,He(e,32)|Ye(e)|je(e,0)?t.unreachable():t.atomic_fence()})),n.builtins.set(f.select,(function(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|je(e,3))return t.unreachable();var i=e.operands,s=e.typeArguments,o=s?n.compileExpression(i[0],s[0],1):n.compileExpression(i[0],a.Type.auto),l=n.currentType;if(!l.isAny(384))return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"select",l.toString()),t.unreachable();var u=n.compileExpression(i[1],l,1),c=n.makeIsTrueish(n.compileExpression(i[2],a.Type.bool),n.currentType,i[2]);return n.currentType=l,t.select(o,u,c)})),n.builtins.set(f.unreachable,(function(e){return Ye(e),je(e,0),e.compiler.module.unreachable()})),n.builtins.set(f.memory_size,(function(e){var n=e.compiler,t=n.module;return n.currentType=a.Type.i32,Ye(e)|je(e,0)?t.unreachable():t.memory_size()})),n.builtins.set(f.memory_grow,(function(e){var n=e.compiler,t=n.module;return n.currentType=a.Type.i32,Ye(e)|je(e,1)?t.unreachable():t.memory_grow(n.compileExpression(e.operands[0],a.Type.i32,1))})),n.builtins.set(f.memory_copy,(function(e){var n=e.compiler,t=n.module;if(n.currentType=a.Type.void,Ye(e)|je(e,3))return t.unreachable();var r=e.operands;if(!n.options.hasFeature(8)){let i=n.resolver.resolveFunction(e.prototype,null);return n.currentType=a.Type.void,i&&n.compileFunction(i,!0)?n.compileCallDirect(i,r,e.reportNode):t.unreachable()}var i=n.options.usizeType,s=n.compileExpression(r[0],i,1),o=n.compileExpression(r[1],i,1),l=n.compileExpression(r[2],i,1);return n.currentType=a.Type.void,t.memory_copy(s,o,l)})),n.builtins.set(f.memory_fill,(function(e){var n=e.compiler,t=n.module;if(n.currentType=a.Type.void,Ye(e)|je(e,3))return t.unreachable();var r=e.operands;if(!n.options.hasFeature(8)){let i=n.resolver.resolveFunction(e.prototype,null);return n.currentType=a.Type.void,i&&n.compileFunction(i,!0)?n.compileCallDirect(i,r,e.reportNode):t.unreachable()}var i=n.options.usizeType,s=n.compileExpression(r[0],i,1),o=n.compileExpression(r[1],a.Type.u8,1),l=n.compileExpression(r[2],i,1);return n.currentType=a.Type.void,t.memory_fill(s,o,l)})),n.builtins.set(f.memory_data,(function(e){var n=e.compiler,t=n.module;if(n.currentType=a.Type.i32,Xe(e)|qe(e,1,2))return t.unreachable();var o,l=e.typeArguments,u=e.operands,c=u.length,p=n.options.usizeType;if(null!==l&&l.length>0){let a=l[0];if(!a.isValue)return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"memory.data",a.toString()),n.currentType=p,t.unreachable();let f=u[0];if(f.kind!=i.NodeKind.LITERAL||f.literalKind!=i.LiteralKind.ARRAY)return n.error(r.DiagnosticCode.Array_literal_expected,u[0].range),n.currentType=p,t.unreachable();let d=f.elementExpressions,h=d.length,g=new Array(h),x=!0;for(let e=0;e<h;++e){let r=d[e];if(r.kind!=i.NodeKind.OMITTED){let i=n.compileExpression(r,a,1),o=t.runExpression(i,s.ExpressionRunnerFlags.PreserveSideeffects);o?i=o:x=!1,g[e]=i}else g[e]=n.makeZero(a,r)}if(!x)return n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,f.range),n.currentType=p,t.unreachable();let m=a.byteSize;if(2==c&&(m=Ke(u[1],m,n),m<0))return n.currentType=p,t.unreachable();let _=new Uint8Array(h*a.byteSize);assert(n.writeStaticBuffer(_,0,a,g)==_.byteLength),o=n.addAlignedMemorySegment(_,m).offset}else{let e=n.compileExpression(u[0],a.Type.i32,1),i=t.runExpression(e,s.ExpressionRunnerFlags.PreserveSideeffects);if(!i)return n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,u[0].range),n.currentType=p,t.unreachable();let l=s.getConstValueI32(i);if(l<1)return n.error(r.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,u[0].range,"1",i32.MAX_VALUE.toString()),n.currentType=p,t.unreachable();let f=16;if(2==c&&(f=Ke(u[1],f,n),f<0))return n.currentType=p,t.unreachable();o=n.addAlignedMemorySegment(new Uint8Array(l),f).offset}return n.currentType=p,p==a.Type.usize32?(assert(!i64_high(o)),t.i32(i64_low(o))):t.i64(i64_low(o),i64_high(o))})),n.builtins.set(f.changetype,(function(e){var n=e.compiler,t=n.module;if(We(e,!0)|je(e,1))return t.unreachable();var i=e.operands,s=e.typeArguments[0],o=n.compileExpression(i[0],a.Type.auto),l=n.currentType;return n.currentType=s,l.isChangeableTo(s)?o:(n.error(r.DiagnosticCode.Type_0_cannot_be_changed_to_type_1,e.reportNode.range,l.toString(),s.toString()),t.unreachable())})),n.builtins.set(f.assert,(function(e){var n=e.compiler,t=n.module,i=e.typeArguments;if(Xe(e,!0)|qe(e,1,2))return i&&(assert(i.length),n.currentType=i[0].nonNullableType),t.unreachable();var o=e.operands,u=e.contextualType,c=i?n.compileExpression(o[0],i[0],5):n.compileExpression(o[0],a.Type.bool,4),p=n.currentType;if(n.currentType=p.nonNullableType,n.options.noAssert)return c;var f=t.runExpression(c,s.ExpressionRunnerFlags.Default);if(f)switch(s.getExpressionType(f)){case s.NativeType.I32:if(s.getConstValueI32(f))return c;break;case s.NativeType.I64:if(s.getConstValueI64Low(f)|s.getConstValueI64High(f))return c;break;case s.NativeType.F32:if(s.getConstValueF32(f))return c;break;case s.NativeType.F64:if(s.getConstValueF64(f))return c}var d=n.makeAbort(2==o.length?o[1]:null,e.reportNode);if(n.currentType=p.nonNullableType,u==a.Type.void)switch(n.currentType=a.Type.void,p.kind){case 0:case 1:case 2:case 5:case 6:case 7:case 10:return t.if(t.unary(s.UnaryOp.EqzI32,c),d);case 3:case 8:return t.if(t.unary(s.UnaryOp.EqzI64,c),d);case 4:case 9:return t.if(t.unary(n.options.isWasm64?s.UnaryOp.EqzI64:s.UnaryOp.EqzI32,c),d);case 11:return t.if(t.binary(s.BinaryOp.EqF32,c,t.f32(0)),d);case 12:return t.if(t.binary(s.BinaryOp.EqF64,c,t.f64(0)),d);case 14:case 15:case 16:case 17:return t.if(t.ref_is_null(c),d)}else{n.currentType=p.nonNullableType;let e=n.currentFlow;switch(n.currentType.kind){case 0:case 1:case 2:case 5:case 6:case 7:case 10:{let n=e.getTempLocal(p);e.setLocalFlag(n.index,l.LocalFlags.WRAPPED);let r=t.if(t.local_tee(n.index,c,!1),t.local_get(n.index,s.NativeType.I32),d);return e.freeTempLocal(n),r}case 3:case 8:{let n=e.getTempLocal(a.Type.i64),r=t.if(t.unary(s.UnaryOp.EqzI64,t.local_tee(n.index,c,!1)),d,t.local_get(n.index,s.NativeType.I64));return e.freeTempLocal(n),r}case 4:case 9:{let r=e.getTempLocal(n.options.usizeType),i=t.if(t.unary(n.options.isWasm64?s.UnaryOp.EqzI64:s.UnaryOp.EqzI32,t.local_tee(r.index,c,p.isManaged)),d,t.local_get(r.index,n.options.nativeSizeType));return e.freeTempLocal(r),i}case 11:{let n=e.getTempLocal(a.Type.f32),r=t.if(t.binary(s.BinaryOp.EqF32,t.local_tee(n.index,c,!1),t.f32(0)),d,t.local_get(n.index,s.NativeType.F32));return e.freeTempLocal(n),r}case 12:{let n=e.getTempLocal(a.Type.f64),r=t.if(t.binary(s.BinaryOp.EqF64,t.local_tee(n.index,c,!1),t.f64(0)),d,t.local_get(n.index,s.NativeType.F64));return e.freeTempLocal(n),r}case 14:case 15:case 16:case 17:{let n=e.getTempLocal(p),r=t.if(t.ref_is_null(t.local_tee(n.index,c,!1)),d,t.local_get(n.index,s.NativeType.F64));return e.freeTempLocal(n),r}}}return n.error(r.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,e.reportNode.typeArgumentsRange,"assert",n.currentType.toString()),d})),n.builtins.set(f.unchecked,(function(e){var n=e.compiler,t=n.module;if(Ye(e)|je(e,1))return t.unreachable();var r=n.currentFlow,i=r.is(32768);r.set(32768);var a=n.compileExpression(e.operands[0],e.contextualType);return i||r.unset(32768),a})),n.builtins.set(f.call_indirect,(function(e){var n=e.compiler,t=n.module;if(Xe(e,!0)|qe(e,1,i32.MAX_VALUE))return t.unreachable();var r,i=e.operands,o=e.typeArguments;o?(assert(o.length),r=o[0]):r=e.contextualType;var l=n.compileExpression(i[0],a.Type.u32,1),u=i.length-1,c=new Array(u),p=new Array(u);for(let e=0;e<u;++e)c[e]=n.compileExpression(i[1+e],a.Type.auto),p[e]=n.currentType.toNativeType();return n.currentType=r,t.call_indirect(l,c,s.createType(p),r.toNativeType())})),n.builtins.set(f.instantiate,(function(e){var n=e.compiler,t=n.module;if(We(e,!0))return t.unreachable();var i=e.operands,a=e.typeArguments[0].getClass();if(!a)return n.error(r.DiagnosticCode.This_expression_is_not_constructable,e.reportNode.expression.range),t.unreachable();n.currentType=a.type;var s=n.ensureConstructor(a,e.reportNode);return n.checkFieldInitialization(a,e.reportNode),n.compileInstantiate(s,i,0,e.reportNode)})),n.builtins.set(f.ERROR,(function(e){return W(e,r.DiagnosticCategory.ERROR)})),n.builtins.set(f.WARNING,(function(e){return W(e,r.DiagnosticCategory.WARNING)})),n.builtins.set(f.INFO,(function(e){return W(e,r.DiagnosticCategory.INFO)})),n.function_builtins.set("call",(function(e){var n=e.compiler,t=e.prototype.parent;assert(t.kind==o.ElementKind.CLASS);var s=t;assert(s.prototype==n.program.functionPrototype);var l=assert(s.typeArguments);assert(1==l.length);var u=l[0],c=assert(u.getSignature()),p=c.returnType;if(Ye(e)|qe(e,1+c.requiredParameters,1+c.parameterTypes.length))return n.currentType=p,n.module.unreachable();var f=n.compileExpression(assert(e.thisOperand),u,1),d=assert(e.operands.shift()),h=c.thisType,g=0;if(h)g=n.compileExpression(d,h,1);else if(d.kind!=i.NodeKind.NULL)return n.error(r.DiagnosticCode._this_cannot_be_referenced_in_current_location,d.range),n.module.unreachable();return n.compileCallIndirect(c,f,e.operands,e.reportNode,g,e.contextualType==a.Type.void)})),n.builtins.set(f.i8,(function(e){return X(e,a.Type.i8)})),n.builtins.set(f.i16,(function(e){return X(e,a.Type.i16)})),n.builtins.set(f.i32,(function(e){return X(e,a.Type.i32)})),n.builtins.set(f.i64,(function(e){return X(e,a.Type.i64)})),n.builtins.set(f.isize,(function(e){return X(e,e.compiler.options.isizeType)})),n.builtins.set(f.u8,(function(e){return X(e,a.Type.u8)})),n.builtins.set(f.u16,(function(e){return X(e,a.Type.u16)})),n.builtins.set(f.u32,(function(e){return X(e,a.Type.u32)})),n.builtins.set(f.u64,(function(e){return X(e,a.Type.u64)})),n.builtins.set(f.usize,(function(e){return X(e,e.compiler.options.usizeType)})),n.builtins.set(f.bool,(function(e){return X(e,a.Type.bool)})),n.builtins.set(f.f32,(function(e){return X(e,a.Type.f32)})),n.builtins.set(f.f64,(function(e){return X(e,a.Type.f64)})),n.builtins.set(f.v128,(function(e){return Y(e)})),n.builtins.set(f.i8x16,Y),n.builtins.set(f.i16x8,(function(e){var n=e.compiler,t=n.module;if(He(e,16)|Ye(e)|je(e,8))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=new Uint8Array(16);for(let e=0;e<8;++e){let l=n.compileExpression(i[e],a.Type.i16,1),u=t.runExpression(l,s.ExpressionRunnerFlags.PreserveSideeffects);u?p.writeI16(s.getConstValueI32(u),o,e<<1):n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,i[e].range)}return n.currentType=a.Type.v128,t.v128(o)})),n.builtins.set(f.i32x4,(function(e){var n=e.compiler,t=n.module;if(He(e,16)|Ye(e)|je(e,4))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=new Uint8Array(16);for(let e=0;e<4;++e){let l=n.compileExpression(i[e],a.Type.i32,1),u=t.runExpression(l,s.ExpressionRunnerFlags.PreserveSideeffects);u?p.writeI32(s.getConstValueI32(u),o,e<<2):n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,i[e].range)}return n.currentType=a.Type.v128,t.v128(o)})),n.builtins.set(f.i64x2,(function(e){var n=e.compiler,t=n.module;if(He(e,16)|Ye(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=new Uint8Array(16);for(let e=0;e<2;++e){let l=n.compileExpression(i[e],a.Type.i64,1),u=t.runExpression(l,s.ExpressionRunnerFlags.PreserveSideeffects);if(u){let n=e<<3;p.writeI32(s.getConstValueI64Low(u),o,n),p.writeI32(s.getConstValueI64High(u),o,n+4)}else n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,i[e].range)}return n.currentType=a.Type.v128,t.v128(o)})),n.builtins.set(f.f32x4,(function(e){var n=e.compiler,t=n.module;if(He(e,16)|Ye(e)|je(e,4))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=new Uint8Array(16);for(let e=0;e<4;++e){let l=n.compileExpression(i[e],a.Type.f32,1),u=t.runExpression(l,s.ExpressionRunnerFlags.PreserveSideeffects);u?p.writeF32(s.getConstValueF32(u),o,e<<2):n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,i[e].range)}return n.currentType=a.Type.v128,t.v128(o)})),n.builtins.set(f.f64x2,(function(e){var n=e.compiler,t=n.module;if(He(e,16)|Ye(e)|je(e,2))return n.currentType=a.Type.v128,t.unreachable();var i=e.operands,o=new Uint8Array(16);for(let e=0;e<2;++e){let l=n.compileExpression(i[e],a.Type.f64,1),u=t.runExpression(l,s.ExpressionRunnerFlags.PreserveSideeffects);u?p.writeF64(s.getConstValueF64(u),o,e<<3):n.error(r.DiagnosticCode.Expression_must_be_a_compile_time_constant,i[e].range)}return n.currentType=a.Type.v128,t.v128(o)})),n.builtins.set(f.v128_splat,j),n.builtins.set(f.v128_extract_lane,q),n.builtins.set(f.v128_replace_lane,Q),n.builtins.set(f.v128_shuffle,Z),n.builtins.set(f.v128_swizzle,J),n.builtins.set(f.v128_load_splat,$),n.builtins.set(f.v128_load_ext,ee),n.builtins.set(f.v128_add,ne),n.builtins.set(f.v128_sub,te),n.builtins.set(f.v128_mul,re),n.builtins.set(f.v128_div,ie),n.builtins.set(f.v128_add_saturate,ae),n.builtins.set(f.v128_sub_saturate,se),n.builtins.set(f.v128_min,oe),n.builtins.set(f.v128_max,le),n.builtins.set(f.v128_pmin,ue),n.builtins.set(f.v128_pmax,ce),n.builtins.set(f.v128_dot,pe),n.builtins.set(f.v128_avgr,fe),n.builtins.set(f.v128_eq,de),n.builtins.set(f.v128_ne,he),n.builtins.set(f.v128_lt,ge),n.builtins.set(f.v128_le,xe),n.builtins.set(f.v128_gt,me),n.builtins.set(f.v128_ge,_e),n.builtins.set(f.v128_narrow,ye),n.builtins.set(f.v128_neg,Ee),n.builtins.set(f.v128_abs,Te),n.builtins.set(f.v128_sqrt,be),n.builtins.set(f.v128_ceil,ve),n.builtins.set(f.v128_floor,Ae),n.builtins.set(f.v128_trunc,Fe),n.builtins.set(f.v128_nearest,Ce),n.builtins.set(f.v128_convert,Ie),n.builtins.set(f.v128_trunc_sat,Se),n.builtins.set(f.v128_widen_low,Ne),n.builtins.set(f.v128_widen_high,Oe),n.builtins.set(f.v128_shl,ke),n.builtins.set(f.v128_shr,Le),n.builtins.set(f.v128_and,(function(e){return Be(e,s.BinaryOp.AndV128)})),n.builtins.set(f.v128_or,(function(e){return Be(e,s.BinaryOp.OrV128)})),n.builtins.set(f.v128_xor,(function(e){return Be(e,s.BinaryOp.XorV128)})),n.builtins.set(f.v128_andnot,(function(e){return Be(e,s.BinaryOp.AndNotV128)})),n.builtins.set(f.v128_not,(function(e){return function(e,n){var t=e.compiler,r=t.module;if(He(e,16)|Ye(e)|je(e,1))return t.currentType=a.Type.v128,r.unreachable();var i=e.operands,s=t.compileExpression(i[0],a.Type.v128,1);return r.unary(n,s)}(e,s.UnaryOp.NotV128)})),n.builtins.set(f.v128_bitselect,(function(e){return function(e,n){var t=e.compiler,r=t.module;if(He(e,16)|Ye(e)|je(e,3))return t.currentType=a.Type.v128,r.unreachable();var i=e.operands,s=t.compileExpression(i[0],a.Type.v128,1),o=t.compileExpression(i[1],a.Type.v128,1),l=t.compileExpression(i[2],a.Type.v128,1);return r.simd_ternary(n,s,o,l)}(e,s.SIMDTernaryOp.Bitselect)})),n.builtins.set(f.v128_any_true,De),n.builtins.set(f.v128_all_true,Re),n.builtins.set(f.v128_bitmask,we),n.builtins.set(f.v128_qfma,ze),n.builtins.set(f.v128_qfms,Pe),n.builtins.set(f.visit_globals,(function(e){var n=e.compiler,t=n.module;if(Ye(e)|je(e,1))return n.currentType=a.Type.void,t.unreachable();var r=e.operands,i=n.compileExpression(r[0],a.Type.u32,1);return n.runtimeFeatures|=16,n.currentType=a.Type.void,t.call(f.visit_globals,[i],s.NativeType.None)})),n.builtins.set(f.visit_members,(function(e){var n=e.compiler,t=n.module;if(Ye(e)|je(e,2))return n.currentType=a.Type.void,t.unreachable();var r=e.operands,i=n.compileExpression(r[0],n.options.usizeType,1),o=n.compileExpression(r[1],a.Type.u32,1);return n.runtimeFeatures|=32,n.currentType=a.Type.void,t.call(f.visit_members,[i,o],s.NativeType.None)})),n.builtins.set(f.i32_clz,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,d(e)})),n.builtins.set(f.i64_clz,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,d(e)})),n.builtins.set(f.i32_ctz,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,h(e)})),n.builtins.set(f.i64_ctz,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,h(e)})),n.builtins.set(f.i32_popcnt,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,g(e)})),n.builtins.set(f.i64_popcnt,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,g(e)})),n.builtins.set(f.i32_rotl,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,x(e)})),n.builtins.set(f.i64_rotl,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,x(e)})),n.builtins.set(f.i32_rotr,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,m(e)})),n.builtins.set(f.i64_rotr,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,m(e)})),n.builtins.set(f.f32_abs,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,_(e)})),n.builtins.set(f.f64_abs,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,_(e)})),n.builtins.set(f.f32_max,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,y(e)})),n.builtins.set(f.f64_max,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,y(e)})),n.builtins.set(f.f32_min,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,E(e)})),n.builtins.set(f.f64_min,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,E(e)})),n.builtins.set(f.f32_ceil,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,T(e)})),n.builtins.set(f.f64_ceil,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,T(e)})),n.builtins.set(f.f32_floor,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,b(e)})),n.builtins.set(f.f64_floor,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,b(e)})),n.builtins.set(f.f32_copysign,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,v(e)})),n.builtins.set(f.f64_copysign,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,v(e)})),n.builtins.set(f.f32_nearest,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,A(e)})),n.builtins.set(f.f64_nearest,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,A(e)})),n.builtins.set(f.i32_reinterpret_f32,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.f32,F(e)})),n.builtins.set(f.i64_reinterpret_f64,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.f64,F(e)})),n.builtins.set(f.f32_reinterpret_i32,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.i32,F(e)})),n.builtins.set(f.f64_reinterpret_i64,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.i64,F(e)})),n.builtins.set(f.f32_sqrt,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,C(e)})),n.builtins.set(f.f64_sqrt,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,C(e)})),n.builtins.set(f.f32_trunc,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,I(e)})),n.builtins.set(f.f64_trunc,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,I(e)})),n.builtins.set(f.i32_add,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,O(e)})),n.builtins.set(f.i64_add,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,O(e)})),n.builtins.set(f.f32_add,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,O(e)})),n.builtins.set(f.f64_add,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,O(e)})),n.builtins.set(f.i32_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,k(e)})),n.builtins.set(f.i64_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,k(e)})),n.builtins.set(f.f32_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,k(e)})),n.builtins.set(f.f64_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,k(e)})),n.builtins.set(f.i32_mul,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,L(e)})),n.builtins.set(f.i64_mul,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,L(e)})),n.builtins.set(f.f32_mul,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,L(e)})),n.builtins.set(f.f64_mul,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,L(e)})),n.builtins.set(f.i32_div_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,B(e)})),n.builtins.set(f.i32_div_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.u32,B(e)})),n.builtins.set(f.i64_div_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,B(e)})),n.builtins.set(f.i64_div_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u64],e.contextualType=a.Type.u64,B(e)})),n.builtins.set(f.f32_div,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,B(e)})),n.builtins.set(f.f64_div,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,B(e)})),n.builtins.set(f.i32_load8_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i32,S(e)})),n.builtins.set(f.i32_load8_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,S(e)})),n.builtins.set(f.i32_load16_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.i32,S(e)})),n.builtins.set(f.i32_load16_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,S(e)})),n.builtins.set(f.i32_load,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,S(e)})),n.builtins.set(f.i64_load8_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i64,S(e)})),n.builtins.set(f.i64_load8_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i64,S(e)})),n.builtins.set(f.i64_load16_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.i64,S(e)})),n.builtins.set(f.i64_load16_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,S(e)})),n.builtins.set(f.i64_load32_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i64,S(e)})),n.builtins.set(f.i64_load32_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.i64,S(e)})),n.builtins.set(f.i64_load,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,S(e)})),n.builtins.set(f.f32_load,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,S(e)})),n.builtins.set(f.f64_load,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,S(e)})),n.builtins.set(f.i32_store8,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i32,e.contextIsExact=!0,N(e)})),n.builtins.set(f.i32_store16,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.i32,e.contextIsExact=!0,N(e)})),n.builtins.set(f.i32_store,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,e.contextIsExact=!0,N(e)})),n.builtins.set(f.i64_store8,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i64,e.contextIsExact=!0,N(e)})),n.builtins.set(f.i64_store16,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.i64,e.contextIsExact=!0,N(e)})),n.builtins.set(f.i64_store32,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i64,e.contextIsExact=!0,N(e)})),n.builtins.set(f.i64_store,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,e.contextIsExact=!0,N(e)})),n.builtins.set(f.f32_store,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,e.contextIsExact=!0,N(e)})),n.builtins.set(f.f64_store,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,e.contextIsExact=!0,N(e)})),n.builtins.set(f.i32_atomic_load8_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,D(e)})),n.builtins.set(f.i32_atomic_load16_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,D(e)})),n.builtins.set(f.i32_atomic_load,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,D(e)})),n.builtins.set(f.i64_atomic_load8_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i64,D(e)})),n.builtins.set(f.i64_atomic_load16_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,D(e)})),n.builtins.set(f.i64_atomic_load32_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.i64,D(e)})),n.builtins.set(f.i64_atomic_load,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,D(e)})),n.builtins.set(f.i32_atomic_store8,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i32,e.contextIsExact=!0,R(e)})),n.builtins.set(f.i32_atomic_store16,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.i32,e.contextIsExact=!0,R(e)})),n.builtins.set(f.i32_atomic_store,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,e.contextIsExact=!0,R(e)})),n.builtins.set(f.i64_atomic_store8,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i64,e.contextIsExact=!0,R(e)})),n.builtins.set(f.i64_atomic_store16,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,e.contextIsExact=!0,R(e)})),n.builtins.set(f.i64_atomic_store32,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i64,e.contextIsExact=!0,R(e)})),n.builtins.set(f.i64_atomic_store,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,e.contextIsExact=!0,R(e)})),n.builtins.set(f.i32_atomic_rmw8_add_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,e.contextIsExact=!0,z(e)})),n.builtins.set(f.i32_atomic_rmw16_add_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,e.contextIsExact=!0,z(e)})),n.builtins.set(f.i32_atomic_rmw_add,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,e.contextIsExact=!0,z(e)})),n.builtins.set(f.i64_atomic_rmw8_add_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i64,e.contextIsExact=!0,z(e)})),n.builtins.set(f.i64_atomic_rmw16_add_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,e.contextIsExact=!0,z(e)})),n.builtins.set(f.i64_atomic_rmw32_add_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.i64,e.contextIsExact=!0,z(e)})),n.builtins.set(f.i64_atomic_rmw_add,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,e.contextIsExact=!0,z(e)})),n.builtins.set(f.i32_atomic_rmw8_sub_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,e.contextIsExact=!0,P(e)})),n.builtins.set(f.i32_atomic_rmw16_sub_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,e.contextIsExact=!0,P(e)})),n.builtins.set(f.i32_atomic_rmw_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,e.contextIsExact=!0,P(e)})),n.builtins.set(f.i64_atomic_rmw8_sub_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i64,e.contextIsExact=!0,P(e)})),n.builtins.set(f.i64_atomic_rmw16_sub_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,e.contextIsExact=!0,P(e)})),n.builtins.set(f.i64_atomic_rmw32_sub_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.i64,e.contextIsExact=!0,P(e)})),n.builtins.set(f.i64_atomic_rmw_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,e.contextIsExact=!0,P(e)})),n.builtins.set(f.i32_atomic_rmw8_and_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,e.contextIsExact=!0,U(e)})),n.builtins.set(f.i32_atomic_rmw16_and_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,e.contextIsExact=!0,U(e)})),n.builtins.set(f.i32_atomic_rmw_and,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,e.contextIsExact=!0,U(e)})),n.builtins.set(f.i64_atomic_rmw8_and_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i64,e.contextIsExact=!0,U(e)})),n.builtins.set(f.i64_atomic_rmw16_and_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,e.contextIsExact=!0,U(e)})),n.builtins.set(f.i64_atomic_rmw32_and_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.i64,e.contextIsExact=!0,U(e)})),n.builtins.set(f.i64_atomic_rmw_and,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,e.contextIsExact=!0,U(e)})),n.builtins.set(f.i32_atomic_rmw8_or_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,e.contextIsExact=!0,M(e)})),n.builtins.set(f.i32_atomic_rmw16_or_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,e.contextIsExact=!0,M(e)})),n.builtins.set(f.i32_atomic_rmw_or,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,e.contextIsExact=!0,M(e)})),n.builtins.set(f.i64_atomic_rmw8_or_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i64,e.contextIsExact=!0,M(e)})),n.builtins.set(f.i64_atomic_rmw16_or_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,e.contextIsExact=!0,M(e)})),n.builtins.set(f.i64_atomic_rmw32_or_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.i64,e.contextIsExact=!0,M(e)})),n.builtins.set(f.i64_atomic_rmw_or,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,e.contextIsExact=!0,M(e)})),n.builtins.set(f.i32_atomic_rmw8_xor_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,e.contextIsExact=!0,G(e)})),n.builtins.set(f.i32_atomic_rmw16_xor_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,e.contextIsExact=!0,G(e)})),n.builtins.set(f.i32_atomic_rmw_xor,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,e.contextIsExact=!0,G(e)})),n.builtins.set(f.i64_atomic_rmw8_xor_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i64,e.contextIsExact=!0,G(e)})),n.builtins.set(f.i64_atomic_rmw16_xor_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,e.contextIsExact=!0,G(e)})),n.builtins.set(f.i64_atomic_rmw32_xor_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.i64,e.contextIsExact=!0,G(e)})),n.builtins.set(f.i64_atomic_rmw_xor,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,e.contextIsExact=!0,G(e)})),n.builtins.set(f.i32_atomic_rmw8_xchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,e.contextIsExact=!0,V(e)})),n.builtins.set(f.i32_atomic_rmw16_xchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,e.contextIsExact=!0,V(e)})),n.builtins.set(f.i32_atomic_rmw_xchg,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,e.contextIsExact=!0,V(e)})),n.builtins.set(f.i64_atomic_rmw8_xchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i64,e.contextIsExact=!0,V(e)})),n.builtins.set(f.i64_atomic_rmw16_xchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,e.contextIsExact=!0,V(e)})),n.builtins.set(f.i64_atomic_rmw32_xchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.i64,e.contextIsExact=!0,V(e)})),n.builtins.set(f.i64_atomic_rmw_xchg,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,e.contextIsExact=!0,V(e)})),n.builtins.set(f.i32_atomic_rmw8_cmpxchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,e.contextIsExact=!0,K(e)})),n.builtins.set(f.i32_atomic_rmw16_cmpxchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,e.contextIsExact=!0,K(e)})),n.builtins.set(f.i32_atomic_rmw_cmpxchg,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,e.contextIsExact=!0,K(e)})),n.builtins.set(f.i64_atomic_rmw8_cmpxchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i64,e.contextIsExact=!0,K(e)})),n.builtins.set(f.i64_atomic_rmw16_cmpxchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i64,e.contextIsExact=!0,K(e)})),n.builtins.set(f.i64_atomic_rmw32_cmpxchg_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.i64,e.contextIsExact=!0,K(e)})),n.builtins.set(f.i64_atomic_rmw_cmpxchg,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,e.contextIsExact=!0,K(e)})),n.builtins.set(f.i32_wait,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],H(e)})),n.builtins.set(f.i64_wait,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i32,H(e)})),n.builtins.set(f.v128_load,(function(e){return Ye(e),e.typeArguments=[a.Type.v128],e.contextualType=a.Type.v128,S(e)})),n.builtins.set(f.v128_store,(function(e){return Ye(e),e.typeArguments=[a.Type.v128],e.contextualType=a.Type.v128,e.contextIsExact=!0,N(e)})),n.builtins.set(f.i8x16_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,j(e)})),n.builtins.set(f.i8x16_extract_lane_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i32,q(e)})),n.builtins.set(f.i8x16_extract_lane_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.i32,q(e)})),n.builtins.set(f.i8x16_replace_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,Q(e)})),n.builtins.set(f.i8x16_add,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,ne(e)})),n.builtins.set(f.i8x16_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,te(e)})),n.builtins.set(f.i8x16_mul,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,re(e)})),n.builtins.set(f.i8x16_min_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,oe(e)})),n.builtins.set(f.i8x16_min_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,oe(e)})),n.builtins.set(f.i8x16_max_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,le(e)})),n.builtins.set(f.i8x16_max_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,le(e)})),n.builtins.set(f.i8x16_avgr_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,fe(e)})),n.builtins.set(f.i8x16_abs,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,Te(e)})),n.builtins.set(f.i8x16_neg,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,Ee(e)})),n.builtins.set(f.i8x16_add_saturate_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,ae(e)})),n.builtins.set(f.i8x16_add_saturate_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,ae(e)})),n.builtins.set(f.i8x16_sub_saturate_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,se(e)})),n.builtins.set(f.i8x16_sub_saturate_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,se(e)})),n.builtins.set(f.i8x16_shl,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,ke(e)})),n.builtins.set(f.i8x16_shr_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,Le(e)})),n.builtins.set(f.i8x16_shr_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,Le(e)})),n.builtins.set(f.i8x16_any_true,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i32,De(e)})),n.builtins.set(f.i8x16_all_true,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i32,Re(e)})),n.builtins.set(f.i8x16_bitmask,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.i32,we(e)})),n.builtins.set(f.i8x16_eq,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,de(e)})),n.builtins.set(f.i8x16_ne,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,he(e)})),n.builtins.set(f.i8x16_lt_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,ge(e)})),n.builtins.set(f.i8x16_lt_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,ge(e)})),n.builtins.set(f.i8x16_le_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,xe(e)})),n.builtins.set(f.i8x16_le_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,xe(e)})),n.builtins.set(f.i8x16_gt_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,me(e)})),n.builtins.set(f.i8x16_gt_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,me(e)})),n.builtins.set(f.i8x16_ge_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,_e(e)})),n.builtins.set(f.i8x16_ge_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,_e(e)})),n.builtins.set(f.i8x16_narrow_i16x8_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,ye(e)})),n.builtins.set(f.i8x16_narrow_i16x8_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,ye(e)})),n.builtins.set(f.i16x8_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,j(e)})),n.builtins.set(f.i16x8_extract_lane_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.i32,q(e)})),n.builtins.set(f.i16x8_extract_lane_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.i32,q(e)})),n.builtins.set(f.i16x8_replace_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,Q(e)})),n.builtins.set(f.i16x8_add,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,ne(e)})),n.builtins.set(f.i16x8_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,te(e)})),n.builtins.set(f.i16x8_mul,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,re(e)})),n.builtins.set(f.i16x8_min_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,oe(e)})),n.builtins.set(f.i16x8_min_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,oe(e)})),n.builtins.set(f.i16x8_max_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,le(e)})),n.builtins.set(f.i16x8_max_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,le(e)})),n.builtins.set(f.i16x8_avgr_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,fe(e)})),n.builtins.set(f.i16x8_abs,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,Te(e)})),n.builtins.set(f.i16x8_neg,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,Ee(e)})),n.builtins.set(f.i16x8_add_saturate_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,ae(e)})),n.builtins.set(f.i16x8_add_saturate_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,ae(e)})),n.builtins.set(f.i16x8_sub_saturate_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,se(e)})),n.builtins.set(f.i16x8_sub_saturate_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,se(e)})),n.builtins.set(f.i16x8_shl,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,ke(e)})),n.builtins.set(f.i16x8_shr_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,Le(e)})),n.builtins.set(f.i16x8_shr_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,Le(e)})),n.builtins.set(f.i16x8_any_true,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.i32,De(e)})),n.builtins.set(f.i16x8_all_true,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.i32,Re(e)})),n.builtins.set(f.i16x8_bitmask,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.i32,we(e)})),n.builtins.set(f.i16x8_eq,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,de(e)})),n.builtins.set(f.i16x8_ne,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,he(e)})),n.builtins.set(f.i16x8_lt_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,ge(e)})),n.builtins.set(f.i16x8_lt_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,ge(e)})),n.builtins.set(f.i16x8_le_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,xe(e)})),n.builtins.set(f.i16x8_le_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,xe(e)})),n.builtins.set(f.i16x8_gt_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,me(e)})),n.builtins.set(f.i16x8_gt_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,me(e)})),n.builtins.set(f.i16x8_ge_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,_e(e)})),n.builtins.set(f.i16x8_ge_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,_e(e)})),n.builtins.set(f.i16x8_narrow_i32x4_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,ye(e)})),n.builtins.set(f.i16x8_narrow_i32x4_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,ye(e)})),n.builtins.set(f.i16x8_widen_low_i8x16_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,Ne(e)})),n.builtins.set(f.i16x8_widen_low_i8x16_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,Ne(e)})),n.builtins.set(f.i16x8_widen_high_i8x16_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,Oe(e)})),n.builtins.set(f.i16x8_widen_high_i8x16_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,Oe(e)})),n.builtins.set(f.i16x8_load8x8_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,ee(e)})),n.builtins.set(f.i16x8_load8x8_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,ee(e)})),n.builtins.set(f.i32x4_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,j(e)})),n.builtins.set(f.i32x4_extract_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,q(e)})),n.builtins.set(f.i32x4_replace_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,Q(e)})),n.builtins.set(f.i32x4_add,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,ne(e)})),n.builtins.set(f.i32x4_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,te(e)})),n.builtins.set(f.i32x4_mul,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,re(e)})),n.builtins.set(f.i32x4_min_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,oe(e)})),n.builtins.set(f.i32x4_min_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,oe(e)})),n.builtins.set(f.i32x4_max_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,le(e)})),n.builtins.set(f.i32x4_max_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,le(e)})),n.builtins.set(f.i32x4_dot_i16x8_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,pe(e)})),n.builtins.set(f.i32x4_abs,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,Te(e)})),n.builtins.set(f.i32x4_neg,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,Ee(e)})),n.builtins.set(f.i32x4_shl,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,ke(e)})),n.builtins.set(f.i32x4_shr_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,Le(e)})),n.builtins.set(f.i32x4_shr_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,Le(e)})),n.builtins.set(f.i32x4_any_true,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,De(e)})),n.builtins.set(f.i32x4_all_true,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,Re(e)})),n.builtins.set(f.i32x4_bitmask,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.i32,we(e)})),n.builtins.set(f.i32x4_eq,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,de(e)})),n.builtins.set(f.i32x4_ne,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,he(e)})),n.builtins.set(f.i32x4_lt_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,ge(e)})),n.builtins.set(f.i32x4_lt_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,ge(e)})),n.builtins.set(f.i32x4_le_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,xe(e)})),n.builtins.set(f.i32x4_le_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,xe(e)})),n.builtins.set(f.i32x4_gt_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,me(e)})),n.builtins.set(f.i32x4_gt_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,me(e)})),n.builtins.set(f.i32x4_ge_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,_e(e)})),n.builtins.set(f.i32x4_ge_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,_e(e)})),n.builtins.set(f.i32x4_trunc_sat_f32x4_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,Se(e)})),n.builtins.set(f.i32x4_trunc_sat_f32x4_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,Se(e)})),n.builtins.set(f.i32x4_widen_low_i16x8_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,Ne(e)})),n.builtins.set(f.i32x4_widen_low_i16x8_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,Ne(e)})),n.builtins.set(f.i32x4_widen_high_i16x8_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,Oe(e)})),n.builtins.set(f.i32x4_widen_high_i16x8_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,Oe(e)})),n.builtins.set(f.i32x4_load16x4_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i16],e.contextualType=a.Type.v128,ee(e)})),n.builtins.set(f.i32x4_load16x4_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,ee(e)})),n.builtins.set(f.i64x2_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.v128,j(e)})),n.builtins.set(f.i64x2_extract_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i64,q(e)})),n.builtins.set(f.i64x2_replace_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.v128,Q(e)})),n.builtins.set(f.i64x2_add,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.v128,ne(e)})),n.builtins.set(f.i64x2_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.v128,te(e)})),n.builtins.set(f.i64x2_neg,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.v128,Ee(e)})),n.builtins.set(f.i64x2_shl,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.v128,ke(e)})),n.builtins.set(f.i64x2_shr_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.v128,Le(e)})),n.builtins.set(f.i64x2_shr_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u64],e.contextualType=a.Type.v128,Le(e)})),n.builtins.set(f.i64x2_any_true,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i32,De(e)})),n.builtins.set(f.i64x2_all_true,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.i32,Re(e)})),n.builtins.set(f.i64x2_trunc_sat_f64x2_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.v128,Se(e)})),n.builtins.set(f.i64x2_trunc_sat_f64x2_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u64],e.contextualType=a.Type.v128,Se(e)})),n.builtins.set(f.i64x2_load32x2_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,ee(e)})),n.builtins.set(f.i64x2_load32x2_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,ee(e)})),n.builtins.set(f.f32x4_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,j(e)})),n.builtins.set(f.f32x4_extract_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.f32,q(e)})),n.builtins.set(f.f32x4_replace_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,Q(e)})),n.builtins.set(f.f32x4_add,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,ne(e)})),n.builtins.set(f.f32x4_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,te(e)})),n.builtins.set(f.f32x4_mul,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,re(e)})),n.builtins.set(f.f32x4_div,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,ie(e)})),n.builtins.set(f.f32x4_neg,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,Ee(e)})),n.builtins.set(f.f32x4_min,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,oe(e)})),n.builtins.set(f.f32x4_max,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,le(e)})),n.builtins.set(f.f32x4_pmin,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,ue(e)})),n.builtins.set(f.f32x4_pmax,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,ce(e)})),n.builtins.set(f.f32x4_abs,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,Te(e)})),n.builtins.set(f.f32x4_sqrt,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,be(e)})),n.builtins.set(f.f32x4_ceil,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,ve(e)})),n.builtins.set(f.f32x4_floor,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,Ae(e)})),n.builtins.set(f.f32x4_trunc,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,Fe(e)})),n.builtins.set(f.f32x4_nearest,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,Ce(e)})),n.builtins.set(f.f32x4_eq,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,de(e)})),n.builtins.set(f.f32x4_ne,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,he(e)})),n.builtins.set(f.f32x4_lt,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,ge(e)})),n.builtins.set(f.f32x4_le,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,xe(e)})),n.builtins.set(f.f32x4_gt,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,me(e)})),n.builtins.set(f.f32x4_ge,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,_e(e)})),n.builtins.set(f.f32x4_convert_i32x4_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i32],e.contextualType=a.Type.v128,Ie(e)})),n.builtins.set(f.f32x4_convert_i32x4_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,Ie(e)})),n.builtins.set(f.f32x4_qfma,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,ze(e)})),n.builtins.set(f.f32x4_qfms,(function(e){return Ye(e),e.typeArguments=[a.Type.f32],e.contextualType=a.Type.v128,Pe(e)})),n.builtins.set(f.f64x2_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,j(e)})),n.builtins.set(f.f64x2_extract_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.f64,q(e)})),n.builtins.set(f.f64x2_replace_lane,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,Q(e)})),n.builtins.set(f.f64x2_add,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,ne(e)})),n.builtins.set(f.f64x2_sub,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,te(e)})),n.builtins.set(f.f64x2_mul,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,re(e)})),n.builtins.set(f.f64x2_div,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,ie(e)})),n.builtins.set(f.f64x2_neg,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,Ee(e)})),n.builtins.set(f.f64x2_min,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,oe(e)})),n.builtins.set(f.f64x2_max,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,le(e)})),n.builtins.set(f.f64x2_pmin,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,ue(e)})),n.builtins.set(f.f64x2_pmax,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,ce(e)})),n.builtins.set(f.f64x2_abs,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,Te(e)})),n.builtins.set(f.f64x2_sqrt,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,be(e)})),n.builtins.set(f.f64x2_ceil,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,ve(e)})),n.builtins.set(f.f64x2_floor,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,Ae(e)})),n.builtins.set(f.f64x2_trunc,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,Fe(e)})),n.builtins.set(f.f64x2_nearest,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,Ce(e)})),n.builtins.set(f.f64x2_eq,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,de(e)})),n.builtins.set(f.f64x2_ne,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,he(e)})),n.builtins.set(f.f64x2_lt,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,ge(e)})),n.builtins.set(f.f64x2_le,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,xe(e)})),n.builtins.set(f.f64x2_gt,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,me(e)})),n.builtins.set(f.f64x2_ge,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,_e(e)})),n.builtins.set(f.f64x2_convert_i64x2_s,(function(e){return Ye(e),e.typeArguments=[a.Type.i64],e.contextualType=a.Type.v128,Ie(e)})),n.builtins.set(f.f64x2_convert_i64x2_u,(function(e){return Ye(e),e.typeArguments=[a.Type.u64],e.contextualType=a.Type.v128,Ie(e)})),n.builtins.set(f.f64x2_qfma,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,ze(e)})),n.builtins.set(f.f64x2_qfms,(function(e){return Ye(e),e.typeArguments=[a.Type.f64],e.contextualType=a.Type.v128,Pe(e)})),n.builtins.set(f.v8x16_shuffle,(function(e){return Ye(e),e.typeArguments=[a.Type.i8],e.contextualType=a.Type.v128,Z(e)})),n.builtins.set(f.v8x16_swizzle,(function(e){return Ye(e),e.typeArguments=null,e.contextualType=a.Type.v128,J(e)})),n.builtins.set(f.v8x16_load_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.u8],e.contextualType=a.Type.v128,$(e)})),n.builtins.set(f.v16x8_load_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.u16],e.contextualType=a.Type.v128,$(e)})),n.builtins.set(f.v32x4_load_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.u32],e.contextualType=a.Type.v128,$(e)})),n.builtins.set(f.v64x2_load_splat,(function(e){return Ye(e),e.typeArguments=[a.Type.u64],e.contextualType=a.Type.v128,$(e)})),n.compileVisitGlobals=function(e){var n=e.module,t=new Array,r=e.options.nativeSizeType,i=assert(e.program.visitInstance);e.compileFunction(i,!0);for(let a=Map_values(e.program.elementsByName),l=0,u=a.length;l<u;++l){let u=unchecked(a[l]);if(u.kind!=o.ElementKind.GLOBAL)continue;let p=u,f=p.type.getClass();if(null!==f&&!f.hasDecorator(o.DecoratorFlags.UNMANAGED)&&p.is(c.CommonFlags.COMPILED))if(p.is(c.CommonFlags.INLINED)){let r=p.constantIntegerValue;(i64_low(r)||i64_high(r))&&t.push(n.call(i.internalName,[e.options.isWasm64?n.i64(i64_low(r),i64_high(r)):n.i32(i64_low(r)),n.local_get(0,s.NativeType.I32)],s.NativeType.None))}else t.push(n.if(n.local_tee(1,n.global_get(p.internalName,r),!1),n.call(i.internalName,[n.local_get(1,r),n.local_get(0,s.NativeType.I32)],s.NativeType.None)))}n.addFunction(f.visit_globals,s.NativeType.I32,s.NativeType.None,[r],t.length?n.block(null,t):n.nop())},n.compileVisitMembers=function(e){var n=e.program,t=e.module,r=n.options.usizeType.toNativeType(),i=n.managedClasses,a=assert(n.visitInstance);e.compileFunction(a,!0);var o=new Array,l=new Array,u=0;for(let n=Map_keys(i),a=0,c=n.length;a<c;++a){let c=n[a];assert(c==u++);let p=assert(i.get(c));o[a]=p.internalName,p.isPointerfree?l[a]=t.return():(l[a]=t.block(null,[t.call(p.internalName+"~visit",[t.local_get(0,r),t.local_get(1,s.NativeType.I32)],s.NativeType.None),t.return()],s.NativeType.None),Ue(e,p))}var c=t.block(o[0],[t.switch(o,"invalid",t.load(4,!1,r==s.NativeType.I64?t.binary(s.BinaryOp.SubI64,t.local_get(0,r),t.i64(8)):t.binary(s.BinaryOp.SubI32,t.local_get(0,r),t.i32(8)),s.NativeType.I32,0))],s.NativeType.None);for(let e=0,n=o.length-1;e<n;++e)c=t.block(o[e+1],[c,l[e]],s.NativeType.None);c=t.block("invalid",[c,l[o.length-1]],s.NativeType.None),t.addFunction(f.visit_members,s.createType([r,s.NativeType.I32]),s.NativeType.None,null,t.flatten([c,t.unreachable()]))},n.compileRTTI=function(e){var n=e.program,t=e.module,r=n.managedClasses,i=r.size,a=4+8*i,o=new Uint8Array(a);p.writeI32(i,o,0);var l=4,u=n.arrayBufferViewInstance,c=u.prototype,d=n.arrayPrototype,h=n.setPrototype,g=n.mapPrototype,x=n.staticArrayPrototype,m=0;for(let e=Map_keys(r),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]),i=assert(r.get(t));assert(t==m++);let a=0;if(i.isPointerfree&&(a|=32),i!==u&&i.extends(c)){let e=i.getArrayValueType();a|=1,a|=64*Me(e)}else if(i.extends(d)){let e=i.getArrayValueType();a|=2,a|=64*Me(e)}else if(i.extends(h)){let e=assert(i.getTypeArgumentsTo(h));assert(1==e.length),a|=8,a|=64*Me(e[0])}else if(i.extends(g)){let e=assert(i.getTypeArgumentsTo(g));assert(2==e.length),a|=16,a|=32768*Me(e[0]),a|=64*Me(e[1])}else if(i.extends(x)){let e=i.getArrayValueType();a|=4,a|=64*Me(e)}p.writeI32(a,o,l),l+=4,i.rttiFlags=a;let s=i.base;p.writeI32(s?s.id:0,o,l),l+=4}assert(l==a);var _=n.options.usizeType,y=e.addAlignedMemorySegment(o);if(8==_.size){let e=y.offset;t.addGlobal(f.rtti_base,s.NativeType.I64,!1,t.i64(i64_low(e),i64_high(e)))}else t.addGlobal(f.rtti_base,s.NativeType.I32,!1,t.i32(i64_low(y.offset)))},n.compileClassInstanceOf=function(e,n){var t=e.module,r=e.options.nativeSizeType,i=assert(n.program.instanceofInstance);e.compileFunction(i);var a=new Array;a.push(t.if(t.unary(r==s.NativeType.I64?s.UnaryOp.EqzI64:s.UnaryOp.EqzI32,t.local_get(0,r)),t.return(t.i32(0))));var o=n.instances;if(null!==o&&o.size>0)for(let e=Map_values(o),n=0,l=e.length;n<l;++n){let o=unchecked(e[n]);a.push(t.if(t.call(i.internalName,[t.local_get(0,r),t.i32(o.id)],s.NativeType.I32),t.return(t.i32(1))))}a.push(t.return(t.i32(0))),t.addFunction(n.internalName+"~instanceof",r,s.NativeType.I32,null,t.flatten(a))}},200:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.TypeinfoFlags=n.Typeinfo=n.Target=n.featureToString=n.Feature=n.CommonNames=n.STUB_DELIMITER=n.INDEX_SUFFIX=n.LIBRARY_PREFIX=n.LIBRARY_SUBST=n.INNER_DELIMITER=n.STATIC_DELIMITER=n.INSTANCE_DELIMITER=n.SETTER_PREFIX=n.GETTER_PREFIX=n.PARENT_SUBST=n.PATH_DELIMITER=n.CommonFlags=void 0,function(e){e[e.NONE=0]="NONE",e[e.IMPORT=1]="IMPORT",e[e.EXPORT=2]="EXPORT",e[e.DECLARE=4]="DECLARE",e[e.CONST=8]="CONST",e[e.LET=16]="LET",e[e.STATIC=32]="STATIC",e[e.READONLY=64]="READONLY",e[e.ABSTRACT=128]="ABSTRACT",e[e.PUBLIC=256]="PUBLIC",e[e.PRIVATE=512]="PRIVATE",e[e.PROTECTED=1024]="PROTECTED",e[e.GET=2048]="GET",e[e.SET=4096]="SET",e[e.DEFINITELY_ASSIGNED=8192]="DEFINITELY_ASSIGNED",e[e.AMBIENT=16384]="AMBIENT",e[e.GENERIC=32768]="GENERIC",e[e.GENERIC_CONTEXT=65536]="GENERIC_CONTEXT",e[e.INSTANCE=131072]="INSTANCE",e[e.CONSTRUCTOR=262144]="CONSTRUCTOR",e[e.MODULE_EXPORT=524288]="MODULE_EXPORT",e[e.MODULE_IMPORT=1048576]="MODULE_IMPORT",e[e.RESOLVED=2097152]="RESOLVED",e[e.COMPILED=4194304]="COMPILED",e[e.ERRORED=8388608]="ERRORED",e[e.INLINED=16777216]="INLINED",e[e.SCOPED=33554432]="SCOPED",e[e.STUB=67108864]="STUB",e[e.VIRTUAL=134217728]="VIRTUAL",e[e.CLOSURE=268435456]="CLOSURE",e[e.QUOTED=536870912]="QUOTED"}(n.CommonFlags||(n.CommonFlags={})),n.PATH_DELIMITER="/",n.PARENT_SUBST="..",n.GETTER_PREFIX="get:",n.SETTER_PREFIX="set:",n.INSTANCE_DELIMITER="#",n.STATIC_DELIMITER=".",n.INNER_DELIMITER="~",n.LIBRARY_SUBST="~lib",n.LIBRARY_PREFIX=n.LIBRARY_SUBST+n.PATH_DELIMITER,n.INDEX_SUFFIX=n.PATH_DELIMITER+"index",n.STUB_DELIMITER="@",function(e){e.EMPTY="",e.i8="i8",e.i16="i16",e.i32="i32",e.i64="i64",e.isize="isize",e.u8="u8",e.u16="u16",e.u32="u32",e.u64="u64",e.usize="usize",e.bool="bool",e.f32="f32",e.f64="f64",e.v128="v128",e.funcref="funcref",e.externref="externref",e.exnref="exnref",e.anyref="anyref",e.i8x16="i8x16",e.u8x16="u8x16",e.i16x8="i16x8",e.u16x8="u16x8",e.i32x4="i32x4",e.u32x4="u32x4",e.i64x2="i64x2",e.u64x2="u64x2",e.f32x4="f32x4",e.f64x2="f64x2",e.void_="void",e.number="number",e.boolean="boolean",e.string="string",e.native="native",e.indexof="indexof",e.valueof="valueof",e.returnof="returnof",e.null_="null",e.true_="true",e.false_="false",e.this_="this",e.super_="super",e.constructor="constructor",e.ASC_TARGET="ASC_TARGET",e.ASC_NO_TREESHAKING="ASC_NO_TREESHAKING",e.ASC_NO_ASSERT="ASC_NO_ASSERT",e.ASC_MEMORY_BASE="ASC_MEMORY_BASE",e.ASC_TABLE_BASE="ASC_TABLE_BASE",e.ASC_OPTIMIZE_LEVEL="ASC_OPTIMIZE_LEVEL",e.ASC_SHRINK_LEVEL="ASC_SHRINK_LEVEL",e.ASC_LOW_MEMORY_LIMIT="ASC_LOW_MEMORY_LIMIT",e.ASC_EXPORT_RUNTIME="ASC_EXPORT_RUNTIME",e.ASC_WASI="ASC_WASI",e.ASC_FEATURE_SIGN_EXTENSION="ASC_FEATURE_SIGN_EXTENSION",e.ASC_FEATURE_MUTABLE_GLOBALS="ASC_FEATURE_MUTABLE_GLOBALS",e.ASC_FEATURE_NONTRAPPING_F2I="ASC_FEATURE_NONTRAPPING_F2I",e.ASC_FEATURE_BULK_MEMORY="ASC_FEATURE_BULK_MEMORY",e.ASC_FEATURE_SIMD="ASC_FEATURE_SIMD",e.ASC_FEATURE_THREADS="ASC_FEATURE_THREADS",e.ASC_FEATURE_EXCEPTION_HANDLING="ASC_FEATURE_EXCEPTION_HANDLING",e.ASC_FEATURE_TAIL_CALLS="ASC_FEATURE_TAIL_CALLS",e.ASC_FEATURE_REFERENCE_TYPES="ASC_FEATURE_REFERENCE_TYPES",e.ASC_FEATURE_MULTI_VALUE="ASC_FEATURE_MULTI_VALUE",e.ASC_FEATURE_GC="ASC_FEATURE_GC",e.ASC_FEATURE_MEMORY64="ASC_FEATURE_MEMORY64",e.I8="I8",e.I16="I16",e.I32="I32",e.I64="I64",e.Isize="Isize",e.U8="U8",e.U16="U16",e.U32="U32",e.U64="U64",e.Usize="Usize",e.Bool="Bool",e.F32="F32",e.F64="F64",e.V128="V128",e.Funcref="Funcref",e.Externref="Externref",e.Exnref="Exnref",e.Anyref="Anyref",e.String="String",e.Array="Array",e.StaticArray="StaticArray",e.Set="Set",e.Map="Map",e.Function="Function",e.ArrayBufferView="ArrayBufferView",e.ArrayBuffer="ArrayBuffer",e.Math="Math",e.Mathf="Mathf",e.NativeMath="NativeMath",e.NativeMathf="NativeMathf",e.Int8Array="Int8Array",e.Int16Array="Int16Array",e.Int32Array="Int32Array",e.Int64Array="Int64Array",e.Uint8Array="Uint8Array",e.Uint8ClampedArray="Uint8ClampedArray",e.Uint16Array="Uint16Array",e.Uint32Array="Uint32Array",e.Uint64Array="Uint64Array",e.Float32Array="Float32Array",e.Float64Array="Float64Array",e.Error="Error",e.abort="abort",e.trace="trace",e.seed="seed",e.pow="pow",e.ipow32="ipow32",e.ipow64="ipow64",e.mod="mod",e.alloc="__alloc",e.realloc="__realloc",e.free="__free",e.new_="__new",e.renew="__renew",e.link="__link",e.collect="__collect",e.typeinfo="__typeinfo",e.instanceof_="__instanceof",e.visit="__visit",e.newBuffer="__newBuffer",e.newArray="__newArray",e.BLOCK="~lib/rt/common/BLOCK",e.OBJECT="~lib/rt/common/OBJECT"}(n.CommonNames||(n.CommonNames={}));var r=t(466);Object.defineProperty(n,"Feature",{enumerable:!0,get:function(){return r.Feature}}),Object.defineProperty(n,"featureToString",{enumerable:!0,get:function(){return r.featureToString}});var i=t(607);Object.defineProperty(n,"Target",{enumerable:!0,get:function(){return i.Target}});var a=t(604);Object.defineProperty(n,"Typeinfo",{enumerable:!0,get:function(){return a.Typeinfo}}),Object.defineProperty(n,"TypeinfoFlags",{enumerable:!0,get:function(){return a.TypeinfoFlags}})},220:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Compiler=n.ExportNames=n.RuntimeFeatures=n.Constraints=n.Options=void 0;const r=t(346),i=t(256),a=t(656),s=t(200),o=t(974),l=t(154),u=t(742),c=t(411),p=t(60),f=t(699),d=t(910),h=t(865),g=t(231);var x;n.Options=class{constructor(){this.target=s.Target.WASM32,this.noAssert=!1,this.exportMemory=!0,this.importMemory=!1,this.initialMemory=0,this.maximumMemory=0,this.sharedMemory=!1,this.importTable=!1,this.exportTable=!1,this.sourceMap=!1,this.explicitStart=!1,this.memoryBase=0,this.tableBase=0,this.globalAliases=null,this.features=2,this.noUnsafe=!1,this.pedantic=!1,this.lowMemoryLimit=0,this.exportRuntime=!1,this.stackSize=0,this.optimizeLevelHint=0,this.shrinkLevelHint=0}get isWasm64(){return this.target==s.Target.WASM64}get usizeType(){return this.target==s.Target.WASM64?f.Type.usize64:f.Type.usize32}get isizeType(){return this.target==s.Target.WASM64?f.Type.isize64:f.Type.isize32}get nativeSizeType(){return this.target==s.Target.WASM64?a.NativeType.I64:a.NativeType.I32}get willOptimize(){return this.optimizeLevelHint>0||this.shrinkLevelHint>0}hasFeature(e){return 0!=(this.features&e)}},function(e){e[e.NONE=0]="NONE",e[e.CONV_IMPLICIT=1]="CONV_IMPLICIT",e[e.CONV_EXPLICIT=2]="CONV_EXPLICIT",e[e.MUST_WRAP=4]="MUST_WRAP",e[e.WILL_DROP=8]="WILL_DROP",e[e.PREFER_STATIC=16]="PREFER_STATIC",e[e.IS_THIS=32]="IS_THIS"}(n.Constraints||(n.Constraints={})),function(e){e[e.NONE=0]="NONE",e[e.DATA=1]="DATA",e[e.STACK=2]="STACK",e[e.HEAP=4]="HEAP",e[e.RTTI=8]="RTTI",e[e.visitGlobals=16]="visitGlobals",e[e.visitMembers=32]="visitMembers",e[e.setArgumentsLength=64]="setArgumentsLength"}(n.RuntimeFeatures||(n.RuntimeFeatures={})),function(e){e.start="_start",e.argumentsLength="__argumentsLength",e.setArgumentsLength="__setArgumentsLength",e.memory="memory",e.table="table"}(x=n.ExportNames||(n.ExportNames={}));const m=["__new","__pin","__unpin","__collect"],_=["__rtti_base"];class y extends i.DiagnosticEmitter{constructor(e){super(e.diagnostics),this.currentParent=null,this.currentType=f.Type.void,this.memorySegments=[],this.stringSegments=new Map,this.functionTable=[],this.builtinArgumentsLength=0,this.runtimeFeatures=0,this.inlineStack=[],this.lazyFunctions=new Set,this.pendingClassInstanceOf=new Set,this.virtualCalls=new Set,this.pendingElements=new Set,this.doneModuleExports=new Set,this.f32ModInstance=null,this.f64ModInstance=null,this.f32PowInstance=null,this.f64PowInstance=null,this.i32PowInstance=null,this.i64PowInstance=null,this.program=e;var n=e.options,t=a.Module.create(n.stackSize>0);this.module=t,n.memoryBase?(this.memoryOffset=i64_new(n.memoryBase),t.setLowMemoryUnused(!1)):!n.lowMemoryLimit&&n.optimizeLevelHint>=2?(this.memoryOffset=i64_new(1024),t.setLowMemoryUnused(!0)):(this.memoryOffset=i64_new(8),t.setLowMemoryUnused(!1));var i=0;n.hasFeature(1)&&(i|=a.FeatureFlags.SignExt),n.hasFeature(2)&&(i|=a.FeatureFlags.MutableGloabls),n.hasFeature(4)&&(i|=a.FeatureFlags.NontrappingFPToInt),n.hasFeature(8)&&(i|=a.FeatureFlags.BulkMemory),n.hasFeature(16)&&(i|=a.FeatureFlags.SIMD128),n.hasFeature(32)&&(i|=a.FeatureFlags.Atomics),n.hasFeature(64)&&(i|=a.FeatureFlags.ExceptionHandling),n.hasFeature(128)&&(i|=a.FeatureFlags.TailCall),n.hasFeature(256)&&(i|=a.FeatureFlags.ReferenceTypes),n.hasFeature(512)&&(i|=a.FeatureFlags.MultiValue),n.hasFeature(1024)&&(i|=a.FeatureFlags.GC),n.hasFeature(2048)&&(i|=a.FeatureFlags.Memory64),t.setFeatures(i);var s=e.makeNativeFunction(r.BuiltinNames.start,new f.Signature(e,[],f.Type.void));s.internalName=r.BuiltinNames.start,this.currentFlow=s.flow,this.currentBody=new Array,this.shadowStack=new g.ShadowStackPass(this)}get resolver(){return this.program.resolver}get options(){return this.program.options}static compile(e){return new y(e).compile()}compile(){var e=this.options,n=this.module,t=this.program,o=e.stackSize>0;this.program.initialize();var l=this.currentFlow.actualFunction;assert(l.internalName==r.BuiltinNames.start);var u=this.currentBody;assert(0==u.length),e.isWasm64?(n.addGlobal(r.BuiltinNames.data_end,a.NativeType.I64,!0,n.i64(0)),n.addGlobal(r.BuiltinNames.heap_base,a.NativeType.I64,!0,n.i64(0)),n.addGlobal(r.BuiltinNames.rtti_base,a.NativeType.I64,!0,n.i64(0))):(n.addGlobal(r.BuiltinNames.data_end,a.NativeType.I32,!0,n.i32(0)),n.addGlobal(r.BuiltinNames.heap_base,a.NativeType.I32,!0,n.i32(0)),n.addGlobal(r.BuiltinNames.rtti_base,a.NativeType.I32,!0,n.i32(0)));var c=t.filesByName;for(let e=Map_values(c),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);t.source.sourceKind==p.SourceKind.USER_ENTRY&&(this.compileFile(t),this.compileExports(t))}for(let e=Map_values(this.program.filesByName),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);t.source.sourceKind==p.SourceKind.USER_ENTRY&&this.ensureModuleExports(t)}if(this.options.exportRuntime){for(let e=0,r=m.length;e<r;++e){let r=m[e],i=t.requireFunction(r);this.compileFunction(i)&&!n.hasExport(r)&&n.addFunctionExport(i.internalName,r)}for(let e=0,r=_.length;e<r;++e){let r=_[e],i=t.requireGlobal(r);this.compileGlobal(i)&&!n.hasExport(r)&&n.addGlobalExport(i.internalName,r)}}var d=this.lazyFunctions;do{let e=new Array;for(let n=Set_values(d),t=0,r=n.length;t<r;++t){let r=unchecked(n[t]);e.push(r)}d.clear();for(let n=0,t=e.length;n<t;++n)this.compileFunction(unchecked(e[n]),!0)}while(d.size);for(let e=Set_values(this.pendingClassInstanceOf),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);r.compileClassInstanceOf(this,t)}var g=this.functionTable;for(let e=0,n=g.length;e<n;++e){let n=g[e];n.is(s.CommonFlags.VIRTUAL)?(assert(n.is(s.CommonFlags.INSTANCE)),g[e]=this.ensureVirtualStub(n),this.finalizeVirtualStub(n)):n.signature.requiredParameters<n.signature.parameterTypes.length&&(g[e]=this.ensureVarargsStub(n))}for(var y=this.virtualCalls;y.size;)for(let e=Set_values(y),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);this.finalizeVirtualStub(t),y.delete(t)}n.removeGlobal(r.BuiltinNames.rtti_base),8&this.runtimeFeatures&&r.compileRTTI(this),16&this.runtimeFeatures&&r.compileVisitGlobals(this),32&this.runtimeFeatures&&r.compileVisitMembers(this);var E=i64_align(this.memoryOffset,e.usizeType.byteSize);n.removeGlobal(r.BuiltinNames.data_end),(0!=(1&this.runtimeFeatures)||o)&&(e.isWasm64?n.addGlobal(r.BuiltinNames.data_end,a.NativeType.I64,!1,n.i64(i64_low(E),i64_high(E))):n.addGlobal(r.BuiltinNames.data_end,a.NativeType.I32,!1,n.i32(i64_low(E)))),n.removeGlobal(r.BuiltinNames.stack_pointer),(0!=(2&this.runtimeFeatures)||o)&&(E=i64_align(i64_add(E,i64_new(e.stackSize)),e.usizeType.byteSize),e.isWasm64?n.addGlobal(r.BuiltinNames.stack_pointer,a.NativeType.I64,!0,n.i64(i64_low(E),i64_high(E))):n.addGlobal(r.BuiltinNames.stack_pointer,a.NativeType.I32,!0,n.i32(i64_low(E)))),n.removeGlobal(r.BuiltinNames.heap_base),(0!=(4&this.runtimeFeatures)||o)&&(e.isWasm64?n.addGlobal(r.BuiltinNames.heap_base,a.NativeType.I64,!1,n.i64(i64_low(E),i64_high(E))):n.addGlobal(r.BuiltinNames.heap_base,a.NativeType.I32,!1,n.i32(i64_low(E)))),this.memoryOffset=E;var T=this.options.lowMemoryLimit;if(T){let e=i64_new(-16&T);i64_gt(E,e)&&this.error(i.DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,null,i64_to_string(E),i64_to_string(e))}var b=0;(this.options.memoryBase||this.memorySegments.length)&&(b=u32(i64_low(i64_shr_u(i64_align(E,65536),i64_new(16))))),e.initialMemory&&(e.initialMemory<b?this.error(i.DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,null,b.toString()):b=e.initialMemory);var v=a.Module.UNLIMITED_MEMORY;e.maximumMemory&&(e.maximumMemory<b?this.error(i.DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,null,b.toString()):v=e.maximumMemory);var A=!1;e.sharedMemory&&(A=!0,e.maximumMemory||(this.error(i.DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,null),A=!1),e.hasFeature(32)||(this.error(i.DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,null),A=!1)),n.setMemory(b,v,this.memorySegments,e.target,e.exportMemory?x.memory:null,A),e.importMemory&&n.addMemoryImport("0","env","memory",A);var F=this.options.tableBase;F||(F=1);var C=new Array(g.length);for(let e=0,n=g.length;e<n;++e)C[e]=g[e].internalName;n.setFunctionTable(F+g.length,a.Module.UNLIMITED_TABLE,C,n.i32(F)),e.importTable&&(n.addTableImport("0","env","table"),e.pedantic&&e.willOptimize&&this.pedantic(i.DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,null)),e.exportTable&&(n.addTableExport("0",x.table),e.pedantic&&e.willOptimize&&this.pedantic(i.DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,null)),64&this.runtimeFeatures&&(n.addFunction(r.BuiltinNames.setArgumentsLength,a.NativeType.I32,a.NativeType.None,null,n.global_set(this.ensureArgumentsLength(),n.local_get(0,a.NativeType.I32))),n.addFunctionExport(r.BuiltinNames.setArgumentsLength,x.setArgumentsLength));var I=!u.length,S=t.isWasi||e.explicitStart;if(!I||S){let e=l.signature;!I&&S&&(n.addGlobal(r.BuiltinNames.started,a.NativeType.I32,!0,n.i32(0)),u.unshift(n.global_set(r.BuiltinNames.started,n.i32(1))),u.unshift(n.if(n.global_get(r.BuiltinNames.started,a.NativeType.I32),n.return())));let t=n.addFunction(l.internalName,e.nativeParams,e.nativeResults,f.typesToNativeTypes(l.additionalLocals),n.flatten(u));l.finalize(n,t),S?n.addFunctionExport(l.internalName,x.start):n.setStart(t)}return o&&this.shadowStack.walkModule(),null!=t.lookup("ASC_RTRACE")&&new h.RtraceMemory(this).walkModule(),n}ensureModuleExports(e){var n=e.exports;if(n)for(let e=Map_keys(n),t=0,r=e.length;t<r;++t){let r=unchecked(e[t]),i=assert(n.get(r));this.ensureModuleExport(r,i)}var t=e.exportsStar;if(t)for(let e=0,n=t.length;e<n;++e)this.ensureModuleExports(t[e])}ensureModuleExport(e,n,t=""){var r=this.module;switch(n.kind){case o.ElementKind.FUNCTION_PROTOTYPE:{let r=n,a=r.instances;if(null!==a&&a.size>0)for(let n=Map_values(a),r=0,i=n.length;r<i;++r){let i=unchecked(n[r]),a=e;if(i.is(s.CommonFlags.GENERIC)){let e=i.internalName;a+=e.substring(e.lastIndexOf("<"))}this.ensureModuleExport(a,i,t)}else r.is(s.CommonFlags.GENERIC)&&this.warning(i.DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,r.identifierNode.range);break}case o.ElementKind.CLASS_PROTOTYPE:{let r=n,a=r.instances;if(null!==a&&a.size>0)for(let n=Map_values(a),r=0,i=n.length;r<i;++r){let i=unchecked(n[r]),a=e;if(i.is(s.CommonFlags.GENERIC)){let e=i.internalName;a+=e.substring(e.lastIndexOf("<"))}this.ensureModuleExport(a,i,t)}else r.is(s.CommonFlags.GENERIC)&&this.warning(i.DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,r.identifierNode.range);break}case o.ElementKind.PROPERTY_PROTOTYPE:{let r=n.instance;r&&this.ensureModuleExport(e,r,t);break}case o.ElementKind.GLOBAL:{let a=n;if(a.is(s.CommonFlags.CONST)||a.is(s.CommonFlags.STATIC|s.CommonFlags.READONLY)||this.options.hasFeature(2)){if(a.is(s.CommonFlags.COMPILED)){let i=t+e;r.hasExport(i)||r.addGlobalExport(n.internalName,i)}}else this.error(i.DiagnosticCode.Cannot_export_a_mutable_global,a.identifierNode.range);break}case o.ElementKind.ENUMVALUE:{let a=n;if(a.isImmutable||this.options.hasFeature(2)){if(a.is(s.CommonFlags.COMPILED)){let i=t+e;r.hasExport(i)||r.addGlobalExport(n.internalName,i)}}else this.error(i.DiagnosticCode.Cannot_export_a_mutable_global,a.identifierNode.range);break}case o.ElementKind.FUNCTION:{let i=n;if(!i.hasDecorator(o.DecoratorFlags.BUILTIN)){let n=i.signature;if(n.requiredParameters<n.parameterTypes.length&&(i=this.ensureVarargsStub(i),this.runtimeFeatures|=64),i.is(s.CommonFlags.COMPILED)){let a=t+e;r.hasExport(a)||(r.addFunctionExport(i.internalName,a),n.hasManagedOperands&&this.shadowStack.noteExport(a,n.getManagedOperandIndices()))}}break}case o.ElementKind.PROPERTY:{let r=n,i=r.getterInstance;i&&this.ensureModuleExport(s.GETTER_PREFIX+e,i,t);let a=r.setterInstance;a&&this.ensureModuleExport(s.SETTER_PREFIX+e,a,t);break}case o.ElementKind.FIELD:{let i=n;if(n.is(s.CommonFlags.COMPILED)){let a=t+s.GETTER_PREFIX+e;if(this.compileFieldGetter(i)&&!r.hasExport(a)){r.addFunctionExport(i.internalGetterName,a);let e=i.internalGetterSignature;e.hasManagedOperands&&this.shadowStack.noteExport(a,e.getManagedOperandIndices())}if(!n.is(s.CommonFlags.READONLY)){let n=t+s.SETTER_PREFIX+e;if(this.compileFieldSetter(i)&&!r.hasExport(n)){r.addFunctionExport(i.internalSetterName,n);let e=i.internalSetterSignature;e.hasManagedOperands&&this.shadowStack.noteExport(n,e.getManagedOperandIndices())}}}break}case o.ElementKind.CLASS:{let r=n;if(!r.type.isUnmanaged){let i=this.module,s=r.internalName;this.doneModuleExports.has(n)||(i.addGlobal(s,a.NativeType.I32,!1,i.i32(r.id)),this.doneModuleExports.add(n)),i.addGlobalExport(s,t+e)}break}case o.ElementKind.ENUM:case o.ElementKind.INTERFACE_PROTOTYPE:case o.ElementKind.NAMESPACE:case o.ElementKind.TYPEDEFINITION:case o.ElementKind.INDEXSIGNATURE:break;default:assert(!1)}var l=n.members;if(l){let r=t+e+(n.kind==o.ElementKind.CLASS?s.INSTANCE_DELIMITER:s.STATIC_DELIMITER);if(n.kind==o.ElementKind.NAMESPACE){let e=n.is(s.CommonFlags.SCOPED);for(let n=Map_keys(l),t=0,i=n.length;t<i;++t){let i=unchecked(n[t]),a=assert(l.get(i));(e||a.is(s.CommonFlags.EXPORT))&&this.ensureModuleExport(i,a,r)}}else for(let e=Map_keys(l),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]),i=assert(l.get(t));i.is(s.CommonFlags.PRIVATE)||this.ensureModuleExport(t,i,r)}}}compileElement(e,n=!0){switch(e.kind){case o.ElementKind.GLOBAL:this.compileGlobal(e);break;case o.ElementKind.ENUM:this.compileEnum(e);break;case o.ElementKind.FUNCTION_PROTOTYPE:if(!e.is(s.CommonFlags.GENERIC)){let n=this.resolver.resolveFunction(e,null);n&&this.compileFunction(n)}break;case o.ElementKind.CLASS_PROTOTYPE:if(!e.is(s.CommonFlags.GENERIC)){let n=this.resolver.resolveClass(e,null);n&&this.compileClass(n)}break;case o.ElementKind.PROPERTY_PROTOTYPE:{let n=this.resolver.resolveProperty(e);n&&this.compileProperty(n);break}case o.ElementKind.INTERFACE_PROTOTYPE:case o.ElementKind.NAMESPACE:case o.ElementKind.TYPEDEFINITION:case o.ElementKind.ENUMVALUE:case o.ElementKind.INDEXSIGNATURE:break;default:assert(!1)}if(n){let n=e.members;if(n)for(let e=Map_values(n),t=0,r=e.length;t<r;++t){let n=unchecked(e[t]);this.compileElement(n)}}}compileExports(e){var n=e.exports;if(n)for(let e=Map_values(n),t=0,r=e.length;t<r;++t){let n=unchecked(e[t]);n.hasDecorator(o.DecoratorFlags.LAZY)||this.compileElement(n)}var t=e.exportsStar;if(t)for(let e=0,n=t.length;e<n;++e){let n=unchecked(t[e]);this.compileFile(n),this.compileExports(n)}}compileFileByPath(e,n){var t,r,a=this.program.filesByName;if(a.has(e))t=assert(a.get(e));else{if(!a.has(r=e+s.INDEX_SUFFIX))return void this.error(i.DiagnosticCode.File_0_not_found,n.range,e);t=assert(a.get(r))}this.compileFile(t)}compileFile(e){if(!e.is(s.CommonFlags.COMPILED)){e.set(s.CommonFlags.COMPILED);var n=e.startFunction,t=n.signature,r=this.currentBody,i=new Array;this.currentBody=i;var o=this.currentFlow,l=n.flow;this.currentFlow=l;for(let n=e.source.statements,t=0,r=n.length;t<r;++t)this.compileTopLevelStatement(n[t],i);if(this.currentFlow=o,this.currentBody=r,i.length){let e=this.module,s=n.localsByIndex,o=s.length,l=new Array(o);for(let e=0;e<o;++e)l[e]=s[e].type.toNativeType();e.addFunction(n.internalName,t.nativeParams,t.nativeResults,l,e.flatten(i)),r.push(e.call(n.internalName,null,a.NativeType.None))}}}compileGlobal(e){if(e.is(s.CommonFlags.COMPILED))return!e.is(s.CommonFlags.ERRORED);e.set(s.CommonFlags.COMPILED);var n=this.pendingElements;n.add(e);var t=this.module,l=0,u=e.typeNode,c=e.initializerNode;if(!e.is(s.CommonFlags.RESOLVED))if(u){let t=this.resolver.resolveType(u,e.parent);if(!t)return e.set(s.CommonFlags.ERRORED),n.delete(e),!1;if(t==f.Type.void)return this.error(i.DiagnosticCode.Type_expected,u.range),e.set(s.CommonFlags.ERRORED),n.delete(e),!1;e.setType(t),this.checkTypeSupported(e.type,u)}else{if(!c)return this.error(i.DiagnosticCode.Type_expected,e.identifierNode.range.atEnd),e.set(s.CommonFlags.ERRORED),n.delete(e),!1;{let t=this.currentFlow;if(e.hasDecorator(o.DecoratorFlags.LAZY)&&(this.currentFlow=e.file.startFunction.flow),l=this.compileExpression(c,f.Type.auto,20),this.currentFlow=t,this.currentType==f.Type.void)return this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,c.range,this.currentType.toString(),"<auto>"),e.set(s.CommonFlags.ERRORED),n.delete(e),!1;e.setType(this.currentType)}}if(e.is(s.CommonFlags.AMBIENT)&&e.hasDecorator(o.DecoratorFlags.BUILTIN)){let t=e.internalName;return t==r.BuiltinNames.data_end?this.runtimeFeatures|=1:t==r.BuiltinNames.stack_pointer?this.runtimeFeatures|=2:t==r.BuiltinNames.heap_base?this.runtimeFeatures|=4:t==r.BuiltinNames.rtti_base&&(this.runtimeFeatures|=8),n.delete(e),!0}var d=e.type,h=d.toNativeType(),g=e.is(s.CommonFlags.CONST)||e.is(s.CommonFlags.STATIC|s.CommonFlags.READONLY),x=e.hasDecorator(o.DecoratorFlags.INLINE);if(e.is(s.CommonFlags.AMBIENT))return g||this.options.hasFeature(2)?(e.set(s.CommonFlags.MODULE_IMPORT),E(e,e.declaration),t.addGlobalImport(e.internalName,T,b,h,!g),n.delete(e),!0):(this.error(i.DiagnosticCode.Feature_0_is_not_enabled,e.declaration.range,"mutable-globals"),e.set(s.CommonFlags.ERRORED),n.delete(e),!1);var m=!1;if(c){if(!l){let n=this.currentFlow;e.hasDecorator(o.DecoratorFlags.LAZY)&&(this.currentFlow=e.file.startFunction.flow),l=this.compileExpression(c,d,21),this.currentFlow=n}if(a.getExpressionId(l)!=a.ExpressionId.Const)if(g){if(a.getExpressionId(l)!=a.ExpressionId.Const){let e=t.runExpression(l,a.ExpressionRunnerFlags.PreserveSideeffects);e?l=e:m=!0}}else m=!0;if(m&&a.getExpressionId(l)==a.ExpressionId.GlobalGet){let e=assert(a.getGlobalGetName(l));if(!a.isGlobalMutable(t.getGlobal(e))){let n=this.program.elementsByName;n.has(e)&&assert(n.get(e)).is(s.CommonFlags.AMBIENT)&&(m=!1)}}if(x)if(m)this.warning(i.DiagnosticCode.Mutable_value_cannot_be_inlined,c.range);else{switch(assert(a.getExpressionId(l)==a.ExpressionId.Const),a.getExpressionType(l)){case a.NativeType.I32:e.constantValueKind=1,e.constantIntegerValue=i64_new(a.getConstValueI32(l),0);break;case a.NativeType.I64:e.constantValueKind=1,e.constantIntegerValue=i64_new(a.getConstValueI64Low(l),a.getConstValueI64High(l));break;case a.NativeType.F32:e.constantValueKind=2,e.constantFloatValue=a.getConstValueF32(l);break;case a.NativeType.F64:e.constantValueKind=2,e.constantFloatValue=a.getConstValueF64(l);break;default:return assert(!1),e.set(s.CommonFlags.ERRORED),n.delete(e),!1}e.set(s.CommonFlags.INLINED)}}else l=e.is(s.CommonFlags.INLINED)?this.compileInlineConstant(e,e.type,16):this.makeZero(d,e.declaration);var _=e.internalName;return m?(x&&this.error(i.DiagnosticCode.Decorator_0_is_not_valid_here,p.findDecorator(p.DecoratorKind.INLINE,e.decoratorNodes).range,"inline"),t.addGlobal(_,h,!0,this.makeZero(d,e.declaration)),this.currentBody.push(t.global_set(_,l))):x||t.addGlobal(_,h,!g,l),n.delete(e),!0}compileEnum(e){if(e.is(s.CommonFlags.COMPILED))return!e.is(s.CommonFlags.ERRORED);e.set(s.CommonFlags.COMPILED);var n=this.pendingElements;n.add(e);var t=this.module,r=this.currentParent;this.currentParent=e;var l=null,u=!1,c=e.is(s.CommonFlags.CONST)||e.hasDecorator(o.DecoratorFlags.INLINE),p=e.members;if(p)for(let n=Map_values(p),r=0,d=n.length;r<d;++r){let p=unchecked(n[r]);if(p.kind!=o.ElementKind.ENUMVALUE)continue;let d=!1,h=p,g=h.valueNode;h.set(s.CommonFlags.COMPILED);let x,m=this.currentFlow;if(e.hasDecorator(o.DecoratorFlags.LAZY)&&(this.currentFlow=e.file.startFunction.flow),g){if(x=this.compileExpression(g,f.Type.i32,1),a.getExpressionId(x)!=a.ExpressionId.Const){let n=t.runExpression(x,a.ExpressionRunnerFlags.PreserveSideeffects);n?x=n:(e.is(s.CommonFlags.CONST)&&this.error(i.DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,g.range),d=!0)}}else if(null==l)x=t.i32(0);else if(u&&this.error(i.DiagnosticCode.Enum_member_must_have_initializer,h.identifierNode.range.atEnd),c){let e=i64_add(l.constantIntegerValue,i64_new(1));assert(!i64_high(e)),x=t.i32(i64_low(e))}else{x=t.binary(a.BinaryOp.AddI32,t.global_get(l.internalName,a.NativeType.I32),t.i32(1));let n=t.runExpression(x,a.ExpressionRunnerFlags.PreserveSideeffects);n?x=n:(e.is(s.CommonFlags.CONST)&&this.error(i.DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,p.declaration.range),d=!0)}this.currentFlow=m,d?(t.addGlobal(h.internalName,a.NativeType.I32,!0,t.i32(0)),this.currentBody.push(this.makeGlobalAssignment(h,x,f.Type.i32,!1)),u=!0):(c?(h.setConstantIntegerValue(i64_new(a.getConstValueI32(x)),f.Type.i32),h.is(s.CommonFlags.MODULE_EXPORT)&&t.addGlobal(h.internalName,a.NativeType.I32,!1,x)):t.addGlobal(h.internalName,a.NativeType.I32,!1,x),h.isImmutable=!0,u=!1),l=h}return this.currentParent=r,n.delete(e),!0}compileFunction(e,n=!1){if(e.is(s.CommonFlags.COMPILED))return!e.is(s.CommonFlags.ERRORED);if(!n){if(e.hasDecorator(o.DecoratorFlags.BUILTIN))return!0;if(e.hasDecorator(o.DecoratorFlags.LAZY))return this.lazyFunctions.add(e),!0}e.set(s.CommonFlags.COMPILED);var t=this.pendingElements;t.add(e);var r,a=this.currentType,l=this.module,u=e.signature,c=e.prototype.bodyNode,d=e.declaration;if(assert(d.kind==p.NodeKind.FUNCTIONDECLARATION||d.kind==p.NodeKind.METHODDECLARATION),this.checkSignatureSupported(e.signature,d.signature),c){if(e.is(s.CommonFlags.AMBIENT)&&this.error(i.DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,e.identifierNode.range),e.hasDecorator(o.DecoratorFlags.EXTERNAL)){let n=e.decoratorNodes,t=assert(p.findDecorator(p.DecoratorKind.EXTERNAL,n));this.error(i.DiagnosticCode.Decorator_0_is_not_valid_here,t.range,"external")}let n=this.currentFlow,t=e.flow;this.currentFlow=t;let a=new Array;this.compileFunctionBody(e,a)||a.push(l.unreachable()),this.currentFlow=n,r=l.addFunction(e.internalName,u.nativeParams,u.nativeResults,f.typesToNativeTypes(e.additionalLocals),l.flatten(a,e.signature.returnType.toNativeType()))}else e.is(s.CommonFlags.AMBIENT)?(e.set(s.CommonFlags.MODULE_IMPORT),E(e,d),l.addFunctionImport(e.internalName,T,b,u.nativeParams,u.nativeResults),r=l.getFunction(e.internalName)):e.is(s.CommonFlags.ABSTRACT)||e.parent.kind==o.ElementKind.INTERFACE?r=l.addFunction(e.internalName,u.nativeParams,u.nativeResults,null,l.unreachable()):(this.error(i.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,e.identifierNode.range),r=0,e.set(s.CommonFlags.ERRORED));return e.finalize(l,r),this.currentType=a,t.delete(e),!0}compileFunctionBody(e,n){var t=this.module,r=assert(e.prototype.bodyNode),l=e.signature.returnType,u=this.currentFlow,c=e.signature.thisType?assert(u.lookupLocal(s.CommonNames.this_)):null,d=n.length;if(r.kind==p.NodeKind.BLOCK)n=this.compileStatements(r.statements,!0,n);else{assert(r.kind==p.NodeKind.EXPRESSION),assert(e.prototype.arrowKind),assert(!e.isAny(s.CommonFlags.CONSTRUCTOR|s.CommonFlags.GET|s.CommonFlags.SET));let t=this.compileExpression(r.expression,l,1);u.canOverflow(t,l)||u.set(2),u.isNonnull(t,l)&&u.set(4),n?n.push(t):n=[t],u.is(256)||(u.canOverflow(t,l)||u.set(2),u.isNonnull(t,l)&&u.set(4),u.set(257))}if(e.is(s.CommonFlags.CONSTRUCTOR)){assert(e.is(s.CommonFlags.INSTANCE)),c=assert(c);let r=assert(e.parent);assert(r.kind==o.ElementKind.CLASS);let l=r;if(u.isAny(8256)||!u.is(256)){let r=new Array;r.push(this.makeConditionalAllocation(l,c.index)),this.makeFieldInitializationInConstructor(l,r);for(let e=n.length-1;e>=d;--e)n[e+1]=n[e];n[d]=t.flatten(r,a.NativeType.None),u.is(16384)&&this.options.pedantic&&this.pedantic(i.DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,e.identifierNode.range)}u.is(16384)&&!l.hasDecorator(o.DecoratorFlags.FINAL)&&this.error(i.DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,l.identifierNode.range),u.is(256)||(n.push(t.local_get(c.index,this.options.nativeSizeType)),u.set(261)),null===l.base||u.is(128)||this.error(i.DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,e.prototype.declaration.range)}else if(l!=f.Type.void&&!u.is(256))return this.error(i.DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,e.prototype.functionTypeNode.returnType.range),!1;return!0}compileClass(e){if(e.is(s.CommonFlags.COMPILED))return!0;e.set(s.CommonFlags.COMPILED);var n=e.prototype.members;if(n)for(let e=Map_values(n),t=0,r=e.length;t<r;++t){let n=unchecked(e[t]);switch(n.kind){case o.ElementKind.GLOBAL:this.compileGlobal(n);break;case o.ElementKind.FUNCTION_PROTOTYPE:{if(n.is(s.CommonFlags.GENERIC))break;let e=this.resolver.resolveFunction(n,null);if(!e)break;n=e}case o.ElementKind.FUNCTION:this.compileFunction(n);break;case o.ElementKind.PROPERTY_PROTOTYPE:{let e=this.resolver.resolveProperty(n);if(!e)break;n=e}case o.ElementKind.PROPERTY:this.compileProperty(n)}}this.ensureConstructor(e,e.identifierNode),this.checkFieldInitialization(e);var t=e.members;if(t)for(let e=Map_values(t),n=0,r=e.length;n<r;++n){let t=unchecked(e[n]);switch(t.kind){case o.ElementKind.FUNCTION_PROTOTYPE:{if(t.is(s.CommonFlags.GENERIC))break;let e=this.resolver.resolveFunction(t,null);if(!e)break;t=e}case o.ElementKind.FUNCTION:this.compileFunction(t);break;case o.ElementKind.FIELD:this.compileField(t);break;case o.ElementKind.PROPERTY_PROTOTYPE:{let e=this.resolver.resolveProperty(t);if(!e)break;t=e}case o.ElementKind.PROPERTY:this.compileProperty(t)}}return!0}compileField(e){return this.compileFieldGetter(e),this.compileFieldSetter(e),e.is(s.CommonFlags.COMPILED)}compileFieldGetter(e){if(e.getterRef)return!0;var n=this.module,t=e.type,r=t.toNativeType(),i=this.options.nativeSizeType;if(e.getterRef=n.addFunction(e.internalGetterName,i,r,null,n.load(t.byteSize,t.isSignedIntegerValue,n.local_get(0,i),r,e.memoryOffset)),e.setterRef)e.set(s.CommonFlags.COMPILED);else{let n=e.typeNode;n&&this.checkTypeSupported(e.type,n)}return!0}compileFieldSetter(e){if(e.setterRef)return!0;var n=e.type,t=this.options.nativeSizeType,r=n.toNativeType(),i=this.module,l=i.store(n.byteSize,i.local_get(0,t),i.local_get(1,r),r,e.memoryOffset);if(n.isManaged){let n=e.parent;if(assert(n.kind==o.ElementKind.CLASS),n.type.isManaged){let e=this.program.linkInstance;this.compileFunction(e),l=i.block(null,[l,i.call(e.internalName,[i.local_get(0,t),i.local_get(1,r),i.i32(0)],a.NativeType.None)],a.NativeType.None)}}if(e.setterRef=i.addFunction(e.internalSetterName,a.createType([t,r]),a.NativeType.None,null,l),e.getterRef)e.set(s.CommonFlags.COMPILED);else{let n=e.typeNode;n&&this.checkTypeSupported(e.type,n)}return!0}compileProperty(e){return this.compilePropertyGetter(e),this.compilePropertySetter(e),e.is(s.CommonFlags.COMPILED)}compilePropertyGetter(e){var n=e.getterInstance;if(n){let t=this.compileFunction(n),r=e.setterInstance;return!n.is(s.CommonFlags.COMPILED)||r&&!r.is(s.CommonFlags.COMPILED)||e.set(s.CommonFlags.COMPILED),t}return!1}compilePropertySetter(e){var n=e.setterInstance;if(n){let t=this.compileFunction(n),r=e.getterInstance;return null!==r&&r.is(s.CommonFlags.COMPILED)&&n.is(s.CommonFlags.COMPILED)&&e.set(s.CommonFlags.COMPILED),t}return!1}addAlignedMemorySegment(e,n=16){assert(d.isPowerOf2(n));var t=i64_align(this.memoryOffset,n),r=new a.MemorySegment(e,t);return this.memorySegments.push(r),this.memoryOffset=i64_add(t,i64_new(e.length)),r}addRuntimeMemorySegment(e){var n=this.program.computeBlockStart64(this.memoryOffset),t=new a.MemorySegment(e,n);return this.memorySegments.push(t),this.memoryOffset=i64_add(n,i64_new(e.length)),t}ensureStaticString(e){var n,t=this.program,r=t.totalOverhead,i=assert(t.stringInstance),a=this.stringSegments;if(a.has(e))n=assert(a.get(e));else{let t=e.length,s=i.createBuffer(t<<1);for(let n=0;n<t;++n)d.writeI16(e.charCodeAt(n),s,r+(n<<1));n=this.addRuntimeMemorySegment(s),a.set(e,n)}var s=i64_add(n.offset,i64_new(r));return this.currentType=i.type,this.options.isWasm64?this.module.i64(i64_low(s),i64_high(s)):(assert(i64_is_u32(s)),this.module.i32(i64_low(s)))}writeStaticBuffer(e,n,t,r){var i=r.length,s=t.byteSize,o=t.toNativeType();switch(o){case a.NativeType.I32:switch(s){case 1:for(let t=0;t<i;++t){let i=r[t];assert(a.getExpressionType(i)==o),assert(a.getExpressionId(i)==a.ExpressionId.Const),d.writeI8(a.getConstValueI32(i),e,n),n+=1}break;case 2:for(let t=0;t<i;++t){let i=r[t];assert(a.getExpressionType(i)==o),assert(a.getExpressionId(i)==a.ExpressionId.Const),d.writeI16(a.getConstValueI32(i),e,n),n+=2}break;case 4:for(let t=0;t<i;++t){let i=r[t];assert(a.getExpressionType(i)==o),assert(a.getExpressionId(i)==a.ExpressionId.Const),d.writeI32(a.getConstValueI32(i),e,n),n+=4}break;default:assert(!1)}break;case a.NativeType.I64:for(let t=0;t<i;++t){let i=r[t];assert(a.getExpressionType(i)==o),assert(a.getExpressionId(i)==a.ExpressionId.Const),d.writeI64(i64_new(a.getConstValueI64Low(i),a.getConstValueI64High(i)),e,n),n+=8}break;case a.NativeType.F32:for(let t=0;t<i;++t){let i=r[t];assert(a.getExpressionType(i)==o),assert(a.getExpressionId(i)==a.ExpressionId.Const),d.writeF32(a.getConstValueF32(i),e,n),n+=4}break;case a.NativeType.F64:for(let t=0;t<i;++t){let i=r[t];assert(a.getExpressionType(i)==o),assert(a.getExpressionId(i)==a.ExpressionId.Const),d.writeF64(a.getConstValueF64(i),e,n),n+=8}break;default:assert(!1)}return n}addStaticBuffer(e,n,t=this.program.arrayBufferInstance.id){var r=this.program,i=r.arrayBufferInstance.createBuffer(n.length*e.byteSize);return this.program.OBJECTInstance.writeField("rtId",t,i,0),this.writeStaticBuffer(i,r.totalOverhead,e,n),this.addRuntimeMemorySegment(i)}addStaticArrayHeader(e,n){var t=this.program,r=assert(t.arrayPrototype),i=assert(this.resolver.resolveClass(r,[e])),a=d.readI32(n.buffer,t.OBJECTInstance.offsetof("rtSize")),s=i32(a/e.byteSize),o=i64_add(n.offset,i64_new(t.totalOverhead)),l=i.createBuffer();return assert(i.writeField("buffer",o,l)),assert(i.writeField("dataStart",o,l)),assert(i.writeField("byteLength",a,l)),assert(i.writeField("length_",s,l)),this.addRuntimeMemorySegment(l)}ensureRuntimeFunction(e){assert(e.is(s.CommonFlags.COMPILED)&&!e.is(s.CommonFlags.STUB));var n=this.program,t=e.memorySegment;if(!t){let r=this.functionTable,i=this.options.tableBase;i||(i=1);let a=i+r.length;r.push(e);let s=assert(this.resolver.resolveClass(n.functionPrototype,[e.type])),o=s.createBuffer();assert(s.writeField("_index",a,o)),assert(s.writeField("_env",0,o)),e.memorySegment=t=this.addRuntimeMemorySegment(o)}return i64_add(t.offset,i64_new(n.totalOverhead))}compileTopLevelStatement(e,n){switch(e.kind){case p.NodeKind.CLASSDECLARATION:{let t=e.members;for(let e=0,r=t.length;e<r;++e)this.compileTopLevelStatement(t[e],n);break}case p.NodeKind.ENUMDECLARATION:{let n=this.program.getElementByDeclaration(e);n&&(assert(n.kind==o.ElementKind.ENUM),n.hasDecorator(o.DecoratorFlags.LAZY)||this.compileEnum(n));break}case p.NodeKind.NAMESPACEDECLARATION:{let t=e,r=this.program.getElementByDeclaration(t);if(r){let e=this.currentParent;this.currentParent=r;let i=t.members;for(let e=0,t=i.length;e<t;++e)this.compileTopLevelStatement(i[e],n);this.currentParent=e}break}case p.NodeKind.VARIABLE:{let n=e.declarations;for(let e=0,t=n.length;e<t;++e){let t=this.program.getElementByDeclaration(n[e]);t&&(assert(t.kind==o.ElementKind.GLOBAL),t.is(s.CommonFlags.AMBIENT)||t.hasDecorator(o.DecoratorFlags.LAZY)||this.compileGlobal(t))}break}case p.NodeKind.FIELDDECLARATION:{let n=this.program.getElementByDeclaration(e);null!==n&&n.kind==o.ElementKind.GLOBAL&&(n.hasDecorator(o.DecoratorFlags.LAZY)||this.compileGlobal(n));break}case p.NodeKind.EXPORT:{let n=e,t=n.internalPath;null!==t&&this.compileFileByPath(t,assert(n.path));break}case p.NodeKind.EXPORTDEFAULT:this.compileTopLevelStatement(e.declaration,n);break;case p.NodeKind.IMPORT:{let n=e;this.compileFileByPath(n.internalPath,n.path);break}case p.NodeKind.FUNCTIONDECLARATION:case p.NodeKind.METHODDECLARATION:case p.NodeKind.INTERFACEDECLARATION:case p.NodeKind.INDEXSIGNATURE:case p.NodeKind.TYPEDECLARATION:break;default:{let t=this.compileStatement(e);a.getExpressionId(t)!=a.ExpressionId.Nop&&n.push(t);break}}}compileStatement(e,n=!1){var t,r=this.module;switch(e.kind){case p.NodeKind.BLOCK:t=this.compileBlockStatement(e);break;case p.NodeKind.BREAK:t=this.compileBreakStatement(e);break;case p.NodeKind.CONTINUE:t=this.compileContinueStatement(e);break;case p.NodeKind.DO:t=this.compileDoStatement(e);break;case p.NodeKind.EMPTY:t=this.compileEmptyStatement(e);break;case p.NodeKind.EXPRESSION:t=this.compileExpressionStatement(e);break;case p.NodeKind.FOR:t=this.compileForStatement(e);break;case p.NodeKind.FOROF:t=this.compileForOfStatement(e);break;case p.NodeKind.IF:t=this.compileIfStatement(e);break;case p.NodeKind.RETURN:t=this.compileReturnStatement(e,n);break;case p.NodeKind.SWITCH:t=this.compileSwitchStatement(e);break;case p.NodeKind.THROW:t=this.compileThrowStatement(e);break;case p.NodeKind.TRY:t=this.compileTryStatement(e);break;case p.NodeKind.VARIABLE:(t=this.compileVariableStatement(e))||(t=r.nop());break;case p.NodeKind.VOID:t=this.compileVoidStatement(e);break;case p.NodeKind.WHILE:t=this.compileWhileStatement(e);break;case p.NodeKind.TYPEDECLARATION:this.error(i.DiagnosticCode.Not_implemented_0,e.range,"Inner type alias"),t=r.unreachable();break;default:assert(!1),t=r.unreachable()}return this.options.sourceMap&&this.addDebugLocation(t,e.range),t}compileStatements(e,n=!1,t=null){var r=e.length;t||((t=new Array(r)).length=0);var i=this.module,s=this.currentFlow;for(let o=0;o<r;++o){let l=this.compileStatement(e[o],n&&o==r-1);switch(a.getExpressionId(l)){case a.ExpressionId.Block:if(!a.getBlockName(l)){for(let e=0,n=a.getBlockChildCount(l);e<n;++e)t.push(a.getBlockChildAt(l,e));break}default:t.push(l);case a.ExpressionId.Nop:}if(s.isAny(272)){a.needsExplicitUnreachable(l)&&t.push(i.unreachable());break}}return t}compileBlockStatement(e){var n=e.statements,t=this.currentFlow,r=t.fork();this.currentFlow=r;var i=this.compileStatements(n);return r.freeScopedLocals(),t.inherit(r),this.currentFlow=t,this.module.flatten(i)}compileBreakStatement(e){var n=this.module,t=e.label;if(t)return this.error(i.DiagnosticCode.Not_implemented_0,t.range,"Break label"),n.unreachable();var r=this.currentFlow,a=r.breakLabel;return null==a?(this.error(i.DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,e.range),n.unreachable()):(r.freeScopedLocals(),r.set(16),n.br(a))}compileContinueStatement(e){var n=this.module,t=e.label;if(t)return this.error(i.DiagnosticCode.Not_implemented_0,t.range,"Continue label"),n.unreachable();var r=this.currentFlow,a=r.continueLabel;return null==a?(this.error(i.DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,e.range),n.unreachable()):(r.set(288),r.freeScopedLocals(),n.br(a))}compileDoStatement(e){return this.doCompileDoStatement(e,null)}doCompileDoStatement(e,n){var t=this.module,r=this.currentFlow,i=r.pushBreakLabel(),s=r.fork(!0);n&&s.unifyLocalFlags(n);var o=s.fork();this.currentFlow=s;var u="do-break|"+i;s.breakLabel=u;var c="do-continue|"+i;s.continueLabel=c;var d=s.fork();this.currentFlow=d;var h=new Array,g=e.statement;if(g.kind==p.NodeKind.BLOCK?this.compileStatements(g.statements,!1,h):h.push(this.compileStatement(g)),d.isAny(272))h.push(t.unreachable()),s.inherit(d);else{let n=s.fork();this.currentFlow=n;let i=this.makeIsTrueish(this.compileExpression(e.condition,f.Type.i32),this.currentType,e.condition),u=this.evaluateCondition(i);if(2==u)h.push(t.drop(i)),s.inherit(d);else if(1!=u||d.isAny(2064)){let u=n.getTempLocal(f.Type.bool);if(h.push(t.local_set(u.index,i,!1)),h.push(t.br(c,t.local_get(u.index,a.NativeType.I32))),n.freeTempLocal(u),s.inherit(n),l.Flow.hasIncompatibleLocalStates(o,s))return r.popBreakLabel(),this.currentFlow=r,this.doCompileDoStatement(e,s)}else h.push(t.drop(i)),h.push(t.br(c)),s.set(256)}assert(!s.hasScopedLocals),r.inherit(s),r.popBreakLabel(),this.currentFlow=r;var x=t.block(u,[t.loop(c,t.flatten(h))]);return r.is(256)&&(x=t.block(null,[x,t.unreachable()])),x}compileEmptyStatement(e){return this.module.nop()}compileExpressionStatement(e){return this.compileExpression(e.expression,f.Type.void,1)}compileForStatement(e){return this.doCompileForStatement(e,null)}doCompileForStatement(e,n){var t=this.module,r=this.currentFlow,i=r.pushBreakLabel(),s=new Array,o=r.fork(!0);this.currentFlow=o;var u="for-break"+i;o.breakLabel=u;var c="for-continue|"+i;o.continueLabel=c;var d="for-loop|"+i,h=e.initializer;h&&(assert(h.kind==p.NodeKind.EXPRESSION||h.kind==p.NodeKind.VARIABLE),s.push(this.compileStatement(h))),n&&o.unifyLocalFlags(n);var g,x,m=o.fork(),_=o.fork();this.currentFlow=_;var y=e.condition;if(y){if(g=this.makeIsTrueish(this.compileExpression(y,f.Type.bool),this.currentType,y),2==(x=this.evaluateCondition(g)))return s.push(t.drop(g)),_.freeScopedLocals(),o.inherit(_),o.freeScopedLocals(),r.inherit(o),r.popBreakLabel(),this.currentFlow=r,t.flatten(s)}else g=t.i32(1),x=1;var E=o.getTempLocal(f.Type.bool),T=new Array;T.push(t.local_set(E.index,g,!1)),_.freeScopedLocals(),o.inherit(_),this.currentFlow=o;var b=o.fork();b.inheritNonnullIfTrue(g),this.currentFlow=b;var v=new Array,A=e.statement;A.kind==p.NodeKind.BLOCK?this.compileStatements(A.statements,!1,v):v.push(this.compileStatement(A)),b.isAny(272)&&v.push(t.unreachable()),1==x?o.inherit(b):o.inheritBranch(b),b.freeScopedLocals();var F=new Array;if(F.push(t.block(c,v)),!b.is(256)||b.isAny(4128)){let n=e.incrementor;if(n){let e=o.fork();this.currentFlow=e,F.push(this.compileExpression(n,f.Type.void,9)),e.freeScopedLocals(),o.inherit(e),this.currentFlow=o}if(F.push(t.br(d)),l.Flow.hasIncompatibleLocalStates(m,o))return assert(!b.hasScopedLocals),o.freeScopedLocals(),r.popBreakLabel(),this.currentFlow=r,this.doCompileForStatement(e,o)}return T.push(t.if(t.local_get(E.index,a.NativeType.I32),t.flatten(F))),s.push(t.block(u,[t.loop(d,t.flatten(T))])),o.freeTempLocal(E),this.currentFlow=o,o.freeScopedLocals(),r.inherit(o),r.popBreakLabel(),r.is(256)&&s.push(t.unreachable()),this.currentFlow=r,t.flatten(s)}compileForOfStatement(e){return this.error(i.DiagnosticCode.Not_implemented_0,e.range,"Iterators"),this.module.unreachable()}compileIfStatement(e){var n=this.module,t=e.ifTrue,r=e.ifFalse,i=this.makeIsTrueish(this.compileExpression(e.condition,f.Type.bool),this.currentType,e.condition);switch(this.evaluateCondition(i)){case 1:return n.block(null,[n.drop(i),this.compileStatement(t)]);case 2:return r?n.block(null,[n.drop(i),this.compileStatement(r)]):n.drop(i)}var a=this.currentFlow,s=new Array,o=a.fork();if(this.currentFlow=o,o.inheritNonnullIfTrue(i),t.kind==p.NodeKind.BLOCK?this.compileStatements(t.statements,!1,s):s.push(this.compileStatement(t)),o.isAny(272)&&s.push(n.unreachable()),o.freeScopedLocals(),this.currentFlow=a,r){let e=new Array,t=a.fork();return this.currentFlow=t,t.inheritNonnullIfFalse(i),r.kind==p.NodeKind.BLOCK?this.compileStatements(r.statements,!1,e):e.push(this.compileStatement(r)),t.isAny(272)&&e.push(n.unreachable()),t.freeScopedLocals(),this.currentFlow=a,a.inheritMutual(o,t),n.if(i,n.flatten(s),n.flatten(e))}return a.inheritBranch(o),a.inheritNonnullIfFalse(i,o.isAny(272)?null:o),n.if(i,n.flatten(s))}compileReturnStatement(e,n){var t=this.module,r=0,a=this.currentFlow,o=a.returnType,l=e.value;if(l){if(o==f.Type.void)return this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,l.range,this.currentType.toString(),o.toString()),this.currentType=f.Type.void,t.unreachable();let e=1;a.actualFunction.is(s.CommonFlags.MODULE_EXPORT)&&(e|=4),r=this.compileExpression(l,o,e),a.canOverflow(r,o)||a.set(2),a.isNonnull(r,o)&&a.set(4),a.actualFunction.is(s.CommonFlags.CONSTRUCTOR)&&l.kind!=p.NodeKind.THIS&&a.set(16384)}else if(o!=f.Type.void)return this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,e.range,"void",o.toString()),this.currentType=o,t.unreachable();return a.freeScopedLocals(),a.set(257),a.isInline?n&&0!=r?r:t.br(assert(a.inlineReturnLabel),0,r):n&&0!=r?r:t.return(r)}compileSwitchStatement(e){var n=this.module,t=e.cases,r=t.length;if(!r)return this.compileExpression(e.condition,f.Type.void,1);var i=this.currentFlow,s=i.pushBreakLabel(),o=i.getTempLocal(f.Type.u32),l=o.index,u=new Array(1+r);u[0]=n.local_set(l,this.compileExpression(e.condition,f.Type.u32,1),!1);var c=1,p=-1;for(let e=0;e<r;++e){let r=t[e].label;r?u[c++]=n.br("case"+e.toString()+"|"+s,n.binary(a.BinaryOp.EqI32,n.local_get(l,a.NativeType.I32),this.compileExpression(r,f.Type.u32,1))):p=e}i.freeTempLocal(o),u[c]=n.br((p>=0?"case"+p.toString():"break")+"|"+s);var d=n.block("case0|"+s,u,a.NativeType.None),h=511,g=0;for(let e=0;e<r;++e){let o=t[e].statements,l=o.length,u=i.fork();this.currentFlow=u;let c="break|"+s;u.breakLabel=c;let p=e==r-1,f=p?c:"case"+(e+1).toString()+"|"+s,x=new Array(1+l);x[0]=d;let m=1,_=!1;for(let e=0;e<l;++e){let n=this.compileStatement(o[e]);if(a.getExpressionId(n)!=a.ExpressionId.Nop&&(x[m++]=n),u.isAny(272)){u.is(256)&&(_=!0);break}}x.length=m,(_||p||u.isAny(2064))&&(h&=u.flags),g|=15872&u.flags,u.unset(2064),u.freeScopedLocals(),this.currentFlow=i,d=n.block(f,x,a.NativeType.None)}return i.popBreakLabel(),p>=0&&(i.flags|=-17&h),i.flags|=-2049&g,d}compileThrowStatement(e){var n=this.currentFlow;n.set(264);var t=new Array,r=e.value,i=null;if(r.kind==p.NodeKind.NEW){let e=r.args;e.length&&(i=e[0])}return t.push(this.makeAbort(i,e)),n.freeScopedLocals(),this.module.flatten(t)}compileTryStatement(e){return this.error(i.DiagnosticCode.Not_implemented_0,e.range,"Exceptions"),this.module.unreachable()}compileVariableStatement(e){var n=this.module,t=e.declarations,r=t.length,u=this.currentFlow,c=new Array,p=this.resolver;for(let e=0;e<r;++e){let r=t[e],h=r.name.text,g=null,x=0,m=r.type,_=r.initializer;if(m){if(g=p.resolveType(m,u.actualFunction,d.uniqueMap(u.contextualTypeArguments)),!g)continue;if(this.checkTypeSupported(g,m),_){let e=this.pendingElements,n=u.addScopedDummyLocal(h,g);e.add(n),x=this.compileExpression(_,g,1),e.delete(n),u.freeScopedDummyLocal(h)}}else{if(!_){this.error(i.DiagnosticCode.Type_expected,r.name.range.atEnd);continue}{let e=this.pendingElements,n=u.addScopedDummyLocal(h,f.Type.auto);if(e.add(n),x=this.compileExpression(_,f.Type.auto),e.delete(n),u.freeScopedDummyLocal(h),this.currentType==f.Type.void){this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,r.range,this.currentType.toString(),"<auto>");continue}g=this.currentType}}let y=r.is(s.CommonFlags.CONST),E=!1;if(y)if(x){let e=n.runExpression(x,a.ExpressionRunnerFlags.PreserveSideeffects);if(e){x=e;let n=null;switch(a.getExpressionType(x)){case a.NativeType.I32:n=new o.Local(h,-1,g,u.parentFunction),n.setConstantIntegerValue(i64_new(a.getConstValueI32(x),0),g);break;case a.NativeType.I64:n=new o.Local(h,-1,g,u.parentFunction),n.setConstantIntegerValue(i64_new(a.getConstValueI64Low(x),a.getConstValueI64High(x)),g);break;case a.NativeType.F32:n=new o.Local(h,-1,g,u.parentFunction),n.setConstantFloatValue(a.getConstValueF32(x),g);break;case a.NativeType.F64:n=new o.Local(h,-1,g,u.parentFunction),n.setConstantFloatValue(a.getConstValueF64(x),g)}if(n){let e=u.scopedLocals;if(e){if(e.has(h)){let n=assert(e.get(h));return this.errorRelated(i.DiagnosticCode.Duplicate_identifier_0,r.name.range,n.declaration.name.range,h),this.module.unreachable()}}else u.scopedLocals=e=new Map;e.set(h,n),E=!0}}}else this.error(i.DiagnosticCode._const_declarations_must_be_initialized,r.range);if(!E){let e;if(r.isAny(s.CommonFlags.LET|s.CommonFlags.CONST)||u.isInline){let n=u.getScopedLocal(h);n?(n.declaration.range.source.isNative?this.error(i.DiagnosticCode.Duplicate_identifier_0,r.name.range,h):this.errorRelated(i.DiagnosticCode.Duplicate_identifier_0,r.name.range,n.declaration.name.range,h),e=n):e=u.addScopedLocal(h,g),y&&u.setLocalFlag(e.index,l.LocalFlags.CONSTANT)}else{let n=u.lookupLocal(h);if(n){this.errorRelated(i.DiagnosticCode.Duplicate_identifier_0,r.name.range,n.declaration.name.range,h);continue}e=u.parentFunction.addLocal(g,h,r),y&&u.setLocalFlag(e.index,l.LocalFlags.CONSTANT)}x?c.push(this.makeLocalAssignment(e,x,g,!1)):e.type.isShortIntegerValue&&u.setLocalFlag(e.index,l.LocalFlags.WRAPPED)}}return this.currentType=f.Type.void,0==c.length?0:n.flatten(c)}compileVoidStatement(e){return this.compileExpression(e.expression,f.Type.void,10)}compileWhileStatement(e){return this.doCompileWhileStatement(e,null)}doCompileWhileStatement(e,n){var t=this.module,r=this.currentFlow,i=r.pushBreakLabel(),s=new Array,o=r.fork(!0);n&&o.unifyLocalFlags(n);var u=o.fork();this.currentFlow=o;var c="while-break|"+i;o.breakLabel=c;var d="while-continue|"+i;o.continueLabel=d;var h=o.fork();this.currentFlow=h;var g=this.makeIsTrueish(this.compileExpression(e.condition,f.Type.bool),this.currentType,e.condition),x=this.evaluateCondition(g);if(2==x)return s.push(t.drop(g)),assert(!o.hasScopedLocals),r.popBreakLabel(),this.currentFlow=r,t.flatten(s);var m=o.getTempLocal(f.Type.bool);s.push(t.local_set(m.index,g,!1)),h.freeScopedLocals(),o.inherit(h),this.currentFlow=o;var _=o.fork();_.inheritNonnullIfTrue(g),this.currentFlow=_;var y=new Array,E=e.statement;if(E.kind==p.NodeKind.BLOCK?this.compileStatements(E.statements,!1,y):y.push(this.compileStatement(E)),_.is(256))y.push(t.unreachable()),1==x?o.inherit(_):o.inheritBranch(_);else if(1!=x||_.isAny(2064)){let n=_.is(16);if(n?y.push(t.unreachable()):y.push(t.br(d)),1==x?o.inherit(_):o.inheritBranch(_),!n&&l.Flow.hasIncompatibleLocalStates(u,o))return o.freeTempLocal(m),r.popBreakLabel(),this.currentFlow=r,this.doCompileWhileStatement(e,o)}else y.push(t.br(d)),o.set(256);s.push(t.if(t.local_get(m.index,a.NativeType.I32),t.flatten(y))),o.freeTempLocal(m),this.currentFlow=o,assert(!o.hasScopedLocals),r.inherit(o),r.popBreakLabel(),this.currentFlow=r;var T=t.block(c,[t.loop(d,t.flatten(s))]);return 1==x&&r.is(256)&&(T=t.block(null,[T,t.unreachable()])),T}compileInlineConstant(e,n,t){assert(e.is(s.CommonFlags.INLINED|s.CommonFlags.RESOLVED));var r=e.type;switch(!(3&t)&&r.isIntegerValue&&n.isIntegerValue&&r.size<n.size?(this.currentType=n).kind:(this.currentType=r).kind){case 0:case 1:{let n=r.computeSmallIntegerShift(f.Type.i32);return this.module.i32(1==e.constantValueKind?i64_low(e.constantIntegerValue)<<n>>n:0)}case 5:case 6:case 10:{let n=e.type.computeSmallIntegerMask(f.Type.i32);return this.module.i32(1==e.constantValueKind?i64_low(e.constantIntegerValue)&n:0)}case 2:case 7:return this.module.i32(1==e.constantValueKind?i64_low(e.constantIntegerValue):0);case 4:case 9:if(!e.program.options.isWasm64)return this.module.i32(1==e.constantValueKind?i64_low(e.constantIntegerValue):0);case 3:case 8:return 1==e.constantValueKind?this.module.i64(i64_low(e.constantIntegerValue),i64_high(e.constantIntegerValue)):this.module.i64(0);case 12:if(!e.hasDecorator(o.DecoratorFlags.BUILTIN)||n!=f.Type.f32)return this.module.f64(e.constantFloatValue);this.currentType=f.Type.f32;case 11:return this.module.f32(e.constantFloatValue);default:return assert(!1),this.module.unreachable()}}compileExpression(e,n,t=0){for(;e.kind==p.NodeKind.PARENTHESIZED;)e=e.expression;var r;switch(this.currentType=n,n==f.Type.void&&(t|=8),e.kind){case p.NodeKind.ASSERTION:r=this.compileAssertionExpression(e,n,t);break;case p.NodeKind.BINARY:r=this.compileBinaryExpression(e,n,t);break;case p.NodeKind.CALL:r=this.compileCallExpression(e,n,t);break;case p.NodeKind.COMMA:r=this.compileCommaExpression(e,n,t);break;case p.NodeKind.ELEMENTACCESS:r=this.compileElementAccessExpression(e,n,t);break;case p.NodeKind.FUNCTION:r=this.compileFunctionExpression(e,n,t);break;case p.NodeKind.IDENTIFIER:case p.NodeKind.FALSE:case p.NodeKind.NULL:case p.NodeKind.THIS:case p.NodeKind.SUPER:case p.NodeKind.TRUE:r=this.compileIdentifierExpression(e,n,t);break;case p.NodeKind.INSTANCEOF:r=this.compileInstanceOfExpression(e,n,t);break;case p.NodeKind.LITERAL:r=this.compileLiteralExpression(e,n,t);break;case p.NodeKind.NEW:r=this.compileNewExpression(e,n,t);break;case p.NodeKind.PROPERTYACCESS:r=this.compilePropertyAccessExpression(e,n,t);break;case p.NodeKind.TERNARY:r=this.compileTernaryExpression(e,n,t);break;case p.NodeKind.UNARYPOSTFIX:r=this.compileUnaryPostfixExpression(e,n,t);break;case p.NodeKind.UNARYPREFIX:r=this.compileUnaryPrefixExpression(e,n,t);break;default:assert(!1),r=this.module.unreachable()}var i=this.currentType,a=0!=(4&t);return i!=n.nonNullableType&&(2&t?(r=this.convertExpression(r,i,n,!0,e),this.currentType=n):1&t&&(r=this.convertExpression(r,i,n,!1,e),this.currentType=n)),a&&(r=this.ensureSmallIntegerWrap(r,i)),this.options.sourceMap&&this.addDebugLocation(r,e.range),r}convertExpression(e,n,t,r,s){var o=this.module;if(18==n.kind)return assert(18!=t.kind),this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,s.range,n.toString(),t.toString()),o.unreachable();if(18==t.kind)return o.drop(e);if(n.isReference||t.isReference)return this.currentFlow.isNonnull(e,n)?n=n.nonNullableType:r&&n.isNullableReference&&!t.isNullableReference&&(this.options.noAssert||(e=this.makeRuntimeNonNullCheck(e,n,s)),n=n.nonNullableType),n.isAssignableTo(t)?(assert(t.isExternalReference||n.kind==t.kind),this.currentType=t,e):r&&t.nonNullableType.isAssignableTo(n)?t.isExternalReference?(this.error(i.DiagnosticCode.Not_implemented_0,s.range,"ref.cast"),this.currentType=t,o.unreachable()):(assert(n.kind==t.kind),this.options.noAssert||(e=this.makeRuntimeUpcastCheck(e,n,t,s)),this.currentType=t,e):(this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,s.range,n.toString(),t.toString()),this.currentType=t,o.unreachable());if(assert(!n.isReference&&!t.isReference),n.isAssignableTo(t)||r||this.error(i.DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,s.range,n.toString(),t.toString()),n.isFloatValue)if(t.isFloatValue)11==n.kind?12==t.kind&&(e=o.unary(a.UnaryOp.PromoteF32,e)):11==t.kind&&(e=o.unary(a.UnaryOp.DemoteF64,e));else if(t.isIntegerValue)if(11==n.kind)if(t.isBooleanValue)e=this.makeIsTrueish(e,f.Type.f32,s);else if(t.isSignedIntegerValue){let n=this.options.hasFeature(4);e=t.isLongIntegerValue?o.unary(n?a.UnaryOp.TruncF32ToI64Sat:a.UnaryOp.TruncF32ToI64,e):o.unary(n?a.UnaryOp.TruncF32ToI32Sat:a.UnaryOp.TruncF32ToI32,e)}else{let n=this.options.hasFeature(4);e=t.isLongIntegerValue?o.unary(n?a.UnaryOp.TruncF32ToU64Sat:a.UnaryOp.TruncF32ToU64,e):o.unary(n?a.UnaryOp.TruncF32ToU32Sat:a.UnaryOp.TruncF32ToU32,e)}else if(t.isBooleanValue)e=this.makeIsTrueish(e,f.Type.f64,s);else if(t.isSignedIntegerValue){let n=this.options.hasFeature(4);e=t.isLongIntegerValue?o.unary(n?a.UnaryOp.TruncF64ToI64Sat:a.UnaryOp.TruncF64ToI64,e):o.unary(n?a.UnaryOp.TruncF64ToI32Sat:a.UnaryOp.TruncF64ToI32,e)}else{let n=this.options.hasFeature(4);e=t.isLongIntegerValue?o.unary(n?a.UnaryOp.TruncF64ToU64Sat:a.UnaryOp.TruncF64ToU64,e):o.unary(n?a.UnaryOp.TruncF64ToU32Sat:a.UnaryOp.TruncF64ToU32,e)}else assert(0==t.flags,"void type expected"),e=o.drop(e);else n.isIntegerValue&&t.isFloatValue?e=11==t.kind?n.isLongIntegerValue?o.unary(n.isSignedIntegerValue?a.UnaryOp.ConvertI64ToF32:a.UnaryOp.ConvertU64ToF32,e):o.unary(n.isSignedIntegerValue?a.UnaryOp.ConvertI32ToF32:a.UnaryOp.ConvertU32ToF32,e):n.isLongIntegerValue?o.unary(n.isSignedIntegerValue?a.UnaryOp.ConvertI64ToF64:a.UnaryOp.ConvertU64ToF64,e):o.unary(n.isSignedIntegerValue?a.UnaryOp.ConvertI32ToF64:a.UnaryOp.ConvertU32ToF64,e):n.isLongIntegerValue?t.isBooleanValue?e=o.binary(a.BinaryOp.NeI64,e,o.i64(0)):t.isLongIntegerValue||(e=o.unary(a.UnaryOp.WrapI64,e)):t.isLongIntegerValue?e=o.unary(n.isSignedIntegerValue?a.UnaryOp.ExtendI32:a.UnaryOp.ExtendU32,this.ensureSmallIntegerWrap(e,n)):n.isShortIntegerValue?n.size<t.size&&(e=this.ensureSmallIntegerWrap(e,n)):r||this.options.isWasm64||!n.isVaryingIntegerValue||t.isVaryingIntegerValue||this.warning(i.DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,s.range,n.toString(),t.toString());return this.currentType=t,e}compileAssertionExpression(e,n,t){var r=-4&t;switch(e.assertionKind){case p.AssertionKind.PREFIX:case p.AssertionKind.AS:{let n=this.currentFlow,t=this.resolver.resolveType(assert(e.toType),n.actualFunction,d.uniqueMap(n.contextualTypeArguments));return t?this.compileExpression(e.expression,t,2|r):this.module.unreachable()}case p.AssertionKind.NONNULL:{assert(!e.toType);let t=this.compileExpression(e.expression,n.exceptVoid,r),a=this.currentType;return this.currentFlow.isNonnull(t,a)?this.info(i.DiagnosticCode.Expression_is_never_null,e.expression.range):this.options.noAssert||(t=this.makeRuntimeNonNullCheck(t,a,e)),this.currentType=a.nonNullableType,t}case p.AssertionKind.CONST:return this.error(i.DiagnosticCode.Not_implemented_0,e.range,"Const assertion"),this.module.unreachable();default:assert(!1)}return this.module.unreachable()}compileBinaryExpression(e,n,t){var r,a,s,u,p,d,h=this.module,g=e.left,x=e.right,m=!1,_=e.operator;switch(_){case c.Token.LESSTHAN:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.LT);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!0))||!p.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"<",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p,d=this.makeLt(r,s,p),this.currentType=f.Type.bool;break}case c.Token.GREATERTHAN:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.GT);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!0))||!p.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,">",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p,d=this.makeGt(r,s,p),this.currentType=f.Type.bool;break}case c.Token.LESSTHAN_EQUALS:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.LE);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!0))||!p.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"<=",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p,d=this.makeLe(r,s,p),this.currentType=f.Type.bool;break}case c.Token.GREATERTHAN_EQUALS:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.GE);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!0))||!p.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,">=",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p,d=this.makeGe(r,s,p),this.currentType=f.Type.bool;break}case c.Token.EQUALS_EQUALS_EQUALS:case c.Token.EQUALS_EQUALS:if(r=this.compileExpression(g,n),a=this.currentType,_==c.Token.EQUALS_EQUALS){let n=a.getClassOrWrapper(this.program);if(n){let t=n.lookupOverload(o.OperatorKind.EQ);if(t){d=this.compileBinaryOverload(t,g,r,x,e);break}}}if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1)))return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,c.operatorTokenToString(e.operator),a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p,d=this.makeEq(r,s,p,e),this.currentType=f.Type.bool;break;case c.Token.EXCLAMATION_EQUALS_EQUALS:case c.Token.EXCLAMATION_EQUALS:if(r=this.compileExpression(g,n),a=this.currentType,_==c.Token.EXCLAMATION_EQUALS){let n=a.getClass();if(n){let t=n.lookupOverload(o.OperatorKind.NE);if(t){d=this.compileBinaryOverload(t,g,r,x,e);break}}}if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1)))return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,c.operatorTokenToString(e.operator),a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p,d=this.makeNe(r,s,p,e),this.currentType=f.Type.bool;break;case c.Token.EQUALS:return this.compileAssignment(g,x,n);case c.Token.PLUS_EQUALS:m=!0;case c.Token.PLUS:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.ADD);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(m){if(!a.isNumericValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"+",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=p=this.currentType}else{if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1))||!p.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"+",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p}d=this.makeAdd(r,s,p);break}case c.Token.MINUS_EQUALS:m=!0;case c.Token.MINUS:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.SUB);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(m){if(!a.isNumericValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"-",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=p=this.currentType}else{if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1))||!a.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"-",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p}d=this.makeSub(r,s,p);break}case c.Token.ASTERISK_EQUALS:m=!0;case c.Token.ASTERISK:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.MUL);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(m){if(!a.isNumericValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"*",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=p=this.currentType}else{if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1))||!p.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"*",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p}d=this.makeMul(r,s,p);break}case c.Token.ASTERISK_ASTERISK_EQUALS:m=!0;case c.Token.ASTERISK_ASTERISK:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.POW);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(m){if(!a.isNumericValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"**",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=p=this.currentType}else{if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1))||!p.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"**",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p}d=this.makePow(r,s,p,e);break}case c.Token.SLASH_EQUALS:m=!0;case c.Token.SLASH:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.DIV);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(m){if(!a.isNumericValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"/",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=p=this.currentType}else{if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1))||!p.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"/",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p}d=this.makeDiv(r,s,p);break}case c.Token.PERCENT_EQUALS:m=!0;case c.Token.PERCENT:{r=this.compileExpression(g,n);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.REM);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(m){if(!a.isNumericValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"%",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=p=this.currentType}else{if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1))||!p.isNumericValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"%",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p}d=this.makeRem(r,s,p,e);break}case c.Token.LESSTHAN_LESSTHAN_EQUALS:m=!0;case c.Token.LESSTHAN_LESSTHAN:{r=this.compileExpression(g,n.intType);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.BITWISE_SHL);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(!a.isIntegerValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"<<",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=this.currentType,d=this.makeShl(r,s,u);break}case c.Token.GREATERTHAN_GREATERTHAN_EQUALS:m=!0;case c.Token.GREATERTHAN_GREATERTHAN:{r=this.compileExpression(g,n.intType);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.BITWISE_SHR);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(!a.isIntegerValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,">>",a.toString()),this.module.unreachable();s=this.compileExpression(x,a,1),u=this.currentType,d=this.makeShr(r,s,u);break}case c.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:m=!0;case c.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:{r=this.compileExpression(g,n.intType);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.BITWISE_SHR_U);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(!a.isIntegerValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,">>>",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=this.currentType,d=this.makeShru(r,s,u);break}case c.Token.AMPERSAND_EQUALS:m=!0;case c.Token.AMPERSAND:{r=this.compileExpression(g,n.intType);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.BITWISE_AND);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(m){if(!a.isIntegerValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"&",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=p=this.currentType}else{if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1))||!p.isIntegerValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"&",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p}d=this.makeAnd(r,s,p);break}case c.Token.BAR_EQUALS:m=!0;case c.Token.BAR:{r=this.compileExpression(g,n.intType);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.BITWISE_OR);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(m){if(!a.isIntegerValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"|",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=p=this.currentType}else{if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1))||!p.isIntegerValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"|",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p}d=this.makeOr(r,s,p);break}case c.Token.CARET_EQUALS:m=!0;case c.Token.CARET:{r=this.compileExpression(g,n.intType);let t=(a=this.currentType).getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.BITWISE_XOR);if(n){d=this.compileBinaryOverload(n,g,r,x,e);break}}if(m){if(!a.isIntegerValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"^",a.toString()),h.unreachable();s=this.compileExpression(x,a,1),u=p=this.currentType}else{if(s=this.compileExpression(x,a),u=this.currentType,!(p=f.Type.commonDenominator(a,u,!1))||!p.isIntegerValue)return this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"^",a.toString(),u.toString()),this.currentType=n,h.unreachable();r=this.convertExpression(r,a,p,!1,g),a=p,s=this.convertExpression(s,u,p,!1,x),u=p}d=this.makeXor(r,s,p);break}case c.Token.AMPERSAND_AMPERSAND:{let e=this.currentFlow,i=4&t;r=this.compileExpression(g,n.exceptVoid,i),a=this.currentType;let o=e.fork();if(this.currentFlow=o,o.inheritNonnullIfTrue(r),n==f.Type.bool||n==f.Type.void)s=this.compileExpression(x,a,i),u=this.currentType,o.freeScopedLocals(),this.currentFlow=e,d=h.if(this.makeIsTrueish(r,a,g),this.makeIsTrueish(s,u,x),h.i32(0)),this.currentType=f.Type.bool;else{if(s=this.compileExpression(x,a,1|i),u=this.currentType,o.freeScopedLocals(),this.currentFlow=e,d=h.cloneExpression(r,!0,0))d=h.if(this.makeIsTrueish(r,this.currentType,g),s,d);else{let n=e.getTempLocal(a);e.canOverflow(r,a)||e.setLocalFlag(n.index,l.LocalFlags.WRAPPED),e.isNonnull(r,a)&&e.setLocalFlag(n.index,l.LocalFlags.NONNULL),d=h.if(this.makeIsTrueish(h.local_tee(n.index,r,a.isManaged),a,g),s,h.local_get(n.index,a.toNativeType())),e.freeTempLocal(n)}this.currentType=a}break}case c.Token.BAR_BAR:{let e=this.currentFlow,i=4&t;r=this.compileExpression(g,n.exceptVoid,i),a=this.currentType;let o=e.fork();if(this.currentFlow=o,o.inheritNonnullIfFalse(r),n==f.Type.bool||n==f.Type.void)s=this.compileExpression(x,a,i),u=this.currentType,o.freeScopedLocals(),this.currentFlow=e,d=h.if(this.makeIsTrueish(r,a,g),h.i32(1),this.makeIsTrueish(s,u,x)),this.currentType=f.Type.bool;else{if(s=this.compileExpression(x,a,1|i),u=this.currentType,o.freeScopedLocals(),this.currentFlow=e,d=h.cloneExpression(r,!0,0))d=h.if(this.makeIsTrueish(r,a,g),d,s);else{let n=e.getTempLocal(a);e.canOverflow(r,a)||e.setLocalFlag(n.index,l.LocalFlags.WRAPPED),e.isNonnull(r,a)&&e.setLocalFlag(n.index,l.LocalFlags.NONNULL),d=h.if(this.makeIsTrueish(h.local_tee(n.index,r,a.isManaged),a,g),h.local_get(n.index,a.toNativeType()),s),e.freeTempLocal(n)}this.currentType=a}break}default:assert(!1),d=this.module.unreachable()}if(!m)return d;var y=this.resolver,E=y.lookupExpression(g,this.currentFlow);if(!E)return h.unreachable();var T=y.getTypeOfElement(E);return T||(T=f.Type.void),this.currentType.isStrictlyAssignableTo(T)?this.makeAssignment(E,d,this.currentType,x,y.currentThisExpression,y.currentElementExpression,n!=f.Type.void):(this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,e.range,this.currentType.toString(),T.toString()),h.unreachable())}makeLt(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 2:return r.binary(a.BinaryOp.LtI32,e,n);case 3:return r.binary(a.BinaryOp.LtI64,e,n);case 4:return r.binary(this.options.isWasm64?a.BinaryOp.LtI64:a.BinaryOp.LtI32,e,n);case 5:case 6:case 10:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 7:return r.binary(a.BinaryOp.LtU32,e,n);case 9:return r.binary(this.options.isWasm64?a.BinaryOp.LtU64:a.BinaryOp.LtU32,e,n);case 8:return r.binary(a.BinaryOp.LtU64,e,n);case 11:return r.binary(a.BinaryOp.LtF32,e,n);case 12:return r.binary(a.BinaryOp.LtF64,e,n)}return assert(!1),r.unreachable()}makeGt(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 2:return r.binary(a.BinaryOp.GtI32,e,n);case 4:return r.binary(this.options.isWasm64?a.BinaryOp.GtI64:a.BinaryOp.GtI32,e,n);case 3:return r.binary(a.BinaryOp.GtI64,e,n);case 5:case 6:case 10:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 7:return r.binary(a.BinaryOp.GtU32,e,n);case 9:return r.binary(this.options.isWasm64?a.BinaryOp.GtU64:a.BinaryOp.GtU32,e,n);case 8:return r.binary(a.BinaryOp.GtU64,e,n);case 11:return r.binary(a.BinaryOp.GtF32,e,n);case 12:return r.binary(a.BinaryOp.GtF64,e,n)}return assert(!1),r.unreachable()}makeLe(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 2:return r.binary(a.BinaryOp.LeI32,e,n);case 4:return r.binary(this.options.isWasm64?a.BinaryOp.LeI64:a.BinaryOp.LeI32,e,n);case 3:return r.binary(a.BinaryOp.LeI64,e,n);case 5:case 6:case 10:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 7:return r.binary(a.BinaryOp.LeU32,e,n);case 9:return r.binary(this.options.isWasm64?a.BinaryOp.LeU64:a.BinaryOp.LeU32,e,n);case 8:return r.binary(a.BinaryOp.LeU64,e,n);case 11:return r.binary(a.BinaryOp.LeF32,e,n);case 12:return r.binary(a.BinaryOp.LeF64,e,n)}return assert(!1),r.unreachable()}makeGe(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 2:return r.binary(a.BinaryOp.GeI32,e,n);case 4:return r.binary(this.options.isWasm64?a.BinaryOp.GeI64:a.BinaryOp.GeI32,e,n);case 3:return r.binary(a.BinaryOp.GeI64,e,n);case 5:case 6:case 10:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 7:return r.binary(a.BinaryOp.GeU32,e,n);case 9:return r.binary(this.options.isWasm64?a.BinaryOp.GeU64:a.BinaryOp.GeU32,e,n);case 8:return r.binary(a.BinaryOp.GeU64,e,n);case 11:return r.binary(a.BinaryOp.GeF32,e,n);case 12:return r.binary(a.BinaryOp.GeF64,e,n)}return assert(!1),r.unreachable()}makeEq(e,n,t,r){var s=this.module;switch(t.kind){case 0:case 1:case 5:case 6:case 10:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 2:case 7:return s.binary(a.BinaryOp.EqI32,e,n);case 4:case 9:return s.binary(this.options.isWasm64?a.BinaryOp.EqI64:a.BinaryOp.EqI32,e,n);case 3:case 8:return s.binary(a.BinaryOp.EqI64,e,n);case 11:return s.binary(a.BinaryOp.EqF32,e,n);case 12:return s.binary(a.BinaryOp.EqF64,e,n);case 13:return s.unary(a.UnaryOp.AllTrueI8x16,s.binary(a.BinaryOp.EqI8x16,e,n));case 14:case 15:case 16:case 17:return this.error(i.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,r.range,"ref.eq",t.toString()),s.unreachable()}return assert(!1),s.unreachable()}makeNe(e,n,t,r){var s=this.module;switch(t.kind){case 0:case 1:case 5:case 6:case 10:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 2:case 7:return s.binary(a.BinaryOp.NeI32,e,n);case 9:case 4:return s.binary(this.options.isWasm64?a.BinaryOp.NeI64:a.BinaryOp.NeI32,e,n);case 3:case 8:return s.binary(a.BinaryOp.NeI64,e,n);case 11:return s.binary(a.BinaryOp.NeF32,e,n);case 12:return s.binary(a.BinaryOp.NeF64,e,n);case 13:return s.unary(a.UnaryOp.AnyTrueI8x16,s.binary(a.BinaryOp.NeI8x16,e,n));case 14:case 15:case 16:case 17:return this.error(i.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,r.range,"ref.eq",t.toString()),s.unreachable()}return assert(!1),s.unreachable()}makeAdd(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:case 5:case 6:case 10:case 2:case 7:return r.binary(a.BinaryOp.AddI32,e,n);case 9:case 4:return r.binary(this.options.isWasm64?a.BinaryOp.AddI64:a.BinaryOp.AddI32,e,n);case 3:case 8:return r.binary(a.BinaryOp.AddI64,e,n);case 11:return r.binary(a.BinaryOp.AddF32,e,n);case 12:return r.binary(a.BinaryOp.AddF64,e,n)}return assert(!1),r.unreachable()}makeSub(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:case 5:case 6:case 10:case 2:case 7:return r.binary(a.BinaryOp.SubI32,e,n);case 9:case 4:return r.binary(this.options.isWasm64?a.BinaryOp.SubI64:a.BinaryOp.SubI32,e,n);case 3:case 8:return r.binary(a.BinaryOp.SubI64,e,n);case 11:return r.binary(a.BinaryOp.SubF32,e,n);case 12:return r.binary(a.BinaryOp.SubF64,e,n)}return assert(!1),r.unreachable()}makeMul(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:case 5:case 6:case 10:case 2:case 7:return r.binary(a.BinaryOp.MulI32,e,n);case 9:case 4:return r.binary(this.options.isWasm64?a.BinaryOp.MulI64:a.BinaryOp.MulI32,e,n);case 3:case 8:return r.binary(a.BinaryOp.MulI64,e,n);case 11:return r.binary(a.BinaryOp.MulF32,e,n);case 12:return r.binary(a.BinaryOp.MulF64,e,n)}return assert(!1),r.unreachable()}makePow(e,n,t,r){let l=this.module;switch(t.kind){case 10:return l.select(l.i32(1),l.binary(a.BinaryOp.EqI32,n,l.i32(0)),e);case 0:case 5:case 1:case 6:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 2:case 7:{let a=this.i32PowInstance;if(!a){let e=this.program.lookup(s.CommonNames.ipow32);if(!e)return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"ipow32"),l.unreachable();assert(e.kind==o.ElementKind.FUNCTION_PROTOTYPE),this.i32PowInstance=a=this.resolver.resolveFunction(e,null)}if(!a||!this.compileFunction(a))return l.unreachable();let u=this.makeCallDirect(a,[e,n],r);return t.size<32&&(u=this.ensureSmallIntegerWrap(u,t)),u}case 3:case 8:{let t=this.i64PowInstance;if(!t){let e=this.program.lookup(s.CommonNames.ipow64);if(!e)return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"ipow64"),l.unreachable();assert(e.kind==o.ElementKind.FUNCTION_PROTOTYPE),this.i64PowInstance=t=this.resolver.resolveFunction(e,null)}return t&&this.compileFunction(t)?this.makeCallDirect(t,[e,n],r):l.unreachable()}case 4:case 9:{let t=this.options.isWasm64,a=t?this.i64PowInstance:this.i32PowInstance;if(!a){let e=this.program.lookup(t?s.CommonNames.ipow64:s.CommonNames.ipow32);if(!e)return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,t?"ipow64":"ipow32"),l.unreachable();assert(e.kind==o.ElementKind.FUNCTION_PROTOTYPE),a=this.resolver.resolveFunction(e,null),t?this.i64PowInstance=a:this.i32PowInstance=a}return a&&this.compileFunction(a)?this.makeCallDirect(a,[e,n],r):l.unreachable()}case 11:{let t=this.f32PowInstance;if(!t){let e=this.program.lookup(s.CommonNames.Mathf);if(!e)return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"Mathf"),l.unreachable();let n=e.members;if(!n||!n.has(s.CommonNames.pow))return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"Mathf.pow"),l.unreachable();let a=assert(n.get(s.CommonNames.pow));assert(a.kind==o.ElementKind.FUNCTION_PROTOTYPE),this.f32PowInstance=t=this.resolver.resolveFunction(a,null)}return t&&this.compileFunction(t)?this.makeCallDirect(t,[e,n],r):l.unreachable()}case 12:{let t=this.f64PowInstance;if(!t){let e=this.program.lookup(s.CommonNames.Math);if(!e)return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"Math"),l.unreachable();let n=e.members;if(!n||!n.has(s.CommonNames.pow))return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"Math.pow"),l.unreachable();let a=assert(n.get(s.CommonNames.pow));assert(a.kind==o.ElementKind.FUNCTION_PROTOTYPE),this.f64PowInstance=t=this.resolver.resolveFunction(a,null)}return t&&this.compileFunction(t)?this.makeCallDirect(t,[e,n],r):l.unreachable()}}return assert(!1),l.unreachable()}makeDiv(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 2:return r.binary(a.BinaryOp.DivI32,e,n);case 4:return r.binary(this.options.isWasm64?a.BinaryOp.DivI64:a.BinaryOp.DivI32,e,n);case 3:return r.binary(a.BinaryOp.DivI64,e,n);case 5:case 6:case 10:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 7:return r.binary(a.BinaryOp.DivU32,e,n);case 9:return r.binary(this.options.isWasm64?a.BinaryOp.DivU64:a.BinaryOp.DivU32,e,n);case 8:return r.binary(a.BinaryOp.DivU64,e,n);case 11:return r.binary(a.BinaryOp.DivF32,e,n);case 12:return r.binary(a.BinaryOp.DivF64,e,n)}return assert(!1),r.unreachable()}makeRem(e,n,t,r){var l=this.module;switch(t.kind){case 0:case 1:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 2:return l.binary(a.BinaryOp.RemI32,e,n);case 4:return l.binary(this.options.isWasm64?a.BinaryOp.RemI64:a.BinaryOp.RemI32,e,n);case 3:return l.binary(a.BinaryOp.RemI64,e,n);case 5:case 6:case 10:e=this.ensureSmallIntegerWrap(e,t),n=this.ensureSmallIntegerWrap(n,t);case 7:return l.binary(a.BinaryOp.RemU32,e,n);case 9:return l.binary(this.options.isWasm64?a.BinaryOp.RemU64:a.BinaryOp.RemU32,e,n);case 8:return l.binary(a.BinaryOp.RemU64,e,n);case 11:{let t=this.f32ModInstance;if(!t){let e=this.program.lookup(s.CommonNames.Mathf);if(!e)return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"Mathf"),l.unreachable();let n=e.members;if(!n||!n.has(s.CommonNames.mod))return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"Mathf.mod"),l.unreachable();let a=assert(n.get(s.CommonNames.mod));assert(a.kind==o.ElementKind.FUNCTION_PROTOTYPE),this.f32ModInstance=t=this.resolver.resolveFunction(a,null)}return t&&this.compileFunction(t)?this.makeCallDirect(t,[e,n],r):l.unreachable()}case 12:{let t=this.f64ModInstance;if(!t){let e=this.program.lookup(s.CommonNames.Math);if(!e)return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"Math"),l.unreachable();let n=e.members;if(!n||!n.has(s.CommonNames.mod))return this.error(i.DiagnosticCode.Cannot_find_name_0,r.range,"Math.mod"),l.unreachable();let a=assert(n.get(s.CommonNames.mod));assert(a.kind==o.ElementKind.FUNCTION_PROTOTYPE),this.f64ModInstance=t=this.resolver.resolveFunction(a,null)}return t&&this.compileFunction(t)?this.makeCallDirect(t,[e,n],r):l.unreachable()}}return assert(!1),l.unreachable()}makeShl(e,n,t){var r=this.module;switch(t.kind){case 10:return e;case 0:case 1:case 5:case 6:return r.binary(a.BinaryOp.ShlI32,e,r.binary(a.BinaryOp.AndI32,n,r.i32(t.size-1)));case 2:case 7:return r.binary(a.BinaryOp.ShlI32,e,n);case 3:case 8:return r.binary(a.BinaryOp.ShlI64,e,n);case 9:case 4:return r.binary(this.options.isWasm64?a.BinaryOp.ShlI64:a.BinaryOp.ShlI32,e,n)}return assert(!1),r.unreachable()}makeShr(e,n,t){var r=this.module;switch(t.kind){case 10:return e;case 0:case 1:return r.binary(a.BinaryOp.ShrI32,this.ensureSmallIntegerWrap(e,t),r.binary(a.BinaryOp.AndI32,n,r.i32(t.size-1)));case 5:case 6:return r.binary(a.BinaryOp.ShrU32,this.ensureSmallIntegerWrap(e,t),r.binary(a.BinaryOp.AndI32,n,r.i32(t.size-1)));case 2:return r.binary(a.BinaryOp.ShrI32,e,n);case 3:return r.binary(a.BinaryOp.ShrI64,e,n);case 4:return r.binary(this.options.isWasm64?a.BinaryOp.ShrI64:a.BinaryOp.ShrI32,e,n);case 7:return r.binary(a.BinaryOp.ShrU32,e,n);case 8:return r.binary(a.BinaryOp.ShrU64,e,n);case 9:return r.binary(this.options.isWasm64?a.BinaryOp.ShrU64:a.BinaryOp.ShrU32,e,n)}return assert(!1),r.unreachable()}makeShru(e,n,t){var r=this.module;switch(t.kind){case 10:return e;case 0:case 1:case 5:case 6:return r.binary(a.BinaryOp.ShrU32,this.ensureSmallIntegerWrap(e,t),r.binary(a.BinaryOp.AndI32,n,r.i32(t.size-1)));case 2:case 7:return r.binary(a.BinaryOp.ShrU32,e,n);case 3:case 8:return r.binary(a.BinaryOp.ShrU64,e,n);case 9:case 4:return r.binary(this.options.isWasm64?a.BinaryOp.ShrU64:a.BinaryOp.ShrU32,e,n)}return assert(!1),r.unreachable()}makeAnd(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:case 2:case 5:case 6:case 10:case 7:return r.binary(a.BinaryOp.AndI32,e,n);case 3:case 8:return r.binary(a.BinaryOp.AndI64,e,n);case 9:case 4:return r.binary(this.options.isWasm64?a.BinaryOp.AndI64:a.BinaryOp.AndI32,e,n)}return assert(!1),r.unreachable()}makeOr(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:case 5:case 6:case 10:return r.binary(a.BinaryOp.OrI32,e,n);case 2:case 7:return r.binary(a.BinaryOp.OrI32,e,n);case 3:case 8:return r.binary(a.BinaryOp.OrI64,e,n);case 9:case 4:return r.binary(this.options.isWasm64?a.BinaryOp.OrI64:a.BinaryOp.OrI32,e,n)}return assert(!1),r.unreachable()}makeXor(e,n,t){var r=this.module;switch(t.kind){case 0:case 1:case 5:case 6:case 10:return r.binary(a.BinaryOp.XorI32,e,n);case 2:case 7:return r.binary(a.BinaryOp.XorI32,e,n);case 3:case 8:return r.binary(a.BinaryOp.XorI64,e,n);case 4:case 9:return r.binary(this.options.isWasm64?a.BinaryOp.XorI64:a.BinaryOp.XorI32,e,n)}return assert(!1),r.unreachable()}compileUnaryOverload(e,n,t,r){return this.makeCallDirect(e,[t],r,!1)}compileBinaryOverload(e,n,t,r,i){var a;if(e.is(s.CommonFlags.INSTANCE)){let n=assert(e.parent);assert(n.kind==o.ElementKind.CLASS),a=e.signature.parameterTypes[0]}else a=e.signature.parameterTypes[1];var l=this.compileExpression(r,a,1);return this.makeCallDirect(e,[t,l],i)}compileAssignment(e,n,t){var r=this.program.resolver,a=this.currentFlow,s=r.lookupExpression(e,a);if(!s)return this.module.unreachable();var l,u=r.currentThisExpression,c=r.currentElementExpression;switch(s.kind){case o.ElementKind.GLOBAL:if(!this.compileGlobal(s))return this.module.unreachable();case o.ElementKind.LOCAL:case o.ElementKind.FIELD:if(this.pendingElements.has(s))return this.error(i.DiagnosticCode.Variable_0_used_before_its_declaration,e.range,s.internalName),this.module.unreachable();l=s.type,s.hasDecorator(o.DecoratorFlags.UNSAFE)&&this.checkUnsafe(e);break;case o.ElementKind.PROPERTY_PROTOTYPE:{let e=s,n=r.resolveProperty(e);if(!n)return this.module.unreachable();s=n}case o.ElementKind.PROPERTY:{let n=s,t=n.setterInstance;if(!t)return this.error(i.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,e.range,n.internalName),this.module.unreachable();assert(1==t.signature.parameterTypes.length),l=t.signature.parameterTypes[0],t.hasDecorator(o.DecoratorFlags.UNSAFE)&&this.checkUnsafe(e);break}case o.ElementKind.INDEXSIGNATURE:{let n=s.parent;assert(n.kind==o.ElementKind.CLASS);let t=n,r=a.is(32768),u=t.lookupOverload(o.OperatorKind.INDEXED_SET,r);if(!u)return t.lookupOverload(o.OperatorKind.INDEXED_GET,r)?this.error(i.DiagnosticCode.Index_signature_in_type_0_only_permits_reading,e.range,t.internalName):this.error(i.DiagnosticCode.Index_signature_is_missing_in_type_0,e.range,t.internalName),this.module.unreachable();assert(2==u.signature.parameterTypes.length),l=u.signature.parameterTypes[1],u.hasDecorator(o.DecoratorFlags.UNSAFE)&&this.checkUnsafe(e),!r&&this.options.pedantic&&this.pedantic(i.DiagnosticCode.Indexed_access_may_involve_bounds_checking,e.range);break}default:return assert(!1),this.module.unreachable()}assert(l!=f.Type.void);var p=this.compileExpression(n,l),d=this.currentType;return this.makeAssignment(s,this.convertExpression(p,d,l,!1,n),d,n,u,c,t!=f.Type.void)}makeAssignment(e,n,t,r,a,u,c){var d=this.module,h=this.currentFlow;switch(e.kind){case o.ElementKind.LOCAL:{let a=e;return h.isLocalFlag(a.index,l.LocalFlags.CONSTANT,!0)?(this.error(i.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,r.range,e.internalName),this.currentType=c?a.type:f.Type.void,d.unreachable()):this.makeLocalAssignment(a,n,t,c)}case o.ElementKind.GLOBAL:{let a=e;return this.compileGlobal(a)?e.isAny(s.CommonFlags.CONST|s.CommonFlags.READONLY)?(this.error(i.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,r.range,e.internalName),this.currentType=c?a.type:f.Type.void,d.unreachable()):this.makeGlobalAssignment(a,n,t,c):d.unreachable()}case o.ElementKind.FIELD:{let u=e,f=u.initializerNode,g=h.actualFunction.is(s.CommonFlags.CONSTRUCTOR);if(u.is(s.CommonFlags.READONLY)&&(!g||null!==f))return this.error(i.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,r.range,u.internalName),d.unreachable();a=assert(a),g&&a.kind==p.NodeKind.THIS&&h.setThisFieldFlag(u,l.FieldFlags.INITIALIZED);let x=u.parent;return assert(x.kind==o.ElementKind.CLASS),this.makeFieldAssignment(u,n,t,this.compileExpression(a,x.type,33),c)}case o.ElementKind.PROPERTY:{let t=e,o=t.setterInstance;if(!o)return this.error(i.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,r.range,e.internalName),d.unreachable();if(assert(1==o.signature.parameterTypes.length),t.is(s.CommonFlags.INSTANCE)){let t=assert(o.signature.thisType),i=this.compileExpression(assert(a),t,33);if(!c)return this.makeCallDirect(o,[i,n],r);let s=assert(e.getterInstance);assert(s.signature.thisType==t);let l=s.signature.returnType,u=l.toNativeType(),p=h.getTempLocal(l),f=d.block(null,[this.makeCallDirect(o,[d.local_tee(p.index,i,l.isManaged),n],r),this.makeCallDirect(s,[d.local_get(p.index,u)],r)],u);return h.freeTempLocal(p),f}{if(!c)return this.makeCallDirect(o,[n],r);let t=assert(e.getterInstance);return d.block(null,[this.makeCallDirect(o,[n],r),this.makeCallDirect(t,null,r)],t.signature.returnType.toNativeType())}}case o.ElementKind.INDEXSIGNATURE:{let t=e.parent;assert(t.kind==o.ElementKind.CLASS);let s=t;assert(s.kind==o.ElementKind.CLASS);let l=h.is(32768),p=s.lookupOverload(o.OperatorKind.INDEXED_GET,l);if(!p)return this.error(i.DiagnosticCode.Index_signature_is_missing_in_type_0,r.range,s.internalName),d.unreachable();let g=s.lookupOverload(o.OperatorKind.INDEXED_SET,l);if(!g)return this.error(i.DiagnosticCode.Index_signature_in_type_0_only_permits_reading,r.range,s.internalName),this.currentType=c?p.signature.returnType:f.Type.void,d.unreachable();assert(2==g.signature.parameterTypes.length);let x=s.type,m=this.compileExpression(assert(a),x,33),_=this.compileExpression(assert(u),f.Type.i32,1),y=this.currentType;if(c){let e=h.getTempLocal(x),t=h.getTempLocal(y),i=p.signature.returnType;h.freeTempLocal(e);let a=d.block(null,[this.makeCallDirect(g,[d.local_tee(e.index,m,x.isManaged),d.local_tee(t.index,_,y.isManaged),n],r),this.makeCallDirect(p,[d.local_get(e.index,e.type.toNativeType()),d.local_get(t.index,t.type.toNativeType())],r)],i.toNativeType());return h.freeTempLocal(t),h.freeTempLocal(e),a}return this.makeCallDirect(g,[m,_,n],r)}}return assert(!1),d.unreachable()}makeLocalAssignment(e,n,t,r){var i=this.module,a=this.currentFlow,s=e.type;assert(s!=f.Type.void);var o=e.index;return s.isNullableReference&&(!t.isNullableReference||a.isNonnull(n,s)?a.setLocalFlag(o,l.LocalFlags.NONNULL):a.unsetLocalFlag(o,l.LocalFlags.NONNULL)),a.setLocalFlag(o,l.LocalFlags.INITIALIZED),s.isShortIntegerValue&&(a.canOverflow(n,s)?a.unsetLocalFlag(o,l.LocalFlags.WRAPPED):a.setLocalFlag(o,l.LocalFlags.WRAPPED)),r?(this.currentType=s,i.local_tee(o,n,s.isManaged)):(this.currentType=f.Type.void,i.local_set(o,n,s.isManaged))}makeGlobalAssignment(e,n,t,r){var i=this.module,a=e.type;assert(a!=f.Type.void);var s=a.toNativeType();return n=this.ensureSmallIntegerWrap(n,a),r?(this.currentType=a,i.block(null,[i.global_set(e.internalName,n),i.global_get(e.internalName,s)],s)):(this.currentType=f.Type.void,i.global_set(e.internalName,n))}makeFieldAssignment(e,n,t,r,i){var l=this.module,u=this.currentFlow,c=e.type,p=c.toNativeType();assert(e.parent.kind==o.ElementKind.CLASS);var d=e.parent.type;if(!e.is(s.CommonFlags.COMPILED)){e.set(s.CommonFlags.COMPILED);let n=e.typeNode;n&&this.checkTypeSupported(e.type,n)}if(i){this.compileField(e);let t=u.getTempLocal(d),i=l.block(null,[l.call(e.internalSetterName,[l.local_tee(t.index,r,d.isManaged),n],a.NativeType.None),l.call(e.internalGetterName,[l.local_get(t.index,d.toNativeType())],p)],p);return u.freeTempLocal(t),this.currentType=c,i}{this.compileFieldSetter(e);let t=l.call(e.internalSetterName,[r,n],a.NativeType.None);return this.currentType=f.Type.void,t}}compileCallExpression(e,n,t){var r=this.module,a=this.currentFlow;if(e.expression.kind==p.NodeKind.SUPER){let n=this.currentFlow,t=n.actualFunction;if(!t.is(s.CommonFlags.CONSTRUCTOR))return this.error(i.DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,e.range),r.unreachable();let a=assert(t.parent);assert(a.kind==o.ElementKind.CLASS);let l=a,u=l.base;if(!u)return this.error(i.DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,e.expression.range),r.unreachable();let c=assert(n.lookupLocal(s.CommonNames.this_)),p=this.options.nativeSizeType,d=this.ensureConstructor(u,e);this.checkFieldInitialization(u,e);let h=this.compileCallDirect(d,e.args,e,r.local_get(c.index,p));return n.isAny(8256)?(this.error(i.DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,e.range),r.unreachable()):(n.set(192),this.currentType=f.Type.void,r.local_set(c.index,h,l.type.isManaged))}var l=this.resolver.lookupExpression(e.expression,a);if(!l)return r.unreachable();var u,c,d=this.resolver.currentThisExpression;switch(l.kind){case o.ElementKind.FUNCTION_PROTOTYPE:{let t=l;if(t.hasDecorator(o.DecoratorFlags.BUILTIN))return this.compileCallExpressionBuiltin(t,e,n);let r=this.resolver.maybeInferCall(e,t,a);if(!r)return this.module.unreachable();l=r}case o.ElementKind.FUNCTION:{let n=l,r=0;return n.is(s.CommonFlags.INSTANCE)&&(r=this.compileExpression(assert(d),assert(n.signature.thisType),33)),this.compileCallDirect(n,e.args,e,r,t)}case o.ElementKind.LOCAL:{let n=l;if(u=n.type.signatureReference){if(n.is(s.CommonFlags.INLINED)){let e=n.constantIntegerValue;this.options.isWasm64?c=r.i64(i64_low(e),i64_high(e)):(assert(!i64_high(e)),c=r.i32(i64_low(e)))}else c=r.local_get(n.index,this.options.nativeSizeType);break}return this.error(i.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,e.range,n.type.toString()),r.unreachable()}case o.ElementKind.GLOBAL:{let n=l;if(u=n.type.signatureReference){c=r.global_get(n.internalName,n.type.toNativeType());break}return this.error(i.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,e.range,n.type.toString()),r.unreachable()}case o.ElementKind.FIELD:{let n=l,t=n.type;if(u=t.signatureReference){let e=n.parent;assert(e.kind==o.ElementKind.CLASS);let t=this.options.usizeType;c=r.load(t.byteSize,!1,this.compileExpression(assert(d),e.type,33),t.toNativeType(),n.memoryOffset);break}return this.error(i.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,e.range,t.toString()),r.unreachable()}case o.ElementKind.PROPERTY_PROTOTYPE:{let e=this.resolver.resolveProperty(l);if(!e)return r.unreachable();l=e}case o.ElementKind.PROPERTY:{let n=l,t=assert(n.getterInstance),a=0;if(n.is(s.CommonFlags.INSTANCE)&&(a=this.compileExpression(assert(d),assert(t.signature.thisType),33)),c=this.compileCallDirect(t,[],e.expression,a),!(u=this.currentType.signatureReference))return this.error(i.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,e.range,this.currentType.toString()),r.unreachable();break}case o.ElementKind.CLASS:{let n=l.getTypeArgumentsTo(this.program.functionPrototype);if(null!==n&&n.length>0){let t=n[0];u=t.getSignature(),c=this.compileExpression(e.expression,t,1);break}}default:{let n=this.resolver.getTypeOfElement(l);return n?this.error(i.DiagnosticCode.Type_0_has_no_call_signatures,e.range,n.toString()):this.error(i.DiagnosticCode.Expression_cannot_be_represented_by_a_type,e.range),r.unreachable()}}return this.compileCallIndirect(assert(u),c,e.args,e,0,n==f.Type.void)}compileCallExpressionBuiltin(e,n,t){e.hasDecorator(o.DecoratorFlags.UNSAFE)&&this.checkUnsafe(n);var a=null,l=e.typeParameterNodes,u=n.typeArguments;n.typeArguments&&(e.is(s.CommonFlags.GENERIC)||this.error(i.DiagnosticCode.Type_0_is_not_generic,n.range,e.internalName),a=this.resolver.resolveTypeArguments(assert(l),u,this.currentFlow.actualFunction.parent,d.uniqueMap(this.currentFlow.contextualTypeArguments),n));var c=n.expression,f=new r.BuiltinContext(this,e,a,n.args,c.kind==p.NodeKind.PROPERTYACCESS?c.expression:null,t,n,!1),h=e.internalName;if(r.builtins.has(h))return assert(r.builtins.get(h))(f);var g=e.parent;if(g.kind==o.ElementKind.CLASS&&g.prototype==this.program.functionPrototype){let n=e.name;if(r.function_builtins.has(n))return assert(r.function_builtins.get(n))(f)}return assert(!1),this.module.unreachable()}checkCallSignature(e,n,t,r){if(t!=(null!=e.thisType))return this.error(i.DiagnosticCode.The_this_types_of_each_signature_are_incompatible,r.range),!1;var a=e.hasRest;if(a)return this.error(i.DiagnosticCode.Not_implemented_0,r.range,"Rest parameters"),!1;var s=e.requiredParameters,o=e.parameterTypes.length;return n<s?(this.error(s<o?i.DiagnosticCode.Expected_at_least_0_arguments_but_got_1:i.DiagnosticCode.Expected_0_arguments_but_got_1,r.range,s.toString(),n.toString()),!1):!(n>o&&!a&&(this.error(i.DiagnosticCode.Expected_0_arguments_but_got_1,r.range,o.toString(),n.toString()),1))}checkUnsafe(e,n=null){this.options.noUnsafe&&!e.range.source.isLibrary&&(n?this.errorRelated(i.DiagnosticCode.Operation_is_unsafe,e.range,n.range):this.error(i.DiagnosticCode.Operation_is_unsafe,e.range))}compileCallDirect(e,n,t,r=0,a=0){var l=n.length,u=e.signature;if(!this.checkCallSignature(u,l,0!=r,t))return this.currentType=u.returnType,this.module.unreachable();e.hasDecorator(o.DecoratorFlags.UNSAFE)&&this.checkUnsafe(t);let c=this.currentFlow.actualFunction;if(c.is(s.CommonFlags.CONSTRUCTOR)&&t.isAccessOnThis){let e=c.parent;assert(e.kind==o.ElementKind.CLASS),this.checkFieldInitialization(e,t)}if(e.hasDecorator(o.DecoratorFlags.INLINE)&&(!e.is(s.CommonFlags.VIRTUAL)||t.isAccessOnSuper)){assert(!e.is(s.CommonFlags.STUB));let o=this.inlineStack;if(!o.includes(e)){o.push(e);let t=u.parameterTypes;assert(l<=t.length);let i=new Array(l);for(let e=0;e<l;++e)i[e]=this.compileExpression(n[e],t[e],1);let s=this.makeCallInline(e,i,r,0!=(8&a));return o.pop(),s}this.warning(i.DiagnosticCode.Function_0_cannot_be_inlined_into_itself,t.range,e.internalName)}var p=r?l+1:l,f=new Array(p),d=0;r&&(f[0]=r,d=1);var h=u.parameterTypes;for(let e=0;e<l;++e,++d){let t=h[e],r=this.compileExpression(n[e],t,1);f[d]=r}return assert(d==p),this.makeCallDirect(e,f,t,0!=(8&a))}makeCallInline(e,n,t=0,r=!1){var i=this.module,a=n?n.length:0,u=e.signature.parameterTypes,c=u.length,p=this.currentFlow,f=l.Flow.createInline(p.parentFunction,e),d=[],h=new Set;for(let t=a-1;t>=0;--t){let r=n[t],a=u[t],s=f.addScopedLocal(e.getParameterName(t),a,h);l.findUsedLocals(r,h),p.canOverflow(r,a)||f.setLocalFlag(s.index,l.LocalFlags.WRAPPED),f.isNonnull(r,a)&&f.setLocalFlag(s.index,l.LocalFlags.NONNULL),d.unshift(i.local_set(s.index,r,a.isManaged))}if(t){let n=assert(e.parent);assert(n.kind==o.ElementKind.CLASS);let r=n,a=assert(e.signature.thisType),l=f.addScopedLocal(s.CommonNames.this_,a,h);d.unshift(i.local_set(l.index,t,a.isManaged));let u=r.base;u&&f.addScopedAlias(s.CommonNames.super_,u.type,l.index)}else assert(!e.signature.thisType);this.currentFlow=f;for(let n=a;n<c;++n){let t=u[n],r=this.compileExpression(assert(e.prototype.functionTypeNode.parameters[n].initializer),t,1),i=f.addScopedLocal(e.getParameterName(n),t);d.push(this.makeLocalAssignment(i,r,t,!1))}if(this.compileFunctionBody(e,d),e.is(s.CommonFlags.CONSTRUCTOR)){let n=e.parent;assert(n.kind==o.ElementKind.CLASS),this.checkFieldInitializationInFlow(n,f)}f.freeScopedLocals();var g=f.returnType;return this.currentFlow=p,this.currentType=g,i.block(f.inlineReturnLabel,d,g.toNativeType())}ensureArgumentsLength(){var e=r.BuiltinNames.argumentsLength;if(!this.builtinArgumentsLength){let n=this.module;this.builtinArgumentsLength=n.addGlobal(e,a.NativeType.I32,!0,n.i32(0))}return e}ensureVarargsStub(e){var n=e.varargsStub;if(n)return n;var t=e.signature,r=t.parameterTypes,o=e.prototype.functionTypeNode.parameters,l=t.returnType,u=e.is(s.CommonFlags.INSTANCE),c=t.requiredParameters,p=c,d=r.length,h=d;u&&(++p,++h);var g=assert(h-p),x=new Array(p),m=0,_=new Array,y=this.module,E=t.thisType;E&&(x[0]=y.local_get(0,E.toNativeType()),m=1);for(let e=0;e<c;++e,++m){let n=r[e];x[m]=y.local_get(m,n.toNativeType())}assert(m==p),(n=e.newStub("varargs")).signature.requiredParameters=d,e.varargsStub=n;var T=this.currentFlow,b=n.flow;this.currentFlow=b;var v=g+1,A=new Array(v),F="of"+g.toString();for(let e=0;e<v;++e){let n=e.toString()+F;A[e]=n}var C=this.ensureArgumentsLength(),I=y.block(A[0],[y.block("outOfRange",[y.switch(A,"outOfRange",c?y.binary(a.BinaryOp.SubI32,y.global_get(C,a.NativeType.I32),y.i32(c)):y.global_get(C,a.NativeType.I32))]),y.unreachable()]);for(let e=0;e<g;++e,++m){let n,t=r[c+e],a=o[c+e],s=a.initializer;s?(n=this.compileExpression(s,t,1),n=y.local_set(m,n,t.isManaged)):(this.error(i.DiagnosticCode.Optional_parameter_must_have_an_initializer,a.range),n=y.unreachable()),I=y.block(A[e+1],[I,n]),x[m]=y.local_get(m,t.toNativeType())}assert(m==h),_.push(I),_.push(y.call(e.internalName,x,l.toNativeType())),b.freeScopedLocals(),this.currentFlow=T;var S=y.addFunction(n.internalName,n.signature.nativeParams,n.signature.nativeResults,f.typesToNativeTypes(n.additionalLocals),y.flatten(_,l.toNativeType()));return n.set(s.CommonFlags.COMPILED),n.finalize(y,S),n}ensureVirtualStub(e){var n=e.virtualStub;if(n)return n;n=e.newStub("virtual"),e.virtualStub=n;var t=this.module;return n.ref=t.addFunction(n.internalName,n.signature.nativeParams,n.signature.nativeResults,null,t.unreachable()),this.virtualCalls.add(e),n}finalizeVirtualStub(e){var n=this.ensureVirtualStub(e);if(!n.is(s.CommonFlags.COMPILED)){var t,r=assert(e.prototype.overloads),l=this.module,u=this.options.usizeType.toNativeType(),c=e.signature.parameterTypes,p=e.signature.returnType,d=c.length,h=1+c.length,g=new a.SwitchBuilder(this.module,l.load(4,!1,l.binary(u==a.NativeType.I64?a.BinaryOp.SubI64:a.BinaryOp.SubI32,l.local_get(0,u),u==a.NativeType.I64?l.i64(8):l.i32(8)),a.NativeType.I32));for(let n=Set_values(r),t=0,a=n.length;t<a;++t){let r=n[t];assert(!r.isBound);let a,h=r.parent,x=h.kind==o.ElementKind.PROPERTY_PROTOTYPE;if(x){let e=h.parent;assert(e.kind==o.ElementKind.CLASS_PROTOTYPE),a=e.instances}else assert(h.kind==o.ElementKind.CLASS_PROTOTYPE),a=h.instances;if(a)for(let n=Map_values(a),t=0,m=n.length;t<m;++t){let a,m=n[t];if(x){let n=assert(m.members.get(h.name));assert(n.kind==o.ElementKind.PROPERTY_PROTOTYPE);let t=this.resolver.resolveProperty(n);if(!t)continue;e.is(s.CommonFlags.GET)?a=t.getterInstance:(assert(e.is(s.CommonFlags.SET)),a=t.setterInstance)}else{let n=assert(m.members.get(r.name));assert(n.kind==o.ElementKind.FUNCTION_PROTOTYPE),a=this.resolver.resolveFunction(n,e.typeArguments)}if(!a||!this.compileFunction(a))continue;let _=a.type,y=e.type;if(!_.isAssignableTo(y)){this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,a.identifierNode.range,_.toString(),y.toString());continue}let E=a.signature,T=E.parameterTypes,b=T.length,v=new Array(1+b);v[0]=l.local_get(0,u);for(let e=1;e<=d;++e)v[e]=l.local_get(e,c[e-1].toNativeType());let A=!1;for(let e=d;e<b;++e)v[1+e]=this.makeZero(T[e],a.declaration),A=!0;let F=A?this.ensureVarargsStub(a).internalName:a.internalName,C=E.returnType.toNativeType(),I=new Array;A&&I.push(l.global_set(this.ensureArgumentsLength(),l.i32(d))),p==f.Type.void?(I.push(l.call(F,v,C)),I.push(l.return())):I.push(l.return(l.call(F,v,C))),g.addCase(m.id,I);let S=m.getAllExtendees(x?h.name:e.prototype.name);for(let e=Set_values(S),n=0,t=e.length;n<t;++n){let t=e[n];g.addCase(t.id,I)}}}if(e.prototype.bodyNode){let n=new Array(d);n[0]=l.local_get(0,u);for(let e=0,t=c.length;e<t;++e)n[1+e]=l.local_get(1+e,c[e].toNativeType());t=l.call(e.internalName,n,p.toNativeType())}else t=l.unreachable();n.ref&&l.removeFunction(n.internalName),n.ref=l.addFunction(n.internalName,n.signature.nativeParams,n.signature.nativeResults,[a.NativeType.I32],l.block(null,[g.render(h),t],p.toNativeType())),n.set(s.CommonFlags.COMPILED)}}operandsTostack(e,n){if(this.options.stackSize){var t=this.module,r=0,i=e.thisType;if(i){if(i.isManaged){let e=n[0],i=t.runExpression(e,a.ExpressionRunnerFlags.Default);a.isConstZero(i)||(n[r]=t.tostack(e))}++r}var s=0,o=e.parameterTypes;for(assert(o.length>=n.length-r);r<n.length;){if(o[s].isManaged){let e=n[r],i=t.runExpression(e,a.ExpressionRunnerFlags.Default);a.isConstZero(i)||(n[r]=t.tostack(e))}++r,++s}}}makeCallDirect(e,n,t,r=!1){if(e.hasDecorator(o.DecoratorFlags.INLINE))if(e.is(s.CommonFlags.VIRTUAL))this.warning(i.DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,t.range,e.internalName);else{assert(!e.is(s.CommonFlags.STUB));let a=this.inlineStack;if(!a.includes(e)){let t;if(a.push(e),e.is(s.CommonFlags.INSTANCE)){let i=assert(n);assert(i.length),t=this.makeCallInline(e,i.slice(1),i[0],r)}else t=this.makeCallInline(e,n,0,r);return a.pop(),t}this.warning(i.DiagnosticCode.Function_0_cannot_be_inlined_into_itself,t.range,e.internalName)}var l=this.module,c=n?n.length:0,p=c,d=e.signature.requiredParameters,h=e.signature.parameterTypes,g=h.length,x=g;if(e.is(s.CommonFlags.INSTANCE)&&(++d,++x,--p),assert(c>=d),!this.compileFunction(e))return l.unreachable();var m=e.signature.returnType;if(c<x){n||((n=new Array(x)).length=0);let t=e.prototype.functionTypeNode.parameters;assert(t.length==h.length);let i=!0;for(let r=p;r<g;++r){let a=t[r].initializer;if(a){if(a.compilesToConst){n.push(this.compileExpression(a,h[r],1));continue}let t=this.resolver.lookupExpression(a,e.flow,h[r],u.ReportMode.SWALLOW);if(t&&t.kind==o.ElementKind.GLOBAL){let e=t;if(this.compileGlobal(e)){e.is(s.CommonFlags.INLINED)?n.push(this.compileInlineConstant(e,h[r],1)):n.push(this.convertExpression(l.global_get(e.internalName,e.type.toNativeType()),e.type,h[r],!1,a));continue}}}n.push(this.makeZero(h[r],e.declaration)),i=!1}if(!i&&!e.is(s.CommonFlags.MODULE_IMPORT)){let t=e;if(e=this.ensureVarargsStub(e),!this.compileFunction(e))return l.unreachable();e.flow.flags=t.flow.flags;let i=m.toNativeType(),s=n[x-1];assert(!(a.getSideEffects(s)&a.SideEffects.WritesGlobal));let o=h[g-1];n[x-1]=l.block(null,[l.global_set(this.ensureArgumentsLength(),l.i32(p)),s],o.toNativeType()),this.operandsTostack(e.signature,n);let u=l.call(e.internalName,n,i);return m!=f.Type.void&&r?(u=l.drop(u),this.currentType=f.Type.void):this.currentType=m,u}}e.is(s.CommonFlags.VIRTUAL)&&!t.isAccessOnSuper&&(e=this.ensureVirtualStub(e)),n&&this.operandsTostack(e.signature,n);var _=l.call(e.internalName,n,m.toNativeType());return this.currentType=m,_}compileCallIndirect(e,n,t,r,i=0,a=!1){var s=t.length;if(!this.checkCallSignature(e,s,0!=i,r))return this.module.unreachable();var o=i?s+1:s,l=new Array(o),u=0;i&&(l[0]=i,u=1);var c=e.parameterTypes;for(let e=0;e<s;++e,++u)l[u]=this.compileExpression(t[e],c[e],1);return assert(u==o),this.makeCallIndirect(e,n,r,l,a)}makeCallIndirect(e,n,t,r=null,i=!1){var s=this.module,o=r?r.length:0,u=o,c=e.requiredParameters,p=e.parameterTypes,f=e.returnType,d=p.length,h=d;if(e.thisType&&(++c,++h,--u),assert(o>=c),o<h){r||((r=new Array(h)).length=0);let n=e.parameterTypes;for(let e=u;e<d;++e)r.push(this.makeZero(n[e],t))}var g=this.ensureArgumentsLength(),x=this.options.nativeSizeType;if(a.getSideEffects(n)&a.SideEffects.WritesGlobal){let e=this.currentFlow,t=e.getTempLocal(this.options.usizeType,l.findUsedLocals(n));n=s.block(null,[s.local_set(t.index,n,!0),s.global_set(g,s.i32(u)),s.local_get(t.index,x)],x),e.freeTempLocal(t)}else n=s.block(null,[s.global_set(g,s.i32(u)),n],x);r&&this.operandsTostack(e,r);var m=s.call_indirect(s.load(4,!1,n,a.NativeType.I32),r,e.nativeParams,e.nativeResults);return this.currentType=f,m}compileCommaExpression(e,n,t){var r=e.expressions,i=r.length,a=new Array(i--);for(let e=0;e<i;++e)a[e]=this.compileExpression(r[e],f.Type.void,9);return a[i]=this.compileExpression(r[i],n,t),this.module.flatten(a,this.currentType.toNativeType())}compileElementAccessExpression(e,n,t){var r=this.module,a=e.expression,s=this.resolver.resolveExpression(a,this.currentFlow);if(s){let n=s.getClassOrWrapper(this.program);if(n){let r=this.currentFlow.is(32768),s=n.lookupOverload(o.OperatorKind.INDEXED_GET,r);if(s){let n=assert(s.signature.thisType),o=this.compileExpression(a,n,1);return!r&&this.options.pedantic&&this.pedantic(i.DiagnosticCode.Indexed_access_may_involve_bounds_checking,e.range),this.compileCallDirect(s,[e.elementExpression],e,o,t)}}this.error(i.DiagnosticCode.Index_signature_is_missing_in_type_0,e.expression.range,s.toString())}return r.unreachable()}compileFunctionExpression(e,n,t){var r=e.declaration.clone();assert(!r.typeParameters);var a,s=this.currentFlow,u=s.actualFunction,c=r.name.text.length>0,h=!c||n!=f.Type.void,g=new o.FunctionPrototype(h?(c?r.name.text+"|":"anonymous|")+(u.nextAnonymousId++).toString():r.name.text,u,r,o.DecoratorFlags.NONE),x=d.uniqueMap(s.contextualTypeArguments),m=this.module,_=n.signatureReference;if(_){let n=g.functionTypeNode,t=n.parameters,r=t.length,l=_.parameterTypes,c=l.length;if(r>c)return this.error(i.DiagnosticCode.Expected_0_arguments_but_got_1,e.range,c.toString(),r.toString()),m.unreachable();for(let e=0;e<r;++e){let n=t[e];if(!p.isTypeOmitted(n.type)){let t=this.resolver.resolveType(n.type,u.parent,x);if(!t)return m.unreachable();if(!l[e].isStrictlyAssignableTo(t))return this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,n.range,l[e].toString(),t.toString()),m.unreachable()}}let d=_.returnType;if(!p.isTypeOmitted(n.returnType)){let e=this.resolver.resolveType(n.returnType,u.parent,x);if(!e)return m.unreachable();if(d==f.Type.void?e!=f.Type.void:!e.isStrictlyAssignableTo(d))return this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,n.returnType.range,e.toString(),d.toString()),m.unreachable()}let h=_.thisType,y=n.explicitThisType;if(y){if(!h)return this.error(i.DiagnosticCode._this_cannot_be_referenced_in_current_location,y.range),m.unreachable();let e=this.resolver.resolveType(y,u.parent,x);if(!e)return m.unreachable();if(!h.isStrictlyAssignableTo(e))return this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,y.range,h.toString(),e.toString()),m.unreachable()}let E=new f.Signature(this.program,l,d,h);E.requiredParameters=c,(a=new o.Function(g.name,g,null,E,x)).flow.outer=s;let T=this.compileFunction(a);if(this.currentType=_.type,!T)return m.unreachable()}else{if(!(a=this.resolver.resolveFunction(g,null,x)))return this.module.unreachable();a.flow.outer=s;let e=this.compileFunction(a);if(this.currentType=a.signature.type,!e)return m.unreachable()}var y=this.ensureRuntimeFunction(a),E=this.options.isWasm64?m.i64(i64_low(y),i64_high(y)):m.i32(i64_low(y));if(!h){let e=a.name,n=s.getScopedLocal(e);if(n)n.declaration.range.source.isNative?this.error(i.DiagnosticCode.Duplicate_identifier_0,r.name.range,e):this.errorRelated(i.DiagnosticCode.Duplicate_identifier_0,r.name.range,n.declaration.name.range,e);else{let e=a.type,n=s.addScopedLocal(a.name,e);s.setLocalFlag(n.index,l.LocalFlags.CONSTANT),E=m.local_tee(n.index,E,e.isManaged)}}return E}maybeCompileEnclosingSource(e){var n=e.range.source.internalPath,t=this.program.filesByName;assert(t.has(n)),assert(t.get(n)).is(s.CommonFlags.COMPILED)||this.compileFileByPath(n,e)}compileIdentifierExpression(e,n,t){var r=this.module,u=this.currentFlow,c=u.actualFunction;switch(e.kind){case p.NodeKind.NULL:{let t=this.options;if(n.isReference){let i=n.getClass();if(i)return this.currentType=i.type.asNullable(),t.isWasm64?r.i64(0):r.i32(0);let a=n.getSignature();return a?(this.currentType=a.type.asNullable(),t.isWasm64?r.i64(0):r.i32(0)):this.makeZero(n,e)}return this.currentType=t.usizeType,this.warning(i.DiagnosticCode.Expression_resolves_to_unusual_type_0,e.range,this.currentType.toString()),t.isWasm64?r.i64(0):r.i32(0)}case p.NodeKind.TRUE:return this.currentType=f.Type.bool,r.i32(1);case p.NodeKind.FALSE:return this.currentType=f.Type.bool,r.i32(0);case p.NodeKind.THIS:{let n=c.signature.thisType;if(!n)return this.error(i.DiagnosticCode._this_cannot_be_referenced_in_current_location,e.range),this.currentType=this.options.usizeType,r.unreachable();if(c.is(s.CommonFlags.CONSTRUCTOR)&&!(32&t)){let n=c.parent;assert(n.kind==o.ElementKind.CLASS),this.checkFieldInitialization(n,e)}let a=assert(u.lookupLocal(s.CommonNames.this_));return u.set(64),this.currentType=n,r.local_get(a.index,n.toNativeType())}case p.NodeKind.SUPER:{let n=this.currentFlow,t=n.actualFunction;if(t.is(s.CommonFlags.CONSTRUCTOR)&&(n.is(128)||this.error(i.DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,e.range)),n.isInline){let e=n.lookupLocal(s.CommonNames.this_);if(e){let n=assert(e.type.getClass()).base;if(n)return this.currentType=n.type,r.local_get(e.index,n.type.toNativeType())}}if(t.is(s.CommonFlags.INSTANCE)){let e=assert(t.parent);assert(e.kind==o.ElementKind.CLASS);let n=e.base;if(n){let e=n.type;return this.currentType=e,r.local_get(0,e.toNativeType())}}return this.error(i.DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,e.range),this.currentType=this.options.usizeType,r.unreachable()}}this.maybeCompileEnclosingSource(e);var h=this.currentParent;h||(h=c);var g=this.resolver.lookupIdentifierExpression(e,u,h);if(!g)return this.currentType==f.Type.void&&(this.currentType=f.Type.i32),r.unreachable();switch(g.kind){case o.ElementKind.LOCAL:{let a=g,o=a.type;if(assert(o!=f.Type.void),this.pendingElements.has(a))return this.error(i.DiagnosticCode.Variable_0_used_before_its_declaration,e.range,a.internalName),this.currentType=o,r.unreachable();if(a.is(s.CommonFlags.INLINED))return this.compileInlineConstant(a,n,t);let c=a.index;return assert(c>=0),o.isNullableReference&&u.isLocalFlag(c,l.LocalFlags.NONNULL,!1)&&(o=o.nonNullableType),this.currentType=o,g.parent!=u.parentFunction?(this.error(i.DiagnosticCode.Not_implemented_0,e.range,"Closures"),r.unreachable()):r.local_get(c,o.toNativeType())}case o.ElementKind.GLOBAL:{let a=g;if(!this.compileGlobal(a))return r.unreachable();let o=a.type;return this.pendingElements.has(a)?(this.error(i.DiagnosticCode.Variable_0_used_before_its_declaration,e.range,a.internalName),this.currentType=o,r.unreachable()):(assert(o!=f.Type.void),a.is(s.CommonFlags.INLINED)?this.compileInlineConstant(a,n,t):(this.currentType=o,r.global_get(a.internalName,o.toNativeType())))}case o.ElementKind.ENUMVALUE:{let n=g;return g.is(s.CommonFlags.COMPILED)?(this.currentType=f.Type.i32,n.is(s.CommonFlags.INLINED)?(assert(1==n.constantValueKind),r.i32(i64_low(n.constantIntegerValue))):r.global_get(n.internalName,a.NativeType.I32)):(this.error(i.DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,e.range),this.currentType=f.Type.i32,r.unreachable())}case o.ElementKind.FUNCTION_PROTOTYPE:{let t=g,s=t.typeParameterNodes;if(null!==s&&0!=s.length)return this.error(i.DiagnosticCode.Expected_0_arguments_but_got_1,e.range,s.length.toString(),"0"),r.unreachable();let o=this.resolver.resolveFunction(t,null,d.uniqueMap(u.contextualTypeArguments));if(!o||!this.compileFunction(o))return r.unreachable();if(n.isExternalReference)return this.currentType=f.Type.funcref,r.ref_func(o.internalName,a.NativeType.Funcref);let l=this.ensureRuntimeFunction(o);return this.currentType=o.signature.type,this.options.isWasm64?r.i64(i64_low(l),i64_high(l)):r.i32(i64_low(l))}}return this.error(i.DiagnosticCode.Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime,e.range),this.module.unreachable()}compileInstanceOfExpression(e,n,t){var r=this.currentFlow,i=e.isType;if(i.kind==p.NodeKind.NAMEDTYPE){let n=i;if(!n.isNullable&&!n.hasTypeArguments){let t=this.resolver.resolveTypeName(n.name,r.actualFunction,u.ReportMode.SWALLOW);if(null!==t&&t.kind==o.ElementKind.CLASS_PROTOTYPE){let n=t;if(n.is(s.CommonFlags.GENERIC))return this.makeInstanceofClass(e,n)}}}var a=this.resolver.resolveType(e.isType,r.actualFunction,d.uniqueMap(r.contextualTypeArguments));return a?this.makeInstanceofType(e,a):(this.currentType=f.Type.bool,this.module.unreachable())}makeInstanceofType(e,n){var t=this.module,r=this.currentFlow,s=this.compileExpression(e.expression,n),o=this.currentType;if(this.currentType=f.Type.bool,n.isValue)return t.maybeDropCondition(s,t.i32(o==n?1:0));if(o.isValue)return t.maybeDropCondition(s,t.i32(0));var l=o.toNativeType();if(o.isNullableReference&&!n.isNullableReference){if(o.nonNullableType.isAssignableTo(n))return t.binary(l==a.NativeType.I64?a.BinaryOp.NeI64:a.BinaryOp.NeI32,s,this.makeZero(o,e.expression));if(n.isAssignableTo(o)){let u=this.program;if(!o.isUnmanaged&&!n.isUnmanaged){let c=r.getTempLocal(o),p=assert(u.instanceofInstance);this.compileFunction(p);let f=t.if(t.unary(l==a.NativeType.I64?a.UnaryOp.EqzI64:a.UnaryOp.EqzI32,t.local_tee(c.index,s,o.isManaged)),t.i32(0),this.makeCallDirect(p,[t.local_get(c.index,l),t.i32(n.classReference.id)],e));return r.freeTempLocal(c),this.options.pedantic&&this.pedantic(i.DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,e.range),f}this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"instanceof",o.toString(),n.toString())}}else{if(o.isAssignableTo(n))return t.maybeDropCondition(s,t.i32(1));if(n.isAssignableTo(o)){let u=this.program;if(!o.isUnmanaged&&!n.isUnmanaged){let i=r.getTempLocal(o),c=assert(u.instanceofInstance);this.compileFunction(c);let p=t.if(t.unary(l==a.NativeType.I64?a.UnaryOp.EqzI64:a.UnaryOp.EqzI32,t.local_tee(i.index,s,o.isManaged)),t.i32(0),this.makeCallDirect(c,[t.local_get(i.index,l),t.i32(n.classReference.id)],e));return r.freeTempLocal(i),p}this.error(i.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"instanceof",o.toString(),n.toString())}}return t.maybeDropCondition(s,t.i32(0))}makeInstanceofClass(e,n){var t=this.module,r=this.compileExpression(e.expression,f.Type.auto),i=this.currentType,s=i.toNativeType();this.currentType=f.Type.bool;var o=i.getClass();if(o){if(o.extends(n))return i.isNullableReference?t.binary(s==a.NativeType.I64?a.BinaryOp.NeI64:a.BinaryOp.NeI32,r,this.makeZero(i,e.expression)):t.maybeDropCondition(r,t.i32(1));if(n.extends(o.prototype))return this.pendingClassInstanceOf.add(n),t.call(n.internalName+"~instanceof",[r],a.NativeType.I32)}return t.maybeDropCondition(r,t.i32(0))}compileLiteralExpression(e,n,t,r=!1){var a=this.module;switch(e.literalKind){case p.LiteralKind.ARRAY:return assert(!r),this.compileArrayLiteral(e,n,t);case p.LiteralKind.FLOAT:{let t=e.value;return r&&(t=-t),n==f.Type.f32?a.f32(t):(this.currentType=f.Type.f64,a.f64(t))}case p.LiteralKind.INTEGER:{let t=e.value;r&&(t=i64_sub(i64_new(0),t));let i=this.resolver.determineIntegerLiteralType(t,n);switch(this.currentType=i,i.kind){case 4:if(!this.options.isWasm64)return a.i32(i64_low(t));case 3:return a.i64(i64_low(t),i64_high(t));case 9:if(!this.options.isWasm64)return a.i32(i64_low(t));case 8:return a.i64(i64_low(t),i64_high(t));case 11:return a.f32(i64_to_f32(t));case 12:return a.f64(i64_to_f64(t));default:return a.i32(i64_low(t))}}case p.LiteralKind.STRING:return assert(!r),this.compileStringLiteral(e,t);case p.LiteralKind.OBJECT:return assert(!r),this.compileObjectLiteral(e,n);case p.LiteralKind.REGEXP:return this.error(i.DiagnosticCode.Not_implemented_0,e.range,"Regular expressions"),this.currentType=n,a.unreachable()}return assert(!1),a.unreachable()}compileStringLiteral(e,n){return this.ensureStaticString(e.value)}compileArrayLiteral(e,n,t){var r=this.module,s=this.currentFlow,l=this.program;let u=n.getClass();if(null!==u&&u.extends(l.staticArrayPrototype))return this.compileStaticArrayLiteral(e,n,t);var c=this.resolver.lookupExpression(e,s,this.currentType);if(!c)return r.unreachable();assert(c.kind==o.ElementKind.CLASS);var f=c,d=f.type,h=f.getTypeArgumentsTo(l.arrayPrototype)[0],g=assert(l.arrayBufferInstance),x=s.getTempLocal(this.options.usizeType),m=s.getTempLocal(g.type),_=e.elementExpressions,y=_.length,E=new Array(y),T=!h.isExternalReference;for(let e=0;e<y;++e){let n=_[e];if(n.kind!=p.NodeKind.OMITTED){let t=this.compileExpression(n,h,1),i=r.runExpression(t,a.ExpressionRunnerFlags.PreserveSideeffects);i?t=i:T=!1,E[e]=t}else E[e]=this.makeZero(h,n)}if(T){s.freeTempLocal(x),s.freeTempLocal(m);let n=l.totalOverhead,i=this.addStaticBuffer(h,E),a=i64_add(i.offset,i64_new(n));if(16&t){let e=this.addStaticArrayHeader(h,i),t=i64_add(e.offset,i64_new(n));return this.currentType=d,l.options.isWasm64?this.module.i64(i64_low(t),i64_high(t)):this.module.i32(i64_low(t))}{let n=this.makeCallDirect(l.newArrayInstance,[r.i32(y),l.options.isWasm64?r.i64(h.alignLog2):r.i32(h.alignLog2),r.i32(f.id),l.options.isWasm64?r.i64(i64_low(a),i64_high(a)):r.i32(i64_low(a))],e);return this.currentType=d,n}}var b=f.lookupOverload(o.OperatorKind.INDEXED_SET,!0);if(!b)return s.freeTempLocal(x),s.freeTempLocal(m),this.error(i.DiagnosticCode.Index_signature_in_type_0_only_permits_reading,e.range,f.internalName),this.currentType=d,r.unreachable();var v=d.toNativeType(),A=new Array;A.push(r.local_set(x.index,this.makeCallDirect(l.newArrayInstance,[r.i32(y),l.options.isWasm64?r.i64(h.alignLog2):r.i32(h.alignLog2),r.i32(f.id),l.options.isWasm64?r.i64(0):r.i32(0)],e),d.isManaged));var F=assert(f.lookupInSelf("dataStart"));assert(F.kind==o.ElementKind.FIELD),A.push(r.local_set(m.index,r.load(d.byteSize,!1,r.local_get(x.index,v),v,F.memoryOffset),!0));for(let e=0;e<y;++e)A.push(r.call(b.internalName,[r.local_get(x.index,v),r.i32(e),E[e]],a.NativeType.None));return A.push(r.local_get(x.index,v)),s.freeTempLocal(x),s.freeTempLocal(m),y&&this.compileFunction(b),this.currentType=d,r.flatten(A,v)}compileStaticArrayLiteral(e,n,t){var r=this.module,s=this.currentFlow,l=this.program,u=assert(n.getClass()),c=u.type,f=assert(u.getTypeArgumentsTo(l.staticArrayPrototype))[0],d=s.getTempLocal(this.options.usizeType),h=e.elementExpressions,g=h.length,x=new Array(g),m=!f.isExternalReference;for(let e=0;e<g;++e){let n=h[e];if(n.kind!=p.NodeKind.OMITTED){let t=this.compileExpression(n,f,1),i=r.runExpression(t,a.ExpressionRunnerFlags.PreserveSideeffects);i?t=i:m=!1,x[e]=t}else x[e]=this.makeZero(f,n)}var _=this.options.isWasm64,y=x.length<<f.alignLog2;if(m){s.freeTempLocal(d);let n=this.addStaticBuffer(f,x,u.id),i=i64_add(n.offset,i64_new(l.totalOverhead));if(16&t){let e=this.options.isWasm64?r.i64(i64_low(i),i64_high(i)):r.i32(i64_low(i));return this.currentType=c,e}{let n=this.makeCallDirect(l.newBufferInstance,[_?r.i64(y):r.i32(y),r.i32(u.id),_?r.i64(i64_low(i),i64_high(i)):r.i32(i64_low(i))],e);return this.currentType=c,n}}var E=u.lookupOverload(o.OperatorKind.INDEXED_SET,!0);if(!E)return s.freeTempLocal(d),this.error(i.DiagnosticCode.Index_signature_in_type_0_only_permits_reading,e.range,u.internalName),this.currentType=c,r.unreachable();var T=c.toNativeType(),b=new Array;b.push(r.local_set(d.index,this.makeCallDirect(l.newBufferInstance,[_?r.i64(y):r.i32(y),r.i32(u.id)],e),c.isManaged));for(let e=0;e<g;++e)b.push(r.call(E.internalName,[r.local_get(d.index,T),r.i32(e),x[e]],a.NativeType.None));return b.push(r.local_get(d.index,T)),s.freeTempLocal(d),g&&this.compileFunction(E),this.currentType=c,r.flatten(b,T)}compileObjectLiteral(e,n){var t=this.module,r=n.getClass();if(!r)return this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,e.range,"<object>",n.toString()),t.unreachable();var l=r.type;if(this.currentType=l.nonNullableType,r.is(s.CommonFlags.ABSTRACT))return this.error(i.DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,e.range),t.unreachable();var u=r.prototype.constructorPrototype;if(u)return this.errorRelated(i.DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,e.range,u.identifierNode.range,l.toString()),t.unreachable();var c=l.isManaged;c||this.checkUnsafe(e,p.findDecorator(p.DecoratorKind.UNMANAGED,r.decoratorNodes));var f=e.names,d=f.length,h=e.values,g=r.members,x=!1,m=new Array,_=this.currentFlow,y=_.getTempLocal(l),E=l.toNativeType();assert(d==h.length);var T=new Set;if(g)for(let e=Map_keys(g),n=0,t=e.length;n<t;++n){let t=e[n],r=assert(g.get(t));null!==r&&r.kind==o.ElementKind.FIELD&&T.add(r)}for(let e=0;e<d;++e){let n,r=f[e].text;if(!g||!g.has(r)||(n=assert(g.get(r))).kind!=o.ElementKind.FIELD){this.error(i.DiagnosticCode.Property_0_does_not_exist_on_type_1,f[e].range,r,l.toString()),x=!0;continue}if(n.is(s.CommonFlags.PRIVATE)){this.error(i.DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,f[e].range,r,l.toString()),x=!0;continue}if(n.is(s.CommonFlags.PROTECTED)){this.error(i.DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,f[e].range,r,l.toString()),x=!0;continue}let u=n,c=u.type,p=this.compileExpression(h[e],c,1);m.push(t.call(u.internalSetterName,[t.local_get(y.index,E),p],a.NativeType.None)),this.compileFieldSetter(u),T.delete(u)}if(this.currentType=l.nonNullableType,x)return t.unreachable();for(let n=Set_values(T),r=0,s=n.length;r<s;++r){let s=n[r],o=s.type;if(!s.initializerNode)if(!o.isReference||o.isNullableReference){switch(o.kind){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:m.push(t.call(s.internalSetterName,[t.local_get(y.index,E),this.makeZero(o,e)],a.NativeType.None)),this.compileFieldSetter(s);continue}this.error(i.DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,e.range,s.name,"<object>",l.toString()),x=!0}else this.error(i.DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,e.range,s.name,"<object>",l.toString()),x=!0}if(x)return t.unreachable();var b=this.ensureConstructor(r,e);return m.unshift(t.local_set(y.index,this.compileInstantiate(b,[],0,e),l.isManaged)),m.push(t.local_get(y.index,E)),c||_.freeTempLocal(y),this.currentType=l.nonNullableType,t.flatten(m,E)}compileNewExpression(e,n,t){var r=this.module,a=this.currentFlow,l=this.resolver.resolveTypeName(e.typeName,a.actualFunction);if(!l)return r.unreachable();if(l.kind!=o.ElementKind.CLASS_PROTOTYPE)return this.error(i.DiagnosticCode.This_expression_is_not_constructable,e.typeName.range),this.module.unreachable();if(l.is(s.CommonFlags.ABSTRACT))return this.error(i.DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,e.typeName.range),this.module.unreachable();var u,c=l,p=null,h=e.typeArguments;if(!(p=!h&&null!==(u=n.classReference)&&u.prototype==c&&u.is(s.CommonFlags.GENERIC)?this.resolver.resolveClass(c,u.typeArguments,d.uniqueMap(a.contextualTypeArguments)):this.resolver.resolveClassInclTypeArguments(c,h,a.actualFunction.parent,d.uniqueMap(a.contextualTypeArguments),e)))return r.unreachable();n==f.Type.void&&(t|=8);var g=this.ensureConstructor(p,e);return g.hasDecorator(o.DecoratorFlags.INLINE)||this.checkFieldInitialization(p,e),this.compileInstantiate(g,e.args,t,e)}ensureConstructor(e,n){var t=e.constructorInstance;if(t){if(t.is(s.CommonFlags.COMPILED))return t;t.hasDecorator(o.DecoratorFlags.INLINE)||this.compileFunction(t)}else{let r=e.base,i=d.uniqueMap(e.contextualTypeArguments);if(r){let a=this.ensureConstructor(r,n);this.checkFieldInitialization(r,n),t=new o.Function(s.CommonNames.constructor,new o.FunctionPrototype(s.CommonNames.constructor,e,a.declaration.clone()),null,a.signature,i)}else t=new o.Function(s.CommonNames.constructor,new o.FunctionPrototype(s.CommonNames.constructor,e,this.program.makeNativeFunctionDeclaration(s.CommonNames.constructor,s.CommonFlags.INSTANCE|s.CommonFlags.CONSTRUCTOR)),null,new f.Signature(this.program,null,e.type,e.type),i);t.set(s.CommonFlags.COMPILED),t.prototype.setResolvedInstance("",t),e.is(s.CommonFlags.MODULE_EXPORT)&&t.set(s.CommonFlags.MODULE_EXPORT),e.constructorInstance=t;let a=e.members;a||(e.members=a=new Map),a.set("constructor",t.prototype);let l=this.currentFlow,u=t.flow;this.currentFlow=u;let c=t.signature,p=this.module,h=this.options.nativeSizeType,g=new Array;if(g.push(this.makeConditionalAllocation(e,0)),r){let e=c.parameterTypes,t=e.length,i=new Array(1+t);i[0]=p.local_get(0,h);for(let n=1;n<=t;++n)i[n]=p.local_get(n,e[n-1].toNativeType());g.push(p.local_set(0,this.makeCallDirect(assert(r.constructorInstance),i,n,!1),r.type.isManaged))}this.makeFieldInitializationInConstructor(e,g),g.push(p.local_get(0,h)),u.freeScopedLocals(),this.currentFlow=l;let x=t.localsByIndex,m=new Array,_=1+c.parameterTypes.length,y=x.length;if(y>_)for(let e=_;e<y;++e)m.push(x[e].type.toNativeType());let E=p.addFunction(t.internalName,c.nativeParams,c.nativeResults,m,p.flatten(g,h));t.finalize(p,E)}return t}checkFieldInitialization(e,n=null){if(!e.didCheckFieldInitialization){e.didCheckFieldInitialization=!0;var t=assert(e.constructorInstance);this.checkFieldInitializationInFlow(e,t.flow,n)}}checkFieldInitializationInFlow(e,n,t=null){var r=e.members;if(r)for(let a=Map_values(r),u=0,c=a.length;u<c;++u){let r=a[u];if(r.kind==o.ElementKind.FIELD&&r.parent==e){let e=r;e.initializerNode||n.isThisFieldFlag(e,l.FieldFlags.INITIALIZED)?e.is(s.CommonFlags.DEFINITELY_ASSIGNED)&&(e.type.isReference?this.warning(i.DiagnosticCode.Property_0_is_always_assigned_before_being_used,e.identifierNode.range,e.internalName):this.pedantic(i.DiagnosticCode.Unnecessary_definite_assignment,e.identifierNode.range)):e.is(s.CommonFlags.DEFINITELY_ASSIGNED)||(t?this.errorRelated(i.DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,e.declaration.name.range,t.range,e.internalName):this.error(i.DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,e.declaration.name.range,e.internalName))}}}compileInstantiate(e,n,t,r){assert(e.is(s.CommonFlags.CONSTRUCTOR));var i=e.parent;assert(i.kind==o.ElementKind.CLASS);var l=i;(l.type.isUnmanaged||e.hasDecorator(o.DecoratorFlags.UNSAFE))&&this.checkUnsafe(r);var u=this.compileCallDirect(e,n,r,this.makeZero(this.options.usizeType,r),t);return a.getExpressionType(u)!=a.NativeType.None&&(this.currentType=l.type),u}compilePropertyAccessExpression(e,n,t){var r=this.module,u=this.currentFlow;this.maybeCompileEnclosingSource(e);var c=this.resolver,d=c.lookupExpression(e,u,n);if(!d)return r.unreachable();var h=c.currentThisExpression;switch(d.hasDecorator(o.DecoratorFlags.UNSAFE)&&this.checkUnsafe(e),d.kind){case o.ElementKind.GLOBAL:{let a=d;if(!this.compileGlobal(a))return r.unreachable();let o=a.type;return assert(o!=f.Type.void),this.pendingElements.has(a)?(this.error(i.DiagnosticCode.Variable_0_used_before_its_declaration,e.range,a.internalName),this.currentType=o,r.unreachable()):a.is(s.CommonFlags.INLINED)?this.compileInlineConstant(a,n,t):(this.currentType=o,r.global_get(a.internalName,o.toNativeType()))}case o.ElementKind.ENUMVALUE:{let e=d,i=assert(e.parent);assert(i.kind==o.ElementKind.ENUM);let l=i;return this.compileEnum(l)?(this.currentType=f.Type.i32,e.is(s.CommonFlags.INLINED)?(assert(1==e.constantValueKind),this.compileInlineConstant(e,n,t)):(assert(e.type==f.Type.i32),r.global_get(e.internalName,a.NativeType.I32))):(this.currentType=f.Type.i32,this.module.unreachable())}case o.ElementKind.FIELD:{let n=d,t=n.type;assert(n.memoryOffset>=0);let a=n.parent;assert(a.kind==o.ElementKind.CLASS),h=assert(h);let c=this.compileExpression(h,a.type,33),f=this.currentType;if(!u.actualFunction.is(s.CommonFlags.CONSTRUCTOR)||h.kind!=p.NodeKind.THIS||u.isThisFieldFlag(n,l.FieldFlags.INITIALIZED)||n.is(s.CommonFlags.DEFINITELY_ASSIGNED)||this.errorRelated(i.DiagnosticCode.Property_0_is_used_before_being_assigned,e.range,n.identifierNode.range,n.internalName),f.isNullableReference&&(u.isNonnull(c,f)||this.error(i.DiagnosticCode.Object_is_possibly_null,h.range)),!n.is(s.CommonFlags.COMPILED)){n.set(s.CommonFlags.COMPILED);let e=n.typeNode;e&&this.checkTypeSupported(n.type,e)}this.currentType=t;let g=r.load(t.byteSize,t.isSignedIntegerValue,c,t.toNativeType(),n.memoryOffset);return n.is(s.CommonFlags.DEFINITELY_ASSIGNED)&&t.isReference&&!t.isNullableReference&&(g=this.makeRuntimeNonNullCheck(g,t,e)),g}case o.ElementKind.PROPERTY_PROTOTYPE:{let e=d,n=this.resolver.resolveProperty(e);if(!n)return r.unreachable();d=n}case o.ElementKind.PROPERTY:{let n=assert(d.getterInstance),t=0;return n.is(s.CommonFlags.INSTANCE)&&(t=this.compileExpression(assert(h),assert(n.signature.thisType),33)),this.compileCallDirect(n,[],e,t)}case o.ElementKind.FUNCTION_PROTOTYPE:{let e=d,n=this.resolver.resolveFunction(e,null);if(!n)return r.unreachable();if(!this.compileFunction(n))return r.unreachable();this.currentType=n.type;let t=this.ensureRuntimeFunction(n);return this.options.isWasm64?r.i64(i64_low(t),i64_high(t)):r.i32(i64_low(t))}}return assert(!1),r.unreachable()}compileTernaryExpression(e,n,t){var r=this.module,a=e.ifThen,s=e.ifElse,o=this.makeIsTrueish(this.compileExpression(e.condition,f.Type.bool),this.currentType,e.condition),l=this.evaluateCondition(o);if(1==l)return r.maybeDropCondition(o,this.compileExpression(a,n));if(2==l)return r.maybeDropCondition(o,this.compileExpression(s,n));var u=this.currentFlow,c=u.fork();c.inheritNonnullIfTrue(o),this.currentFlow=c;var p=this.compileExpression(a,n),d=this.currentType,h=u.fork();h.inheritNonnullIfFalse(o),this.currentFlow=h;var g=this.compileExpression(s,n==f.Type.auto?d:n),x=this.currentType,m=f.Type.commonDenominator(d,x,!1);return m?(p=this.convertExpression(p,d,m,!1,a),d=m,g=this.convertExpression(g,x,m,!1,s),x=m,this.currentType=m,c.freeScopedLocals(),h.freeScopedLocals(),this.currentFlow=u,u.inheritMutual(c,h),r.if(o,p,g)):(this.error(i.DiagnosticCode.Type_0_is_not_assignable_to_type_1,s.range,x.toString(),d.toString()),this.currentType=n,r.unreachable())}compileUnaryPostfixExpression(e,n,t){var r=this.module,l=this.currentFlow,u=this.compileExpression(e.operand,n.exceptVoid,0);if(a.getExpressionId(u)==a.ExpressionId.Unreachable)return u;var p,d=null;switch(n!=f.Type.void&&(d=l.getTempLocal(this.currentType),u=r.local_tee(d.index,u,this.currentType.isManaged)),e.operator){case c.Token.PLUS_PLUS:{let n=this.currentType.getClassOrWrapper(this.program);if(n){let t=n.lookupOverload(o.OperatorKind.POSTFIX_INC);if(t){let n=t.is(s.CommonFlags.INSTANCE);if(null===d||n||(u=a.getLocalSetValue(u),l.freeTempLocal(d),d=null),p=this.compileUnaryOverload(t,e.operand,u,e),n)break;return p}}if(!this.currentType.isValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"++",this.currentType.toString()),d&&l.freeTempLocal(d),r.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 5:case 6:case 7:case 10:p=r.binary(a.BinaryOp.AddI32,u,r.i32(1));break;case 9:case 4:{let e=this.options;p=r.binary(e.isWasm64?a.BinaryOp.AddI64:a.BinaryOp.AddI32,u,this.makeOne(this.currentType));break}case 3:case 8:p=r.binary(a.BinaryOp.AddI64,u,r.i64(1));break;case 11:p=r.binary(a.BinaryOp.AddF32,u,r.f32(1));break;case 12:p=r.binary(a.BinaryOp.AddF64,u,r.f64(1));break;default:return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"++",this.currentType.toString()),r.unreachable()}break}case c.Token.MINUS_MINUS:{let n=this.currentType.getClassOrWrapper(this.program);if(n){let t=n.lookupOverload(o.OperatorKind.POSTFIX_DEC);if(t){let n=t.is(s.CommonFlags.INSTANCE);if(null===d||n||(u=a.getLocalSetValue(u),l.freeTempLocal(d),d=null),p=this.compileUnaryOverload(t,e.operand,u,e),t.is(s.CommonFlags.INSTANCE))break;return p}}if(!this.currentType.isValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"--",this.currentType.toString()),d&&l.freeTempLocal(d),r.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 5:case 6:case 7:case 10:p=r.binary(a.BinaryOp.SubI32,u,r.i32(1));break;case 9:case 4:{let e=this.options;p=r.binary(e.isWasm64?a.BinaryOp.SubI64:a.BinaryOp.SubI32,u,this.makeOne(this.currentType));break}case 3:case 8:p=r.binary(a.BinaryOp.SubI64,u,r.i64(1));break;case 11:p=r.binary(a.BinaryOp.SubF32,u,r.f32(1));break;case 12:p=r.binary(a.BinaryOp.SubF64,u,r.f64(1));break;default:return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"--",this.currentType.toString()),r.unreachable()}break}default:return assert(!1),r.unreachable()}var h=this.resolver,g=h.lookupExpression(e.operand,l);if(!g)return d&&l.freeTempLocal(d),r.unreachable();if(!d)return this.makeAssignment(g,p,this.currentType,e.operand,h.currentThisExpression,h.currentElementExpression,!1);var x=this.makeAssignment(g,p,this.currentType,e.operand,h.currentThisExpression,h.currentElementExpression,!1);this.currentType=d.type,l.freeTempLocal(d);var m=d.type.toNativeType();return r.block(null,[x,r.local_get(d.index,m)],m)}compileUnaryPrefixExpression(e,n,t){var r,l=this.module,u=!1;switch(e.operator){case c.Token.PLUS:{r=this.compileExpression(e.operand,n.exceptVoid,0);let t=this.currentType.getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.PLUS);if(n)return this.compileUnaryOverload(n,e.operand,r,e)}if(!this.currentType.isValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"+",this.currentType.toString()),l.unreachable();break}case c.Token.MINUS:{let t=e.operand;if(t.isNumericLiteral){r=this.compileLiteralExpression(t,n,0,!0),this.options.sourceMap&&this.addDebugLocation(r,e.range);break}r=this.compileExpression(e.operand,n.exceptVoid,0);let s=this.currentType.getClassOrWrapper(this.program);if(s){let n=s.lookupOverload(o.OperatorKind.MINUS);if(n)return this.compileUnaryOverload(n,e.operand,r,e)}if(!this.currentType.isValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"-",this.currentType.toString()),l.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 5:case 6:case 7:case 10:r=l.binary(a.BinaryOp.SubI32,l.i32(0),r);break;case 9:case 4:r=l.binary(this.options.isWasm64?a.BinaryOp.SubI64:a.BinaryOp.SubI32,this.makeZero(this.currentType,e.operand),r);break;case 3:case 8:r=l.binary(a.BinaryOp.SubI64,l.i64(0),r);break;case 11:r=l.unary(a.UnaryOp.NegF32,r);break;case 12:r=l.unary(a.UnaryOp.NegF64,r);break;default:this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"-",this.currentType.toString()),r=l.unreachable()}break}case c.Token.PLUS_PLUS:{u=!0,r=this.compileExpression(e.operand,n.exceptVoid,0);let t=this.currentType.getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.PREFIX_INC);if(n){if(r=this.compileUnaryOverload(n,e.operand,r,e),n.is(s.CommonFlags.INSTANCE))break;return r}}if(!this.currentType.isValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"++",this.currentType.toString()),l.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 5:case 6:case 7:case 10:r=l.binary(a.BinaryOp.AddI32,r,this.module.i32(1));break;case 9:case 4:r=l.binary(this.options.isWasm64?a.BinaryOp.AddI64:a.BinaryOp.AddI32,r,this.makeOne(this.currentType));break;case 3:case 8:r=l.binary(a.BinaryOp.AddI64,r,l.i64(1));break;case 11:r=l.binary(a.BinaryOp.AddF32,r,l.f32(1));break;case 12:r=l.binary(a.BinaryOp.AddF64,r,l.f64(1));break;default:this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"++",this.currentType.toString()),r=l.unreachable()}break}case c.Token.MINUS_MINUS:{u=!0,r=this.compileExpression(e.operand,n.exceptVoid,0);let t=this.currentType.getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.PREFIX_DEC);if(n){if(r=this.compileUnaryOverload(n,e.operand,r,e),n.is(s.CommonFlags.INSTANCE))break;return r}}if(!this.currentType.isValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"--",this.currentType.toString()),l.unreachable();switch(this.currentType.kind){case 0:case 1:case 2:case 5:case 6:case 7:case 10:r=l.binary(a.BinaryOp.SubI32,r,l.i32(1));break;case 9:case 4:r=l.binary(this.options.isWasm64?a.BinaryOp.SubI64:a.BinaryOp.SubI32,r,this.makeOne(this.currentType));break;case 3:case 8:r=l.binary(a.BinaryOp.SubI64,r,l.i64(1));break;case 11:r=l.binary(a.BinaryOp.SubF32,r,l.f32(1));break;case 12:r=l.binary(a.BinaryOp.SubF64,r,l.f64(1));break;default:this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"--",this.currentType.toString()),r=l.unreachable()}break}case c.Token.EXCLAMATION:{r=this.compileExpression(e.operand,n.exceptVoid,0);let t=this.currentType.getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.NOT);if(n)return this.compileUnaryOverload(n,e.operand,r,e)}r=l.unary(a.UnaryOp.EqzI32,this.makeIsTrueish(r,this.currentType,e.operand)),this.currentType=f.Type.bool;break}case c.Token.TILDE:{r=this.compileExpression(e.operand,n==f.Type.void?f.Type.i32:n.isFloatValue?f.Type.i64:n,0);let t=this.currentType.getClassOrWrapper(this.program);if(t){let n=t.lookupOverload(o.OperatorKind.BITWISE_NOT);if(n)return this.compileUnaryOverload(n,e.operand,r,e)}if(!this.currentType.isValue)return this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"~",this.currentType.toString()),l.unreachable();switch(r=this.convertExpression(r,this.currentType,this.currentType.intType,!1,e.operand),this.currentType.kind){case 0:case 1:case 2:case 5:case 6:case 7:case 10:r=l.binary(a.BinaryOp.XorI32,r,l.i32(-1));break;case 9:case 4:r=l.binary(this.options.isWasm64?a.BinaryOp.XorI64:a.BinaryOp.XorI32,r,this.makeNegOne(this.currentType));break;case 3:case 8:r=l.binary(a.BinaryOp.XorI64,r,l.i64(-1,-1));break;default:this.error(i.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"~",this.currentType.toString()),r=l.unreachable()}break}case c.Token.TYPEOF:return this.compileTypeof(e,n,t);default:return assert(!1),l.unreachable()}if(!u)return r;var p=this.resolver,d=p.lookupExpression(e.operand,this.currentFlow);return d?this.makeAssignment(d,r,this.currentType,e.operand,p.currentThisExpression,p.currentElementExpression,n!=f.Type.void):l.unreachable()}compileTypeof(e,n,t){var r,i=e.operand,a=0,s=this.program.stringInstance;if(i.kind==p.NodeKind.NULL)r="object";else{let e=this.resolver.lookupExpression(i,this.currentFlow,f.Type.auto,u.ReportMode.SWALLOW);if(e)switch(e.kind){case o.ElementKind.CLASS_PROTOTYPE:case o.ElementKind.NAMESPACE:case o.ElementKind.ENUM:r="object";break;case o.ElementKind.FUNCTION_PROTOTYPE:r="function";break;default:{a=this.compileExpression(i,f.Type.auto);let e=this.currentType;if(a=this.convertExpression(a,e,f.Type.void,!0,i),e.isReference)if(e.getSignature())r="function";else{let n=e.getClass();r=n?n.prototype===s.prototype?"string":"object":"externref"}else r=e==f.Type.bool?"boolean":e.isNumericValue?"number":"undefined";break}}else{switch(i.kind){case p.NodeKind.IDENTIFIER:break;case p.NodeKind.PROPERTYACCESS:case p.NodeKind.ELEMENTACCESS:if(i.kind,p.NodeKind.PROPERTYACCESS,i=i.expression,!this.resolver.resolveExpression(i,this.currentFlow,f.Type.auto,u.ReportMode.REPORT))return this.currentType=s.type,this.module.unreachable();default:a=this.compileExpression(i,f.Type.auto),a=this.convertExpression(a,this.currentType,f.Type.void,!0,i)}r="undefined"}}return this.currentType=s.type,a?this.module.block(null,[a,this.ensureStaticString(r)],this.options.nativeSizeType):this.ensureStaticString(r)}ensureSmallIntegerWrap(e,n){var t=this.module,r=this.currentFlow;switch(n.kind){case 0:r.canOverflow(e,n)&&(e=this.options.hasFeature(1)?t.unary(a.UnaryOp.ExtendI8ToI32,e):t.binary(a.BinaryOp.ShrI32,t.binary(a.BinaryOp.ShlI32,e,t.i32(24)),t.i32(24)));break;case 1:r.canOverflow(e,n)&&(e=this.options.hasFeature(1)?t.unary(a.UnaryOp.ExtendI16ToI32,e):t.binary(a.BinaryOp.ShrI32,t.binary(a.BinaryOp.ShlI32,e,t.i32(16)),t.i32(16)));break;case 5:r.canOverflow(e,n)&&(e=t.binary(a.BinaryOp.AndI32,e,t.i32(255)));break;case 6:r.canOverflow(e,n)&&(e=t.binary(a.BinaryOp.AndI32,e,t.i32(65535)));break;case 10:r.canOverflow(e,n)&&(e=t.binary(a.BinaryOp.NeI32,e,t.i32(0)))}return e}addDebugLocation(e,n){var t=this.currentFlow.parentFunction,r=n.source;r.debugInfoIndex<0&&(r.debugInfoIndex=this.module.addDebugInfoFile(r.normalizedPath)),n.debugInfoRef=e,t.debugLocations.push(n)}checkFeatureEnabled(e,n){return!!this.options.hasFeature(e)||(this.error(i.DiagnosticCode.Feature_0_is_not_enabled,n.range,s.featureToString(e)),!1)}checkTypeSupported(e,n){switch(e.kind){case 13:return this.checkFeatureEnabled(16,n);case 14:case 15:return this.checkFeatureEnabled(256,n);case 16:return this.checkFeatureEnabled(256,n)&&this.checkFeatureEnabled(64,n);case 17:return this.checkFeatureEnabled(256,n)&&this.checkFeatureEnabled(1024,n)}let t=e.getClass();if(t)do{let e=t.typeArguments;if(e)for(let t=0,r=e.length;t<r;++t)if(!this.checkTypeSupported(e[t],n))return!1;t=t.base}while(t);else{let t=e.getSignature();if(t){let e=t.thisType;if(e&&!this.checkTypeSupported(e,n))return!1;let r=t.parameterTypes;for(let e=0,t=r.length;e<t;++e)if(!this.checkTypeSupported(r[e],n))return!1;let i=t.returnType;if(!this.checkTypeSupported(i,n))return!1}}return!0}checkSignatureSupported(e,n){var t=!0,r=n.explicitThisType;r&&(this.checkTypeSupported(assert(e.thisType),r)||(t=!1));var i=e.parameterTypes,a=n.parameters;for(let e=0,r=i.length;e<r;++e){let r;r=a.length>e?a[e]:n,this.checkTypeSupported(i[e],r)||(t=!1)}return this.checkTypeSupported(e.returnType,n.returnType)||(t=!1),t}evaluateCondition(e){var n=this.module.runExpression(e,a.ExpressionRunnerFlags.Default);return n?a.getConstValueI32(n)?1:2:0}makeZero(e,n){var t=this.module;switch(e.kind){default:assert(!1);case 0:case 1:case 2:case 5:case 6:case 7:case 10:return t.i32(0);case 4:case 9:if(64!=e.size)return t.i32(0);case 3:case 8:return t.i64(0);case 11:return t.f32(0);case 12:return t.f64(0);case 13:return t.v128(d.v128_zero);case 14:case 15:case 16:case 17:return t.ref_null(e.toNativeType())}}makeOne(e){var n=this.module;switch(e.kind){default:assert(!1);case 0:case 1:case 2:case 5:case 6:case 7:case 10:return n.i32(1);case 4:case 9:if(64!=e.size)return n.i32(1);case 3:case 8:return n.i64(1);case 11:return n.f32(1);case 12:return n.f64(1)}}makeNegOne(e){var n=this.module;switch(e.kind){default:assert(!1);case 0:case 1:case 2:case 5:case 6:case 7:return n.i32(-1);case 4:case 9:if(64!=e.size)return n.i32(-1);case 3:case 8:return n.i64(-1,-1);case 11:return n.f32(-1);case 12:return n.f64(-1)}}makeIsTrueish(e,n,t){var r=this.module;switch(n.kind){case 0:case 1:case 5:case 6:e=this.ensureSmallIntegerWrap(e,n);case 10:case 2:case 7:return e;case 3:case 8:return r.binary(a.BinaryOp.NeI64,e,r.i64(0));case 9:case 4:return 64==n.size?r.binary(a.BinaryOp.NeI64,e,r.i64(0)):e;case 11:return r.binary(a.BinaryOp.LeU32,r.binary(a.BinaryOp.SubI32,r.binary(a.BinaryOp.ShlI32,r.unary(a.UnaryOp.ReinterpretF32,e),r.i32(1)),r.i32(2)),r.i32(4278190078));case 12:return r.binary(a.BinaryOp.LeU64,r.binary(a.BinaryOp.SubI64,r.binary(a.BinaryOp.ShlI64,r.unary(a.UnaryOp.ReinterpretF64,e),r.i64(1)),r.i64(2)),r.i64(4294967294,4292870143));case 14:case 15:case 16:case 17:return r.ref_is_null(e);default:return assert(!1),r.i32(0)}}makeAllocation(e){var n=this.program;assert(e.program==n);var t=this.module,r=this.options;if(this.currentType=e.type,e.hasDecorator(o.DecoratorFlags.UNMANAGED)){let i=n.allocInstance;return this.compileFunction(i),t.call(i.internalName,[r.isWasm64?t.i64(e.nextMemoryOffset):t.i32(e.nextMemoryOffset)],r.nativeSizeType)}{let i=n.newInstance;return this.compileFunction(i),t.call(i.internalName,[r.isWasm64?t.i64(e.nextMemoryOffset):t.i32(e.nextMemoryOffset),t.i32(e.id)],r.nativeSizeType)}}makeConditionalAllocation(e,n){var t=this.module,r=e.type.toNativeType();return assert(r==this.options.nativeSizeType),t.if(t.unary(r==a.NativeType.I64?a.UnaryOp.EqzI64:a.UnaryOp.EqzI32,t.local_get(n,r)),t.local_set(n,this.makeAllocation(e),e.type.isManaged))}makeFieldInitializationInConstructor(e,n=[]){var t=e.members;if(!t)return n;var r=this.module,i=this.currentFlow,l=i.isInline,u=l?i.lookupLocal(s.CommonNames.this_).index:0,c=this.options.nativeSizeType;for(let p=Map_values(t),f=0,d=p.length;f<d;++f){let t=unchecked(p[f]);if(t.kind!=o.ElementKind.FIELD||t.parent!=e)continue;let d=t;assert(!d.isAny(s.CommonFlags.CONST));let h,g=d.type,x=g.toNativeType(),m=d.prototype,_=m.initializerNode,y=m.parameterIndex,E=d.typeNode;E&&this.checkTypeSupported(g,E),h=y>=0?r.local_get(l?i.lookupLocal(d.name).index:1+y,x):_?this.compileExpression(_,g,1):this.makeZero(g,m.declaration),this.compileFieldSetter(d),n.push(r.call(d.internalSetterName,[r.local_get(u,c),h],a.NativeType.None))}return n}makeAbort(e,n){var t=this.program,r=t.abortInstance;if(!r||!this.compileFunction(r))return this.module.unreachable();var i,a=t.stringInstance;return i=null!==e?this.compileExpression(e,a.type,1):this.makeZero(a.type,n),this.makeStaticAbort(i,n)}makeStaticAbort(e,n){var t=this.program,r=this.module,i=t.abortInstance;if(!i||!this.compileFunction(i))return r.unreachable();var s=this.ensureStaticString(n.range.source.normalizedPath),o=n.range,l=o.source;return r.block(null,[r.call(i.internalName,[e,s,r.i32(l.lineAt(o.start)),r.i32(l.columnAt())],a.NativeType.None),r.unreachable()])}makeRuntimeNonNullCheck(e,n,t){var r=this.module,i=this.currentFlow,a=i.getTempLocal(n);return i.canOverflow(e,n)||i.setLocalFlag(a.index,l.LocalFlags.WRAPPED),i.setLocalFlag(a.index,l.LocalFlags.NONNULL),e=r.if(r.local_tee(a.index,e,n.isManaged),r.local_get(a.index,n.toNativeType()),this.makeStaticAbort(this.ensureStaticString("unexpected null"),t)),i.freeTempLocal(a),this.currentType=n.nonNullableType,e}makeRuntimeUpcastCheck(e,n,t,r){assert(t.isReference&&t.nonNullableType.isAssignableTo(n));var i=this.module,s=this.currentFlow,o=s.getTempLocal(n),l=this.program.instanceofInstance;return assert(this.compileFunction(l)),e=i.if(i.call(l.internalName,[i.local_tee(o.index,e,n.isManaged),i.i32(t.classReference.id)],a.NativeType.I32),i.local_get(o.index,n.toNativeType()),this.makeStaticAbort(this.ensureStaticString("unexpected upcast"),r)),s.freeTempLocal(o),this.currentType=t,e}}function E(e,n){if(T=n.range.source.simplePath,b=o.mangleInternalName(e.name,e.parent,e.is(s.CommonFlags.INSTANCE),!0),e.hasDecorator(o.DecoratorFlags.EXTERNAL)){var t=e.program,r=assert(p.findDecorator(p.DecoratorKind.EXTERNAL,n.decorators)),a=r.args;if(null!==a&&a.length>0){let e=a[0];e.isLiteralKind(p.LiteralKind.STRING)?(b=e.value,a.length>=2&&(e=a[1],e.isLiteralKind(p.LiteralKind.STRING)?(T=b,b=e.value,a.length>2&&t.error(i.DiagnosticCode.Expected_0_arguments_but_got_1,r.range,"2",a.length.toString())):t.error(i.DiagnosticCode.String_literal_expected,e.range))):t.error(i.DiagnosticCode.String_literal_expected,e.range)}else t.error(i.DiagnosticCode.Expected_at_least_0_arguments_but_got_1,r.range,"1","0")}}var T,b;n.Compiler=y},317:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.TSDBuilder=n.IDLBuilder=n.ExportsWalker=void 0;const r=t(200),i=t(974),a=t(60),s=t(910);class o{constructor(e,n=!1){this.seen=new Map,this.program=e,this.includePrivate=n}walk(){for(let e=Map_values(this.program.filesByName),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);t.source.sourceKind==a.SourceKind.USER_ENTRY&&this.visitFile(t)}}visitFile(e){var n=e.exports;if(n)for(let e=Map_keys(n),t=0,r=e.length;t<r;++t){let r=unchecked(e[t]),i=assert(n.get(r));this.visitElement(r,i)}var t=e.exportsStar;if(t)for(let e=0,n=t.length;e<n;++e){let n=unchecked(t[e]);this.visitFile(n)}}visitElement(e,n){if(!n.is(r.CommonFlags.PRIVATE)||this.includePrivate){var t=this.seen;if(n.is(r.CommonFlags.INSTANCE)||!t.has(n))switch(t.set(n,e),n.kind){case i.ElementKind.GLOBAL:n.is(r.CommonFlags.COMPILED)&&this.visitGlobal(e,n);break;case i.ElementKind.ENUM:n.is(r.CommonFlags.COMPILED)&&this.visitEnum(e,n);break;case i.ElementKind.ENUMVALUE:break;case i.ElementKind.FUNCTION_PROTOTYPE:this.visitFunctionInstances(e,n);break;case i.ElementKind.CLASS_PROTOTYPE:this.visitClassInstances(e,n);break;case i.ElementKind.FIELD:{let t=n;t.is(r.CommonFlags.COMPILED)&&this.visitField(e,t);break}case i.ElementKind.PROPERTY_PROTOTYPE:{let e=n.instance;if(!e)break;n=e;break}case i.ElementKind.PROPERTY:{let t=n,r=t.getterInstance;r&&this.visitFunction(e,r);let i=t.setterInstance;i&&this.visitFunction(e,i);break}case i.ElementKind.NAMESPACE:c(n)&&this.visitNamespace(e,n);break;case i.ElementKind.TYPEDEFINITION:break;default:assert(!1)}else this.visitAlias(e,n,assert(t.get(n)))}}visitFunctionInstances(e,n){var t=n.instances;if(t)for(let n=Map_values(t),i=0,a=n.length;i<a;++i){let t=unchecked(n[i]);t.is(r.CommonFlags.COMPILED)&&this.visitFunction(e,t)}}visitClassInstances(e,n){var t=n.instances;if(t)for(let n=Map_values(t),i=0,a=n.length;i<a;++i){let t=unchecked(n[i]);t.is(r.CommonFlags.COMPILED)&&this.visitClass(e,t)}}}n.ExportsWalker=o;class l extends o{constructor(e,n=!1){super(e,n),this.sb=[],this.indentLevel=0}static build(e){return new l(e).build()}visitGlobal(e,n){var t=this.sb,i=n.is(r.CommonFlags.INLINED);if(s.indent(t,this.indentLevel),i&&t.push("const "),t.push(this.typeToString(n.type)),t.push(" "),t.push(e),i)switch(n.constantValueKind){case 1:t.push(" = "),t.push(i64_to_string(n.constantIntegerValue));break;case 2:t.push(" = "),t.push(n.constantFloatValue.toString());break;default:assert(!1)}t.push(";\n")}visitEnum(e,n){var t=this.sb;s.indent(t,this.indentLevel++),t.push("interface "),t.push(e),t.push(" {\n");var a=n.members;if(a){for(let e=Map_keys(a),n=0,o=e.length;n<o;++n){let o=unchecked(e[n]),l=assert(a.get(o));if(l.kind==i.ElementKind.ENUMVALUE){let e=l,n=e.is(r.CommonFlags.INLINED);s.indent(t,this.indentLevel),n?t.push("const "):t.push("readonly "),t.push("unsigned long "),t.push(o),n&&(t.push(" = "),assert(1==e.constantValueKind),t.push(i64_low(e.constantIntegerValue).toString())),t.push(";\n")}}for(let e=Map_values(a),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);t.kind!=i.ElementKind.ENUMVALUE&&this.visitElement(t.name,t)}}s.indent(t,--this.indentLevel),t.push("}\n")}visitFunction(e,n){var t=this.sb,r=n.signature;s.indent(t,this.indentLevel),t.push(this.typeToString(r.returnType)),t.push(" "),t.push(e),t.push("(");var i=r.parameterTypes,a=i.length;for(let e=0;e<a;++e)e&&t.push(", "),t.push(this.typeToString(i[e])),t.push(" "),t.push(n.getParameterName(e));t.push(");\n");var o=n.members;if(null!==o&&o.size>0){s.indent(t,this.indentLevel),t.push("interface "),t.push(n.name),t.push(" {\n");for(let e=Map_values(o),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);this.visitElement(t.name,t)}s.indent(t,--this.indentLevel),t.push("}\n")}}visitClass(e,n){var t=this.sb;s.indent(t,this.indentLevel++),t.push("interface "),t.push(e),t.push(" {\n"),s.indent(t,--this.indentLevel),t.push("}\n")}visitInterface(e,n){this.visitClass(e,n)}visitField(e,n){}visitNamespace(e,n){var t=this.sb;s.indent(t,this.indentLevel++),t.push("interface "),t.push(e),t.push(" {\n");var r=n.members;if(r)for(let e=Map_values(r),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);this.visitElement(t.name,t)}s.indent(t,--this.indentLevel),t.push("}\n")}visitAlias(e,n,t){}typeToString(e){switch(e.kind){case 0:return"byte";case 1:return"short";case 2:return"long";case 3:return"long long";case 4:return this.program.options.isWasm64?"long long":"long";case 5:return"octet";case 6:return"unsigned short";case 7:return"unsigned long";case 8:return"unsigned long long";case 9:return this.program.options.isWasm64?"unsigned long long":"unsigned long";case 10:return"boolean";case 11:return"unrestricted float";case 12:return"unrestricted double";case 18:return"void";default:return assert(!1),""}}build(){var e=this.sb;return e.push("interface ASModule {\n"),++this.indentLevel,this.walk(),--this.indentLevel,e.push("}\n"),e.join("")}}n.IDLBuilder=l;class u extends o{constructor(e,n=!1){super(e,n),this.sb=[],this.indentLevel=0}static build(e){return new u(e).build()}visitGlobal(e,n){var t=this.sb,i=n.is(r.CommonFlags.INLINED);s.indent(t,this.indentLevel),n.is(r.CommonFlags.STATIC)?i?t.push("static readonly "):t.push("static "):i?t.push("export const "):t.push("export var "),t.push(e),t.push(": "),t.push(this.typeToString(n.type)),t.push(";\n"),this.visitNamespace(e,n)}visitEnum(e,n){var t=this.sb;s.indent(t,this.indentLevel++),t.push("export "),n.is(r.CommonFlags.CONST)&&t.push("const "),t.push("enum "),t.push(e),t.push(" {\n");var a=n.members,o=0;if(a){o=a.size;for(let e=Map_keys(a),n=0,l=e.length;n<l;++n){let l=unchecked(e[n]),u=assert(a.get(l));if(u.kind==i.ElementKind.ENUMVALUE){let e=u;s.indent(t,this.indentLevel),t.push(l),u.is(r.CommonFlags.INLINED)&&(t.push(" = "),assert(1==e.constantValueKind),t.push(i64_low(e.constantIntegerValue).toString())),t.push(",\n"),--o}}}s.indent(t,--this.indentLevel),t.push("}\n"),o&&this.visitNamespace(e,n)}visitFunction(e,n){if(!n.isAny(r.CommonFlags.PRIVATE|r.CommonFlags.SET)){var t=this.sb,i=n.signature;if(s.indent(t,this.indentLevel),n.is(r.CommonFlags.PROTECTED)&&t.push("protected "),n.is(r.CommonFlags.STATIC)&&t.push("static "),n.is(r.CommonFlags.GET))return t.push("get "),t.push(e),t.push("(): "),t.push(this.typeToString(i.returnType)),void t.push(";\n");n.isAny(r.CommonFlags.STATIC|r.CommonFlags.INSTANCE)||t.push("export function "),t.push(e),t.push("(");var a=i.parameterTypes,o=a.length,l=i.requiredParameters;for(let e=0;e<o;++e)e&&t.push(", "),t.push(n.getParameterName(e)),e>=l&&t.push("?"),t.push(": "),t.push(this.typeToString(a[e]));n.isAny(r.CommonFlags.CONSTRUCTOR|r.CommonFlags.SET)?t.push(")"):(t.push("): "),t.push(this.typeToString(i.returnType))),t.push(";\n"),this.visitNamespace(e,n)}}visitClass(e,n){var t=this.sb,a=n.kind==i.ElementKind.INTERFACE;s.indent(t,this.indentLevel++),a?t.push("export interface "):(t.push("export "),n.is(r.CommonFlags.ABSTRACT)&&t.push("abstract "),t.push("class ")),t.push(e);var o=n.base;if(null!==o&&o.is(r.CommonFlags.COMPILED|r.CommonFlags.MODULE_EXPORT)){t.push(" extends ");let e=assert(n.prototype.extendsNode);t.push(e.name.identifier.text)}t.push(" {\n"),a||(s.indent(t,this.indentLevel),t.push("static wrap(ptr: usize): "),t.push(e),t.push(";\n"),s.indent(t,this.indentLevel),t.push("valueOf(): usize;\n"));var l=n.prototype.members;if(l)for(let e=Map_values(l),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);this.visitElement(t.name,t)}var u=n.members;if(u)for(let e=Map_values(u),t=0,r=e.length;t<r;++t){let r=unchecked(e[t]);r.parent==n&&this.visitElement(r.name,r)}s.indent(t,--this.indentLevel),t.push("}\n")}visitInterface(e,n){this.visitClass(e,n)}visitField(e,n){if(!n.is(r.CommonFlags.PRIVATE)){var t=this.sb;s.indent(t,this.indentLevel),n.is(r.CommonFlags.PROTECTED)&&t.push("protected "),n.is(r.CommonFlags.STATIC)&&t.push("static "),n.is(r.CommonFlags.READONLY)&&t.push("readonly "),t.push(e),t.push(": "),t.push(this.typeToString(n.type)),t.push(";\n")}}visitNamespace(e,n){var t=n.members;if(null!==t&&t.size>0){let n=this.sb;s.indent(n,this.indentLevel++),n.push("export namespace "),n.push(e),n.push(" {\n");for(let e=Map_values(t),n=0,r=e.length;n<r;++n){let t=unchecked(e[n]);this.visitElement(t.name,t)}s.indent(n,--this.indentLevel),n.push("}\n")}}visitAlias(e,n,t){var r=this.sb;s.indent(r,this.indentLevel),r.push("export const "),r.push(e),r.push(": typeof "),r.push(t),r.push(";\n")}typeToString(e){switch(e.kind){case 0:return"i8";case 1:return"i16";case 2:return"i32";case 3:return"i64";case 4:return"isize";case 5:return"u8";case 6:return"u16";case 7:return"u32";case 8:return"u64";case 9:return"usize";case 10:return"bool";case 11:return"f32";case 12:return"f64";case 13:return"v128";case 18:return"void";case 14:return"funcref";case 15:return"externref";case 16:return"exnref";case 17:return"anyref";default:return assert(!1),"any"}}build(){var e=this.sb,n=this.program.options.isWasm64;return e.push("declare module ASModule {\n"),e.push("  type i8 = number;\n"),e.push("  type i16 = number;\n"),e.push("  type i32 = number;\n"),e.push("  type i64 = bigint;\n"),n?e.push("  type isize = bigint;\n"):e.push("  type isize = number;\n"),e.push("  type u8 = number;\n"),e.push("  type u16 = number;\n"),e.push("  type u32 = number;\n"),e.push("  type u64 = bigint;\n"),n?e.push("  type usize = bigint;\n"):e.push("  type usize = number;\n"),e.push("  type f32 = number;\n"),e.push("  type f64 = number;\n"),e.push("  type bool = boolean | number;\n"),++this.indentLevel,this.walk(),--this.indentLevel,e.push("}\n"),e.push("export default ASModule;\n"),this.sb.join("")}}function c(e){var n=e.members;if(n)for(let e=Map_values(n),t=0,a=e.length;t<a;++t){let n=unchecked(e[t]);switch(n.kind){case i.ElementKind.FUNCTION_PROTOTYPE:{let e=n.instances;if(e)for(let n=Map_values(e),t=0,i=n.length;t<i;++t)if(unchecked(n[t]).is(r.CommonFlags.COMPILED))return!0;break}case i.ElementKind.CLASS_PROTOTYPE:{let e=n.instances;if(e)for(let n=Map_values(e),t=0,i=n.length;t<i;++t)if(unchecked(n[t]).is(r.CommonFlags.COMPILED))return!0;break}default:if(n.is(r.CommonFlags.COMPILED)||c(n))return!0}}return!1}n.TSDBuilder=u},252:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.diagnosticCodeToString=n.DiagnosticCode=void 0,function(e){e[e.Not_implemented_0=100]="Not_implemented_0",e[e.Operation_is_unsafe=101]="Operation_is_unsafe",e[e.User_defined_0=102]="User_defined_0",e[e.Feature_0_is_not_enabled=103]="Feature_0_is_not_enabled",e[e.Low_memory_limit_exceeded_by_static_data_0_1=104]="Low_memory_limit_exceeded_by_static_data_0_1",e[e.Module_requires_at_least_0_pages_of_initial_memory=105]="Module_requires_at_least_0_pages_of_initial_memory",e[e.Module_requires_at_least_0_pages_of_maximum_memory=106]="Module_requires_at_least_0_pages_of_maximum_memory",e[e.Shared_memory_requires_maximum_memory_to_be_defined=107]="Shared_memory_requires_maximum_memory_to_be_defined",e[e.Shared_memory_requires_feature_threads_to_be_enabled=108]="Shared_memory_requires_feature_threads_to_be_enabled",e[e.Conversion_from_type_0_to_1_requires_an_explicit_cast=200]="Conversion_from_type_0_to_1_requires_an_explicit_cast",e[e.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit=201]="Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit",e[e.Type_0_cannot_be_changed_to_type_1=202]="Type_0_cannot_be_changed_to_type_1",e[e.Operation_0_cannot_be_applied_to_type_1=203]="Operation_0_cannot_be_applied_to_type_1",e[e.Type_0_cannot_be_nullable=204]="Type_0_cannot_be_nullable",e[e.Cannot_export_a_mutable_global=205]="Cannot_export_a_mutable_global",e[e.Mutable_value_cannot_be_inlined=206]="Mutable_value_cannot_be_inlined",e[e.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa=207]="Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa",e[e.Unmanaged_classes_cannot_implement_interfaces=208]="Unmanaged_classes_cannot_implement_interfaces",e[e.Invalid_regular_expression_flags=209]="Invalid_regular_expression_flags",e[e.Expression_is_never_null=210]="Expression_is_never_null",e[e.Class_0_is_final_and_cannot_be_extended=211]="Class_0_is_final_and_cannot_be_extended",e[e.Decorator_0_is_not_valid_here=212]="Decorator_0_is_not_valid_here",e[e.Duplicate_decorator=213]="Duplicate_decorator",e[e.Type_0_is_illegal_in_this_context=214]="Type_0_is_illegal_in_this_context",e[e.Optional_parameter_must_have_an_initializer=215]="Optional_parameter_must_have_an_initializer",e[e.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal=216]="Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal",e[e.Function_0_cannot_be_inlined_into_itself=217]="Function_0_cannot_be_inlined_into_itself",e[e.Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set=218]="Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set",e[e.Optional_properties_are_not_supported=219]="Optional_properties_are_not_supported",e[e.Expression_must_be_a_compile_time_constant=220]="Expression_must_be_a_compile_time_constant",e[e.Type_0_is_not_a_function_index_or_function_reference=221]="Type_0_is_not_a_function_index_or_function_reference",e[e._0_must_be_a_value_between_1_and_2_inclusive=222]="_0_must_be_a_value_between_1_and_2_inclusive",e[e._0_must_be_a_power_of_two=223]="_0_must_be_a_power_of_two",e[e._0_is_not_a_valid_operator=224]="_0_is_not_a_valid_operator",e[e.Expression_cannot_be_represented_by_a_type=225]="Expression_cannot_be_represented_by_a_type",e[e.Expression_resolves_to_unusual_type_0=226]="Expression_resolves_to_unusual_type_0",e[e.Array_literal_expected=227]="Array_literal_expected",e[e.Function_0_is_virtual_and_will_not_be_inlined=228]="Function_0_is_virtual_and_will_not_be_inlined",e[e.Property_0_only_has_a_setter_and_is_missing_a_getter=229]="Property_0_only_has_a_setter_and_is_missing_a_getter",e[e._0_keyword_cannot_be_used_here=230]="_0_keyword_cannot_be_used_here",e[e.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final=231]="A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final",e[e.Exported_generic_function_or_class_has_no_concrete_instances=232]="Exported_generic_function_or_class_has_no_concrete_instances",e[e.Property_0_is_always_assigned_before_being_used=233]="Property_0_is_always_assigned_before_being_used",e[e.Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime=234]="Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime",e[e.Importing_the_table_disables_some_indirect_call_optimizations=901]="Importing_the_table_disables_some_indirect_call_optimizations",e[e.Exporting_the_table_disables_some_indirect_call_optimizations=902]="Exporting_the_table_disables_some_indirect_call_optimizations",e[e.Expression_compiles_to_a_dynamic_check_at_runtime=903]="Expression_compiles_to_a_dynamic_check_at_runtime",e[e.Indexed_access_may_involve_bounds_checking=904]="Indexed_access_may_involve_bounds_checking",e[e.Explicitly_returning_constructor_drops_this_allocation=905]="Explicitly_returning_constructor_drops_this_allocation",e[e.Unnecessary_definite_assignment=906]="Unnecessary_definite_assignment",e[e.Unterminated_string_literal=1002]="Unterminated_string_literal",e[e.Identifier_expected=1003]="Identifier_expected",e[e._0_expected=1005]="_0_expected",e[e.A_file_cannot_have_a_reference_to_itself=1006]="A_file_cannot_have_a_reference_to_itself",e[e.Trailing_comma_not_allowed=1009]="Trailing_comma_not_allowed",e[e.Unexpected_token=1012]="Unexpected_token",e[e.A_rest_parameter_must_be_last_in_a_parameter_list=1014]="A_rest_parameter_must_be_last_in_a_parameter_list",e[e.Parameter_cannot_have_question_mark_and_initializer=1015]="Parameter_cannot_have_question_mark_and_initializer",e[e.A_required_parameter_cannot_follow_an_optional_parameter=1016]="A_required_parameter_cannot_follow_an_optional_parameter",e[e.Statements_are_not_allowed_in_ambient_contexts=1036]="Statements_are_not_allowed_in_ambient_contexts",e[e.Initializers_are_not_allowed_in_ambient_contexts=1039]="Initializers_are_not_allowed_in_ambient_contexts",e[e._0_modifier_cannot_be_used_here=1042]="_0_modifier_cannot_be_used_here",e[e.A_rest_parameter_cannot_be_optional=1047]="A_rest_parameter_cannot_be_optional",e[e.A_rest_parameter_cannot_have_an_initializer=1048]="A_rest_parameter_cannot_have_an_initializer",e[e.A_set_accessor_must_have_exactly_one_parameter=1049]="A_set_accessor_must_have_exactly_one_parameter",e[e.A_set_accessor_parameter_cannot_have_an_initializer=1052]="A_set_accessor_parameter_cannot_have_an_initializer",e[e.A_get_accessor_cannot_have_parameters=1054]="A_get_accessor_cannot_have_parameters",e[e.Enum_member_must_have_initializer=1061]="Enum_member_must_have_initializer",e[e.Type_parameters_cannot_appear_on_a_constructor_declaration=1092]="Type_parameters_cannot_appear_on_a_constructor_declaration",e[e.Type_annotation_cannot_appear_on_a_constructor_declaration=1093]="Type_annotation_cannot_appear_on_a_constructor_declaration",e[e.An_accessor_cannot_have_type_parameters=1094]="An_accessor_cannot_have_type_parameters",e[e.A_set_accessor_cannot_have_a_return_type_annotation=1095]="A_set_accessor_cannot_have_a_return_type_annotation",e[e.Type_parameter_list_cannot_be_empty=1098]="Type_parameter_list_cannot_be_empty",e[e.Type_argument_list_cannot_be_empty=1099]="Type_argument_list_cannot_be_empty",e[e.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement=1104]="A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement",e[e.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement=1105]="A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement",e[e.A_return_statement_can_only_be_used_within_a_function_body=1108]="A_return_statement_can_only_be_used_within_a_function_body",e[e.Expression_expected=1109]="Expression_expected",e[e.Type_expected=1110]="Type_expected",e[e.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement=1113]="A_default_clause_cannot_appear_more_than_once_in_a_switch_statement",e[e.Duplicate_label_0=1114]="Duplicate_label_0",e[e.An_export_assignment_cannot_have_modifiers=1120]="An_export_assignment_cannot_have_modifiers",e[e.Octal_literals_are_not_allowed_in_strict_mode=1121]="Octal_literals_are_not_allowed_in_strict_mode",e[e.Digit_expected=1124]="Digit_expected",e[e.Hexadecimal_digit_expected=1125]="Hexadecimal_digit_expected",e[e.Unexpected_end_of_text=1126]="Unexpected_end_of_text",e[e.Invalid_character=1127]="Invalid_character",e[e._case_or_default_expected=1130]="_case_or_default_expected",e[e._super_must_be_followed_by_an_argument_list_or_member_access=1034]="_super_must_be_followed_by_an_argument_list_or_member_access",e[e.A_declare_modifier_cannot_be_used_in_an_already_ambient_context=1038]="A_declare_modifier_cannot_be_used_in_an_already_ambient_context",e[e.Type_argument_expected=1140]="Type_argument_expected",e[e.String_literal_expected=1141]="String_literal_expected",e[e.Line_break_not_permitted_here=1142]="Line_break_not_permitted_here",e[e.Declaration_expected=1146]="Declaration_expected",e[e._const_declarations_must_be_initialized=1155]="_const_declarations_must_be_initialized",e[e.Unterminated_regular_expression_literal=1161]="Unterminated_regular_expression_literal",e[e.Interface_declaration_cannot_have_implements_clause=1176]="Interface_declaration_cannot_have_implements_clause",e[e.Binary_digit_expected=1177]="Binary_digit_expected",e[e.Octal_digit_expected=1178]="Octal_digit_expected",e[e.An_implementation_cannot_be_declared_in_ambient_contexts=1183]="An_implementation_cannot_be_declared_in_ambient_contexts",e[e.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer=1190]="The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer",e[e.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive=1198]="An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive",e[e.Unterminated_Unicode_escape_sequence=1199]="Unterminated_Unicode_escape_sequence",e[e.Decorators_are_not_valid_here=1206]="Decorators_are_not_valid_here",e[e._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration=1242]="_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration",e[e.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract=1245]="Method_0_cannot_have_an_implementation_because_it_is_marked_abstract",e[e.A_definite_assignment_assertion_is_not_permitted_in_this_context=1255]="A_definite_assignment_assertion_is_not_permitted_in_this_context",e[e.A_class_may_only_extend_another_class=1311]="A_class_may_only_extend_another_class",e[e.A_parameter_property_cannot_be_declared_using_a_rest_parameter=1317]="A_parameter_property_cannot_be_declared_using_a_rest_parameter",e[e.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal=1351]="An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal",e[e.Duplicate_identifier_0=2300]="Duplicate_identifier_0",e[e.Cannot_find_name_0=2304]="Cannot_find_name_0",e[e.Module_0_has_no_exported_member_1=2305]="Module_0_has_no_exported_member_1",e[e.An_interface_can_only_extend_an_interface=2312]="An_interface_can_only_extend_an_interface",e[e.Generic_type_0_requires_1_type_argument_s=2314]="Generic_type_0_requires_1_type_argument_s",e[e.Type_0_is_not_generic=2315]="Type_0_is_not_generic",e[e.Type_0_is_not_assignable_to_type_1=2322]="Type_0_is_not_assignable_to_type_1",e[e.Index_signature_is_missing_in_type_0=2329]="Index_signature_is_missing_in_type_0",e[e._this_cannot_be_referenced_in_current_location=2332]="_this_cannot_be_referenced_in_current_location",e[e._super_can_only_be_referenced_in_a_derived_class=2335]="_super_can_only_be_referenced_in_a_derived_class",e[e.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors=2337]="Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors",e[e.Property_0_does_not_exist_on_type_1=2339]="Property_0_does_not_exist_on_type_1",e[e.Property_0_is_private_and_only_accessible_within_class_1=2341]="Property_0_is_private_and_only_accessible_within_class_1",e[e.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures=2349]="Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures",e[e.This_expression_is_not_constructable=2351]="This_expression_is_not_constructable",e[e.A_function_whose_declared_type_is_not_void_must_return_a_value=2355]="A_function_whose_declared_type_is_not_void_must_return_a_value",e[e.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access=2357]="The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access",e[e.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access=2364]="The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access",e[e.Operator_0_cannot_be_applied_to_types_1_and_2=2365]="Operator_0_cannot_be_applied_to_types_1_and_2",e[e.A_super_call_must_be_the_first_statement_in_the_constructor=2376]="A_super_call_must_be_the_first_statement_in_the_constructor",e[e.Constructors_for_derived_classes_must_contain_a_super_call=2377]="Constructors_for_derived_classes_must_contain_a_super_call",e[e.Getter_and_setter_accessors_do_not_agree_in_visibility=2379]="Getter_and_setter_accessors_do_not_agree_in_visibility",e[e._get_and_set_accessor_must_have_the_same_type=2380]="_get_and_set_accessor_must_have_the_same_type",e[e.Overload_signatures_must_all_be_public_private_or_protected=2385]="Overload_signatures_must_all_be_public_private_or_protected",e[e.Constructor_implementation_is_missing=2390]="Constructor_implementation_is_missing",e[e.Function_implementation_is_missing_or_not_immediately_following_the_declaration=2391]="Function_implementation_is_missing_or_not_immediately_following_the_declaration",e[e.Multiple_constructor_implementations_are_not_allowed=2392]="Multiple_constructor_implementations_are_not_allowed",e[e.Duplicate_function_implementation=2393]="Duplicate_function_implementation",e[e.This_overload_signature_is_not_compatible_with_its_implementation_signature=2394]="This_overload_signature_is_not_compatible_with_its_implementation_signature",e[e.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local=2395]="Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local",e[e.A_class_can_only_implement_an_interface=2422]="A_class_can_only_implement_an_interface",e[e.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged=2434]="A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged",e[e.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses=2445]="Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses",e[e.Variable_0_used_before_its_declaration=2448]="Variable_0_used_before_its_declaration",e[e.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly=2453]="The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly",e[e.Type_0_has_no_property_1=2460]="Type_0_has_no_property_1",e[e.The_0_operator_cannot_be_applied_to_type_1=2469]="The_0_operator_cannot_be_applied_to_type_1",e[e.In_const_enum_declarations_member_initializer_must_be_constant_expression=2474]="In_const_enum_declarations_member_initializer_must_be_constant_expression",e[e.Export_declaration_conflicts_with_exported_declaration_of_0=2484]="Export_declaration_conflicts_with_exported_declaration_of_0",e[e._0_is_referenced_directly_or_indirectly_in_its_own_base_expression=2506]="_0_is_referenced_directly_or_indirectly_in_its_own_base_expression",e[e.Cannot_create_an_instance_of_an_abstract_class=2511]="Cannot_create_an_instance_of_an_abstract_class",e[e.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2=2515]="Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2",e[e.Object_is_possibly_null=2531]="Object_is_possibly_null",e[e.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property=2540]="Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property",e[e.The_target_of_an_assignment_must_be_a_variable_or_a_property_access=2541]="The_target_of_an_assignment_must_be_a_variable_or_a_property_access",e[e.Index_signature_in_type_0_only_permits_reading=2542]="Index_signature_in_type_0_only_permits_reading",e[e.Expected_0_arguments_but_got_1=2554]="Expected_0_arguments_but_got_1",e[e.Expected_at_least_0_arguments_but_got_1=2555]="Expected_at_least_0_arguments_but_got_1",e[e.Expected_0_type_arguments_but_got_1=2558]="Expected_0_type_arguments_but_got_1",e[e.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned=2564]="Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned",e[e.Property_0_is_used_before_being_assigned=2565]="Property_0_is_used_before_being_assigned",e[e.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums=2651]="A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums",e[e.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration=2673]="Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration",e[e.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration=2674]="Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration",e[e.The_this_types_of_each_signature_are_incompatible=2685]="The_this_types_of_each_signature_are_incompatible",e[e.Namespace_0_has_no_exported_member_1=2694]="Namespace_0_has_no_exported_member_1",e[e.Required_type_parameters_may_not_follow_optional_type_parameters=2706]="Required_type_parameters_may_not_follow_optional_type_parameters",e[e.Duplicate_property_0=2718]="Duplicate_property_0",e[e.Property_0_is_missing_in_type_1_but_required_in_type_2=2741]="Property_0_is_missing_in_type_1_but_required_in_type_2",e[e.Type_0_has_no_call_signatures=2757]="Type_0_has_no_call_signatures",e[e.File_0_not_found=6054]="File_0_not_found",e[e.Numeric_separators_are_not_allowed_here=6188]="Numeric_separators_are_not_allowed_here",e[e.Multiple_consecutive_numeric_separators_are_not_permitted=6189]="Multiple_consecutive_numeric_separators_are_not_permitted",e[e._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class=17009]="_super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class",e[e._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class=17011]="_super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class"}(n.DiagnosticCode||(n.DiagnosticCode={})),n.diagnosticCodeToString=function(e){switch(e){case 100:return"Not implemented: {0}";case 101:return"Operation is unsafe.";case 102:return"User-defined: {0}";case 103:return"Feature '{0}' is not enabled.";case 104:return"Low memory limit exceeded by static data: {0} > {1}";case 105:return"Module requires at least '{0}' pages of initial memory.";case 106:return"Module requires at least '{0}' pages of maximum memory.";case 107:return"Shared memory requires maximum memory to be defined.";case 108:return"Shared memory requires feature 'threads' to be enabled.";case 200:return"Conversion from type '{0}' to '{1}' requires an explicit cast.";case 201:return"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.";case 202:return"Type '{0}' cannot be changed to type '{1}'.";case 203:return"Operation '{0}' cannot be applied to type '{1}'.";case 204:return"Type '{0}' cannot be nullable.";case 205:return"Cannot export a mutable global.";case 206:return"Mutable value cannot be inlined.";case 207:return"Unmanaged classes cannot extend managed classes and vice-versa.";case 208:return"Unmanaged classes cannot implement interfaces.";case 209:return"Invalid regular expression flags.";case 210:return"Expression is never 'null'.";case 211:return"Class '{0}' is final and cannot be extended.";case 212:return"Decorator '{0}' is not valid here.";case 213:return"Duplicate decorator.";case 214:return"Type '{0}' is illegal in this context.";case 215:return"Optional parameter must have an initializer.";case 216:return"Class '{0}' cannot declare a constructor when instantiated from an object literal.";case 217:return"Function '{0}' cannot be inlined into itself.";case 218:return"Cannot access method '{0}' without calling it as it requires 'this' to be set.";case 219:return"Optional properties are not supported.";case 220:return"Expression must be a compile-time constant.";case 221:return"Type '{0}' is not a function index or function reference.";case 222:return"'{0}' must be a value between '{1}' and '{2}' inclusive.";case 223:return"'{0}' must be a power of two.";case 224:return"'{0}' is not a valid operator.";case 225:return"Expression cannot be represented by a type.";case 226:return"Expression resolves to unusual type '{0}'.";case 227:return"Array literal expected.";case 228:return"Function '{0}' is virtual and will not be inlined.";case 229:return"Property '{0}' only has a setter and is missing a getter.";case 230:return"'{0}' keyword cannot be used here.";case 231:return"A class with a constructor explicitly returning something else than 'this' must be '@final'.";case 232:return"Exported generic function or class has no concrete instances.";case 233:return"Property '{0}' is always assigned before being used.";case 234:return"Expression refers to a static element that does not compile to a value at runtime.";case 901:return"Importing the table disables some indirect call optimizations.";case 902:return"Exporting the table disables some indirect call optimizations.";case 903:return"Expression compiles to a dynamic check at runtime.";case 904:return"Indexed access may involve bounds checking.";case 905:return"Explicitly returning constructor drops 'this' allocation.";case 906:return"Unnecessary definite assignment.";case 1002:return"Unterminated string literal.";case 1003:return"Identifier expected.";case 1005:return"'{0}' expected.";case 1006:return"A file cannot have a reference to itself.";case 1009:return"Trailing comma not allowed.";case 1012:return"Unexpected token.";case 1014:return"A rest parameter must be last in a parameter list.";case 1015:return"Parameter cannot have question mark and initializer.";case 1016:return"A required parameter cannot follow an optional parameter.";case 1036:return"Statements are not allowed in ambient contexts.";case 1039:return"Initializers are not allowed in ambient contexts.";case 1042:return"'{0}' modifier cannot be used here.";case 1047:return"A rest parameter cannot be optional.";case 1048:return"A rest parameter cannot have an initializer.";case 1049:return"A 'set' accessor must have exactly one parameter.";case 1052:return"A 'set' accessor parameter cannot have an initializer.";case 1054:return"A 'get' accessor cannot have parameters.";case 1061:return"Enum member must have initializer.";case 1092:return"Type parameters cannot appear on a constructor declaration.";case 1093:return"Type annotation cannot appear on a constructor declaration.";case 1094:return"An accessor cannot have type parameters.";case 1095:return"A 'set' accessor cannot have a return type annotation.";case 1098:return"Type parameter list cannot be empty.";case 1099:return"Type argument list cannot be empty.";case 1104:return"A 'continue' statement can only be used within an enclosing iteration statement.";case 1105:return"A 'break' statement can only be used within an enclosing iteration or switch statement.";case 1108:return"A 'return' statement can only be used within a function body.";case 1109:return"Expression expected.";case 1110:return"Type expected.";case 1113:return"A 'default' clause cannot appear more than once in a 'switch' statement.";case 1114:return"Duplicate label '{0}'.";case 1120:return"An export assignment cannot have modifiers.";case 1121:return"Octal literals are not allowed in strict mode.";case 1124:return"Digit expected.";case 1125:return"Hexadecimal digit expected.";case 1126:return"Unexpected end of text.";case 1127:return"Invalid character.";case 1130:return"'case' or 'default' expected.";case 1034:return"'super' must be followed by an argument list or member access.";case 1038:return"A 'declare' modifier cannot be used in an already ambient context.";case 1140:return"Type argument expected.";case 1141:return"String literal expected.";case 1142:return"Line break not permitted here.";case 1146:return"Declaration expected.";case 1155:return"'const' declarations must be initialized.";case 1161:return"Unterminated regular expression literal.";case 1176:return"Interface declaration cannot have 'implements' clause.";case 1177:return"Binary digit expected.";case 1178:return"Octal digit expected.";case 1183:return"An implementation cannot be declared in ambient contexts.";case 1190:return"The variable declaration of a 'for...of' statement cannot have an initializer.";case 1198:return"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.";case 1199:return"Unterminated Unicode escape sequence.";case 1206:return"Decorators are not valid here.";case 1242:return"'abstract' modifier can only appear on a class, method, or property declaration.";case 1245:return"Method '{0}' cannot have an implementation because it is marked abstract.";case 1255:return"A definite assignment assertion '!' is not permitted in this context.";case 1311:return"A class may only extend another class.";case 1317:return"A parameter property cannot be declared using a rest parameter.";case 1351:return"An identifier or keyword cannot immediately follow a numeric literal.";case 2300:return"Duplicate identifier '{0}'.";case 2304:return"Cannot find name '{0}'.";case 2305:return"Module '{0}' has no exported member '{1}'.";case 2312:return"An interface can only extend an interface.";case 2314:return"Generic type '{0}' requires {1} type argument(s).";case 2315:return"Type '{0}' is not generic.";case 2322:return"Type '{0}' is not assignable to type '{1}'.";case 2329:return"Index signature is missing in type '{0}'.";case 2332:return"'this' cannot be referenced in current location.";case 2335:return"'super' can only be referenced in a derived class.";case 2337:return"Super calls are not permitted outside constructors or in nested functions inside constructors.";case 2339:return"Property '{0}' does not exist on type '{1}'.";case 2341:return"Property '{0}' is private and only accessible within class '{1}'.";case 2349:return"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.";case 2351:return"This expression is not constructable.";case 2355:return"A function whose declared type is not 'void' must return a value.";case 2357:return"The operand of an increment or decrement operator must be a variable or a property access.";case 2364:return"The left-hand side of an assignment expression must be a variable or a property access.";case 2365:return"Operator '{0}' cannot be applied to types '{1}' and '{2}'.";case 2376:return"A 'super' call must be the first statement in the constructor.";case 2377:return"Constructors for derived classes must contain a 'super' call.";case 2379:return"Getter and setter accessors do not agree in visibility.";case 2380:return"'get' and 'set' accessor must have the same type.";case 2385:return"Overload signatures must all be public, private or protected.";case 2390:return"Constructor implementation is missing.";case 2391:return"Function implementation is missing or not immediately following the declaration.";case 2392:return"Multiple constructor implementations are not allowed.";case 2393:return"Duplicate function implementation.";case 2394:return"This overload signature is not compatible with its implementation signature.";case 2395:return"Individual declarations in merged declaration '{0}' must be all exported or all local.";case 2422:return"A class can only implement an interface.";case 2434:return"A namespace declaration cannot be located prior to a class or function with which it is merged.";case 2445:return"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.";case 2448:return"Variable '{0}' used before its declaration.";case 2453:return"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.";case 2460:return"Type '{0}' has no property '{1}'.";case 2469:return"The '{0}' operator cannot be applied to type '{1}'.";case 2474:return"In 'const' enum declarations member initializer must be constant expression.";case 2484:return"Export declaration conflicts with exported declaration of '{0}'.";case 2506:return"'{0}' is referenced directly or indirectly in its own base expression.";case 2511:return"Cannot create an instance of an abstract class.";case 2515:return"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.";case 2531:return"Object is possibly 'null'.";case 2540:return"Cannot assign to '{0}' because it is a constant or a read-only property.";case 2541:return"The target of an assignment must be a variable or a property access.";case 2542:return"Index signature in type '{0}' only permits reading.";case 2554:return"Expected {0} arguments, but got {1}.";case 2555:return"Expected at least {0} arguments, but got {1}.";case 2558:return"Expected {0} type arguments, but got {1}.";case 2564:return"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.";case 2565:return"Property '{0}' is used before being assigned.";case 2651:return"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.";case 2673:return"Constructor of class '{0}' is private and only accessible within the class declaration.";case 2674:return"Constructor of class '{0}' is protected and only accessible within the class declaration.";case 2685:return"The 'this' types of each signature are incompatible.";case 2694:return"Namespace '{0}' has no exported member '{1}'.";case 2706:return"Required type parameters may not follow optional type parameters.";case 2718:return"Duplicate property '{0}'.";case 2741:return"Property '{0}' is missing in type '{1}' but required in type '{2}'.";case 2757:return"Type '{0}' has no call signatures.";case 6054:return"File '{0}' not found.";case 6188:return"Numeric separators are not allowed here.";case 6189:return"Multiple consecutive numeric separators are not permitted.";case 17009:return"'super' must be called before accessing 'this' in the constructor of a derived class.";case 17011:return"'super' must be called before accessing a property of 'super' in the constructor of a derived class.";default:return""}}},256:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.DiagnosticEmitter=n.formatDiagnosticMessage=n.DiagnosticMessage=n.diagnosticCategoryToColor=n.diagnosticCategoryToString=n.DiagnosticCategory=n.diagnosticCodeToString=n.DiagnosticCode=void 0;const r=t(252),i=t(910);var a,s=t(252);function o(e){switch(e){case a.PEDANTIC:return"PEDANTIC";case a.INFO:return"INFO";case a.WARNING:return"WARNING";case a.ERROR:return"ERROR";default:return assert(!1),""}}function l(e){switch(e){case a.PEDANTIC:return i.COLOR_MAGENTA;case a.INFO:return i.COLOR_CYAN;case a.WARNING:return i.COLOR_YELLOW;case a.ERROR:return i.COLOR_RED;default:return assert(!1),""}}Object.defineProperty(n,"DiagnosticCode",{enumerable:!0,get:function(){return s.DiagnosticCode}}),Object.defineProperty(n,"diagnosticCodeToString",{enumerable:!0,get:function(){return s.diagnosticCodeToString}}),function(e){e[e.PEDANTIC=0]="PEDANTIC",e[e.INFO=1]="INFO",e[e.WARNING=2]="WARNING",e[e.ERROR=3]="ERROR"}(a=n.DiagnosticCategory||(n.DiagnosticCategory={})),n.diagnosticCategoryToString=o,n.diagnosticCategoryToColor=l;class u{constructor(e,n,t){this.range=null,this.relatedRange=null,this.code=e,this.category=n,this.message=t}static create(e,n,t=null,i=null,a=null){var s=r.diagnosticCodeToString(e);return null!==t&&(s=s.replace("{0}",t)),null!==i&&(s=s.replace("{1}",i)),null!==a&&(s=s.replace("{2}",a)),new u(e,n,s)}equals(e){if(this.code!=e.code)return!1;var n=this.range,t=e.range;if(n){if(!t||!n.equals(t))return!1}else if(t)return!1;var r=this.relatedRange,i=e.relatedRange;if(r){if(!i||!r.equals(i))return!1}else if(t)return!1;return this.message==e.message}withRange(e){return this.range=e,this}withRelatedRange(e){return this.relatedRange=e,this}toString(){var e=this.range;if(e){let n=e.source;return o(this.category)+" "+this.code.toString()+': "'+this.message+'" in '+n.normalizedPath+"("+n.lineAt(e.start).toString()+","+n.columnAt().toString()+"+"+(e.end-e.start).toString()+")"}return o(this.category)+" "+this.code.toString()+": "+this.message}}function c(e){for(var n=e.source.text,t=n.length,r=e.start,a=e.end;r>0&&!i.isLineBreak(n.charCodeAt(r-1));)r--;for(;a<t&&!i.isLineBreak(n.charCodeAt(a));)a++;for(var s=["\n ",n.substring(r,a),"\n "];r<e.start;)s.push(" "),r++;if(i.isColorsEnabled()&&s.push(i.COLOR_RED),e.start==e.end)s.push("^");else for(;r++<e.end;){if(i.isLineBreak(n.charCodeAt(r))){s.push(r==e.start+1?"^":"~");break}s.push("~")}return i.isColorsEnabled()&&s.push(i.COLOR_RESET),s.join("")}n.DiagnosticMessage=u,n.formatDiagnosticMessage=function(e,n=!1,t=!1){var r=i.setColorsEnabled(n),a=[];i.isColorsEnabled()&&a.push(l(e.category)),a.push(o(e.category)),i.isColorsEnabled()&&a.push(i.COLOR_RESET),a.push(e.code<1e3?" AS":" TS"),a.push(e.code.toString()),a.push(": "),a.push(e.message);var s=e.range;if(s){let n=s.source;t&&(a.push("\n"),a.push(c(s))),a.push("\n"),a.push(" in "),a.push(n.normalizedPath),a.push("("),a.push(n.lineAt(s.start).toString()),a.push(","),a.push(n.columnAt().toString()),a.push(")");let r=e.relatedRange;if(r){let e=r.source;t&&(a.push("\n"),a.push(c(r))),a.push("\n"),a.push(" in "),a.push(e.normalizedPath),a.push("("),a.push(e.lineAt(r.start).toString()),a.push(","),a.push(e.columnAt().toString()),a.push(")")}}return i.setColorsEnabled(r),a.join("")},n.DiagnosticEmitter=class{constructor(e=null){this.seen=new Map,e||(e=[]),this.diagnostics=e}emitDiagnostic(e,n,t,r,i=null,a=null,s=null){var o=u.create(e,n,i,a,s);if(t&&(o=o.withRange(t)),r&&(o.relatedRange=r),t){let e=this.seen;if(e.has(t.source)){let n=assert(e.get(t.source));if(n.has(t.start)){let e=assert(n.get(t.start));for(let n=0,t=e.length;n<t;++n)if(e[n].equals(o))return;e.push(o)}else n.set(t.start,[o])}else{let n=new Map;n.set(t.start,[o]),e.set(t.source,n)}}this.diagnostics.push(o)}pedantic(e,n,t=null,r=null,i=null){this.emitDiagnostic(e,a.PEDANTIC,n,null,t,r,i)}pedanticRelated(e,n,t,r=null,i=null,s=null){this.emitDiagnostic(e,a.PEDANTIC,n,t,r,i,s)}info(e,n,t=null,r=null,i=null){this.emitDiagnostic(e,a.INFO,n,null,t,r,i)}infoRelated(e,n,t,r=null,i=null,s=null){this.emitDiagnostic(e,a.INFO,n,t,r,i,s)}warning(e,n,t=null,r=null,i=null){this.emitDiagnostic(e,a.WARNING,n,null,t,r,i)}warningRelated(e,n,t,r=null,i=null,s=null){this.emitDiagnostic(e,a.WARNING,n,t,r,i,s)}error(e,n,t=null,r=null,i=null){this.emitDiagnostic(e,a.ERROR,n,null,t,r,i)}errorRelated(e,n,t,r=null,i=null,s=null){this.emitDiagnostic(e,a.ERROR,n,t,r,i,s)}}},393:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ASTBuilder=void 0;const r=t(60),i=t(411),a=t(910),s=t(200);class o{constructor(){this.sb=[],this.indentLevel=0}static build(e){var n=new o;return n.visitNode(e),n.finish()}visitNode(e){switch(e.kind){case r.NodeKind.SOURCE:this.visitSource(e);break;case r.NodeKind.NAMEDTYPE:this.visitNamedTypeNode(e);break;case r.NodeKind.FUNCTIONTYPE:this.visitFunctionTypeNode(e);break;case r.NodeKind.TYPEPARAMETER:this.visitTypeParameter(e);break;case r.NodeKind.FALSE:case r.NodeKind.NULL:case r.NodeKind.SUPER:case r.NodeKind.THIS:case r.NodeKind.TRUE:case r.NodeKind.CONSTRUCTOR:case r.NodeKind.IDENTIFIER:this.visitIdentifierExpression(e);break;case r.NodeKind.ASSERTION:this.visitAssertionExpression(e);break;case r.NodeKind.BINARY:this.visitBinaryExpression(e);break;case r.NodeKind.CALL:this.visitCallExpression(e);break;case r.NodeKind.CLASS:this.visitClassExpression(e);break;case r.NodeKind.COMMA:this.visitCommaExpression(e);break;case r.NodeKind.ELEMENTACCESS:this.visitElementAccessExpression(e);break;case r.NodeKind.FUNCTION:this.visitFunctionExpression(e);break;case r.NodeKind.INSTANCEOF:this.visitInstanceOfExpression(e);break;case r.NodeKind.LITERAL:this.visitLiteralExpression(e);break;case r.NodeKind.NEW:this.visitNewExpression(e);break;case r.NodeKind.PARENTHESIZED:this.visitParenthesizedExpression(e);break;case r.NodeKind.PROPERTYACCESS:this.visitPropertyAccessExpression(e);break;case r.NodeKind.TERNARY:this.visitTernaryExpression(e);break;case r.NodeKind.UNARYPOSTFIX:this.visitUnaryPostfixExpression(e);break;case r.NodeKind.UNARYPREFIX:this.visitUnaryPrefixExpression(e);break;case r.NodeKind.BLOCK:this.visitBlockStatement(e);break;case r.NodeKind.BREAK:this.visitBreakStatement(e);break;case r.NodeKind.CONTINUE:this.visitContinueStatement(e);break;case r.NodeKind.DO:this.visitDoStatement(e);break;case r.NodeKind.EMPTY:this.visitEmptyStatement(e);break;case r.NodeKind.EXPORT:this.visitExportStatement(e);break;case r.NodeKind.EXPORTDEFAULT:this.visitExportDefaultStatement(e);break;case r.NodeKind.EXPORTIMPORT:this.visitExportImportStatement(e);break;case r.NodeKind.EXPRESSION:this.visitExpressionStatement(e);break;case r.NodeKind.FOR:this.visitForStatement(e);break;case r.NodeKind.FOROF:this.visitForOfStatement(e);break;case r.NodeKind.IF:this.visitIfStatement(e);break;case r.NodeKind.IMPORT:this.visitImportStatement(e);break;case r.NodeKind.RETURN:this.visitReturnStatement(e);break;case r.NodeKind.SWITCH:this.visitSwitchStatement(e);break;case r.NodeKind.THROW:this.visitThrowStatement(e);break;case r.NodeKind.TRY:this.visitTryStatement(e);break;case r.NodeKind.VARIABLE:this.visitVariableStatement(e);break;case r.NodeKind.WHILE:this.visitWhileStatement(e);break;case r.NodeKind.CLASSDECLARATION:this.visitClassDeclaration(e);break;case r.NodeKind.ENUMDECLARATION:this.visitEnumDeclaration(e);break;case r.NodeKind.ENUMVALUEDECLARATION:this.visitEnumValueDeclaration(e);break;case r.NodeKind.FIELDDECLARATION:this.visitFieldDeclaration(e);break;case r.NodeKind.FUNCTIONDECLARATION:this.visitFunctionDeclaration(e);break;case r.NodeKind.IMPORTDECLARATION:this.visitImportDeclaration(e);break;case r.NodeKind.INTERFACEDECLARATION:this.visitInterfaceDeclaration(e);break;case r.NodeKind.METHODDECLARATION:this.visitMethodDeclaration(e);break;case r.NodeKind.NAMESPACEDECLARATION:this.visitNamespaceDeclaration(e);break;case r.NodeKind.TYPEDECLARATION:this.visitTypeDeclaration(e);break;case r.NodeKind.VARIABLEDECLARATION:this.visitVariableDeclaration(e);break;case r.NodeKind.DECORATOR:this.serializeDecorator(e);break;case r.NodeKind.EXPORTMEMBER:this.visitExportMember(e);break;case r.NodeKind.PARAMETER:this.serializeParameter(e);break;case r.NodeKind.SWITCHCASE:this.visitSwitchCase(e);break;case r.NodeKind.INDEXSIGNATURE:this.visitIndexSignature(e);break;default:assert(!1)}}visitSource(e){var n=e.statements;for(let e=0,t=n.length;e<t;++e)this.visitNodeAndTerminate(n[e])}visitTypeNode(e){switch(e.kind){case r.NodeKind.NAMEDTYPE:this.visitNamedTypeNode(e);break;case r.NodeKind.FUNCTIONTYPE:this.visitFunctionTypeNode(e);break;default:assert(!1)}}visitTypeName(e){this.visitIdentifierExpression(e.identifier);for(var n=this.sb,t=e.next;t;)n.push("."),this.visitIdentifierExpression(t.identifier),t=t.next}visitNamedTypeNode(e){this.visitTypeName(e.name);var n=e.typeArguments;if(n){let t=n.length,r=this.sb;if(t){r.push("<"),this.visitTypeNode(n[0]);for(let e=1;e<t;++e)r.push(", "),this.visitTypeNode(n[e]);r.push(">")}e.isNullable&&r.push(" | null")}}visitFunctionTypeNode(e){var n=e.isNullable,t=this.sb;t.push(n?"((":"(");var r=e.explicitThisType;r&&(t.push("this: "),this.visitTypeNode(r));var i=e.parameters,a=i.length;if(a){r&&t.push(", "),this.serializeParameter(i[0]);for(let e=1;e<a;++e)t.push(", "),this.serializeParameter(i[e])}var s=e.returnType;s?(t.push(") => "),this.visitTypeNode(s)):t.push(") => void"),n&&t.push(") | null")}visitTypeParameter(e){this.visitIdentifierExpression(e.name);var n=e.extendsType;n&&(this.sb.push(" extends "),this.visitTypeNode(n));var t=e.defaultType;t&&(this.sb.push("="),this.visitTypeNode(t))}visitIdentifierExpression(e){e.isQuoted?this.visitStringLiteral(e.text):this.sb.push(e.text)}visitArrayLiteralExpression(e){var n=this.sb;n.push("[");var t=e.elementExpressions,r=t.length;if(r){let e=t[0];e&&this.visitNode(e);for(let i=1;i<r;++i)e=t[i],n.push(", "),e&&this.visitNode(e)}n.push("]")}visitObjectLiteralExpression(e){var n=this.sb,t=e.names,r=e.values,i=t.length;if(assert(i==r.length),i){n.push("{\n"),a.indent(n,++this.indentLevel),this.visitNode(t[0]),n.push(": "),this.visitNode(r[0]);for(let e=1;e<i;++e){n.push(",\n"),a.indent(n,this.indentLevel);let i=t[e],s=r[e];i===s?this.visitNode(i):(this.visitNode(i),n.push(": "),this.visitNode(s))}n.push("\n"),a.indent(n,--this.indentLevel),n.push("}")}else n.push("{}")}visitAssertionExpression(e){var n=this.sb;switch(e.assertionKind){case r.AssertionKind.PREFIX:n.push("<"),this.visitTypeNode(assert(e.toType)),n.push(">"),this.visitNode(e.expression);break;case r.AssertionKind.AS:this.visitNode(e.expression),n.push(" as "),this.visitTypeNode(assert(e.toType));break;case r.AssertionKind.NONNULL:this.visitNode(e.expression),n.push("!");break;case r.AssertionKind.CONST:this.visitNode(e.expression),n.push(" as const");break;default:assert(!1)}}visitBinaryExpression(e){var n=this.sb;this.visitNode(e.left),n.push(" "),n.push(i.operatorTokenToString(e.operator)),n.push(" "),this.visitNode(e.right)}visitCallExpression(e){this.visitNode(e.expression),this.visitArguments(e.typeArguments,e.args)}visitArguments(e,n){var t=this.sb;if(e){let n=e.length;if(n){t.push("<"),this.visitTypeNode(e[0]);for(let r=1;r<n;++r)t.push(", "),this.visitTypeNode(e[r]);t.push(">(")}}else t.push("(");var r=n.length;if(r){this.visitNode(n[0]);for(let e=1;e<r;++e)t.push(", "),this.visitNode(n[e])}t.push(")")}visitClassExpression(e){var n=e.declaration;this.visitClassDeclaration(n)}visitCommaExpression(e){var n=e.expressions,t=assert(n.length);this.visitNode(n[0]);var r=this.sb;for(let e=1;e<t;++e)r.push(","),this.visitNode(n[e])}visitElementAccessExpression(e){var n=this.sb;this.visitNode(e.expression),n.push("["),this.visitNode(e.elementExpression),n.push("]")}visitFunctionExpression(e){var n=e.declaration;n.arrowKind?assert(0==n.name.text.length):n.name.text.length?this.sb.push("function "):this.sb.push("function"),this.visitFunctionCommon(n)}visitLiteralExpression(e){switch(e.literalKind){case r.LiteralKind.FLOAT:this.visitFloatLiteralExpression(e);break;case r.LiteralKind.INTEGER:this.visitIntegerLiteralExpression(e);break;case r.LiteralKind.STRING:this.visitStringLiteralExpression(e);break;case r.LiteralKind.REGEXP:this.visitRegexpLiteralExpression(e);break;case r.LiteralKind.ARRAY:this.visitArrayLiteralExpression(e);break;case r.LiteralKind.OBJECT:this.visitObjectLiteralExpression(e);break;default:assert(!1)}}visitFloatLiteralExpression(e){this.sb.push(e.value.toString())}visitInstanceOfExpression(e){this.visitNode(e.expression),this.sb.push(" instanceof "),this.visitTypeNode(e.isType)}visitIntegerLiteralExpression(e){this.sb.push(i64_to_string(e.value))}visitStringLiteral(e,n=!1){var t=this.sb,r=0,i=n?"'":'"';t.push(i);var a=0;for(let i=e.length;a<i;)switch(e.charCodeAt(a)){case 0:a>r&&t.push(e.substring(r,r=a+1)),t.push("\\0"),r=++a;break;case 8:a>r&&t.push(e.substring(r,a)),r=++a,t.push("\\b");break;case 9:a>r&&t.push(e.substring(r,a)),r=++a,t.push("\\t");break;case 10:a>r&&t.push(e.substring(r,a)),r=++a,t.push("\\n");break;case 11:a>r&&t.push(e.substring(r,a)),r=++a,t.push("\\v");break;case 12:a>r&&t.push(e.substring(r,a)),r=++a,t.push("\\f");break;case 13:a>r&&t.push(e.substring(r,a)),t.push("\\r"),r=++a;break;case 34:n?++a:(a>r&&t.push(e.substring(r,a)),t.push('\\"'),r=++a);break;case 39:n?(a>r&&t.push(e.substring(r,a)),t.push("\\'"),r=++a):++a;break;case 92:a>r&&t.push(e.substring(r,a)),t.push("\\\\"),r=++a;break;default:++a}a>r&&t.push(e.substring(r,a)),t.push(i)}visitStringLiteralExpression(e){this.visitStringLiteral(e.value)}visitRegexpLiteralExpression(e){var n=this.sb;n.push("/"),n.push(e.pattern),n.push("/"),n.push(e.patternFlags)}visitNewExpression(e){this.sb.push("new "),this.visitTypeName(e.typeName),this.visitArguments(e.typeArguments,e.args)}visitParenthesizedExpression(e){var n=this.sb;n.push("("),this.visitNode(e.expression),n.push(")")}visitPropertyAccessExpression(e){this.visitNode(e.expression),this.sb.push("."),this.visitIdentifierExpression(e.property)}visitTernaryExpression(e){var n=this.sb;this.visitNode(e.condition),n.push(" ? "),this.visitNode(e.ifThen),n.push(" : "),this.visitNode(e.ifElse)}visitUnaryExpression(e){switch(e.kind){case r.NodeKind.UNARYPOSTFIX:this.visitUnaryPostfixExpression(e);break;case r.NodeKind.UNARYPREFIX:this.visitUnaryPrefixExpression(e);break;default:assert(!1)}}visitUnaryPostfixExpression(e){this.visitNode(e.operand),this.sb.push(i.operatorTokenToString(e.operator))}visitUnaryPrefixExpression(e){this.sb.push(i.operatorTokenToString(e.operator)),this.visitNode(e.operand)}visitNodeAndTerminate(e){this.visitNode(e);var n=this.sb;if(n.length&&e.kind!=r.NodeKind.VARIABLE&&e.kind!=r.NodeKind.EXPRESSION){let e=n[n.length-1],t=e.length-1;t>=0&&(125==e.charCodeAt(t)||59==e.charCodeAt(t))?n.push("\n"):n.push(";\n")}else n.push(";\n")}visitBlockStatement(e){var n=this.sb,t=e.statements,r=t.length;if(r){n.push("{\n");let e=++this.indentLevel;for(let i=0;i<r;++i)a.indent(n,e),this.visitNodeAndTerminate(t[i]);a.indent(n,--this.indentLevel),n.push("}")}else n.push("{}")}visitBreakStatement(e){var n=e.label;n?(this.sb.push("break "),this.visitIdentifierExpression(n)):this.sb.push("break")}visitContinueStatement(e){var n=e.label;n?(this.sb.push("continue "),this.visitIdentifierExpression(n)):this.sb.push("continue")}visitClassDeclaration(e,n=!1){var t=e.decorators;if(t)for(let e=0,n=t.length;e<n;++e)this.serializeDecorator(t[e]);var i=this.sb;n?i.push("export default "):this.serializeExternalModifiers(e),e.is(s.CommonFlags.ABSTRACT)&&i.push("abstract "),e.name.text.length?(i.push("class "),this.visitIdentifierExpression(e.name)):i.push("class");var o=e.typeParameters;if(null!=o&&o.length>0){i.push("<"),this.visitTypeParameter(o[0]);for(let e=1,n=o.length;e<n;++e)i.push(", "),this.visitTypeParameter(o[e]);i.push(">")}var l=e.extendsType;l&&(i.push(" extends "),this.visitTypeNode(l));var u=e.implementsTypes;if(u){let e=u.length;if(e){i.push(" implements "),this.visitTypeNode(u[0]);for(let n=1;n<e;++n)i.push(", "),this.visitTypeNode(u[n])}}var c=e.indexSignature,p=e.members,f=p.length;if(null!==c||f){i.push(" {\n");let e=++this.indentLevel;c&&(a.indent(i,e),this.visitNodeAndTerminate(c));for(let n=0,t=p.length;n<t;++n){let t=p[n];(t.kind!=r.NodeKind.FIELDDECLARATION||t.parameterIndex<0)&&(a.indent(i,e),this.visitNodeAndTerminate(t))}a.indent(i,--this.indentLevel),i.push("}")}else i.push(" {}")}visitDoStatement(e){var n=this.sb;n.push("do "),this.visitNode(e.statement),e.statement.kind==r.NodeKind.BLOCK?n.push(" while ("):(n.push(";\n"),a.indent(n,this.indentLevel),n.push("while (")),this.visitNode(e.condition),n.push(")")}visitEmptyStatement(e){}visitEnumDeclaration(e,n=!1){var t=this.sb;n?t.push("export default "):this.serializeExternalModifiers(e),e.is(s.CommonFlags.CONST)&&t.push("const "),t.push("enum "),this.visitIdentifierExpression(e.name);var r=e.values.length;if(r){t.push(" {\n");let n=++this.indentLevel;a.indent(t,n),this.visitEnumValueDeclaration(e.values[0]);for(let i=1;i<r;++i)t.push(",\n"),a.indent(t,n),this.visitEnumValueDeclaration(e.values[i]);t.push("\n"),a.indent(t,--this.indentLevel),t.push("}")}else t.push(" {}")}visitEnumValueDeclaration(e){this.visitIdentifierExpression(e.name);var n=e.initializer;n&&(this.sb.push(" = "),this.visitNode(n))}visitExportImportStatement(e){var n=this.sb;n.push("export import "),this.visitIdentifierExpression(e.externalName),n.push(" = "),this.visitIdentifierExpression(e.name)}visitExportMember(e){this.visitIdentifierExpression(e.localName),e.exportedName.text!=e.localName.text&&(this.sb.push(" as "),this.visitIdentifierExpression(e.exportedName))}visitExportStatement(e){var n=this.sb;e.isDeclare&&n.push("declare ");var t=e.members;if(null!=t&&t.length>0){let e=t.length;n.push("export {\n");let r=++this.indentLevel;a.indent(n,r),this.visitExportMember(t[0]);for(let i=1;i<e;++i)n.push(",\n"),a.indent(n,r),this.visitExportMember(t[i]);--this.indentLevel,n.push("\n}")}else n.push("export {}");var r=e.path;r&&(n.push(" from "),this.visitStringLiteralExpression(r)),n.push(";")}visitExportDefaultStatement(e){var n=e.declaration;switch(n.kind){case r.NodeKind.ENUMDECLARATION:this.visitEnumDeclaration(n,!0);break;case r.NodeKind.FUNCTIONDECLARATION:this.visitFunctionDeclaration(n,!0);break;case r.NodeKind.CLASSDECLARATION:this.visitClassDeclaration(n,!0);break;case r.NodeKind.INTERFACEDECLARATION:this.visitInterfaceDeclaration(n,!0);break;case r.NodeKind.NAMESPACEDECLARATION:this.visitNamespaceDeclaration(n,!0);break;default:assert(!1)}}visitExpressionStatement(e){this.visitNode(e.expression)}visitFieldDeclaration(e){var n=e.decorators;if(n)for(let e=0,t=n.length;e<t;++e)this.serializeDecorator(n[e]);this.serializeAccessModifiers(e),this.visitIdentifierExpression(e.name);var t=this.sb;e.flags&s.CommonFlags.DEFINITELY_ASSIGNED&&t.push("!");var r=e.type;r&&(t.push(": "),this.visitTypeNode(r));var i=e.initializer;i&&(t.push(" = "),this.visitNode(i))}visitForStatement(e){var n=this.sb;n.push("for (");var t=e.initializer;t&&this.visitNode(t);var r=e.condition;r?(n.push("; "),this.visitNode(r)):n.push(";");var i=e.incrementor;i?(n.push("; "),this.visitNode(i)):n.push(";"),n.push(") "),this.visitNode(e.statement)}visitForOfStatement(e){var n=this.sb;n.push("for ("),this.visitNode(e.variable),n.push(" of "),this.visitNode(e.iterable),n.push(") "),this.visitNode(e.statement)}visitFunctionDeclaration(e,n=!1){var t=this.sb,r=e.decorators;if(r)for(let e=0,n=r.length;e<n;++e)this.serializeDecorator(r[e]);n?t.push("export default "):(this.serializeExternalModifiers(e),this.serializeAccessModifiers(e)),e.name.text.length?t.push("function "):t.push("function"),this.visitFunctionCommon(e)}visitFunctionCommon(e){var n=this.sb;this.visitIdentifierExpression(e.name);var t=e.signature,i=e.typeParameters;if(i){let e=i.length;if(e){n.push("<"),this.visitTypeParameter(i[0]);for(let t=1;t<e;++t)n.push(", "),this.visitTypeParameter(i[t]);n.push(">")}}if(2==e.arrowKind){let e=t.parameters;assert(1==e.length),assert(!t.explicitThisType),this.serializeParameter(e[0])}else{n.push("(");let e=t.parameters,r=e.length,i=t.explicitThisType;if(i&&(n.push("this: "),this.visitTypeNode(i)),r){i&&n.push(", "),this.serializeParameter(e[0]);for(let t=1;t<r;++t)n.push(", "),this.serializeParameter(e[t])}}var a=e.body,o=t.returnType;e.arrowKind?a?(2==e.arrowKind?assert(r.isTypeOmitted(o)):r.isTypeOmitted(o)?n.push(")"):(n.push("): "),this.visitTypeNode(o)),n.push(" => "),this.visitNode(a)):(assert(!r.isTypeOmitted(o)),n.push(" => "),this.visitTypeNode(o)):(r.isTypeOmitted(o)||e.isAny(s.CommonFlags.CONSTRUCTOR|s.CommonFlags.SET)?n.push(")"):(n.push("): "),this.visitTypeNode(o)),a&&(n.push(" "),this.visitNode(a)))}visitIfStatement(e){var n=this.sb;n.push("if ("),this.visitNode(e.condition),n.push(") ");var t=e.ifTrue;this.visitNode(t),t.kind!=r.NodeKind.BLOCK&&n.push(";\n");var i=e.ifFalse;i&&(t.kind==r.NodeKind.BLOCK?n.push(" else "):n.push("else "),this.visitNode(i))}visitImportDeclaration(e){var n=e.foreignName,t=e.name;this.visitIdentifierExpression(n),n.text!=t.text&&(this.sb.push(" as "),this.visitIdentifierExpression(t))}visitImportStatement(e){var n=this.sb;n.push("import ");var t=e.declarations,r=e.namespaceName;if(t){let e=t.length;if(e){n.push("{\n");let r=++this.indentLevel;a.indent(n,r),this.visitImportDeclaration(t[0]);for(let i=1;i<e;++i)n.push(",\n"),a.indent(n,r),this.visitImportDeclaration(t[i]);--this.indentLevel,n.push("\n} from ")}else n.push("{} from ")}else r&&(n.push("* as "),this.visitIdentifierExpression(r),n.push(" from "));this.visitStringLiteralExpression(e.path)}visitIndexSignature(e){var n=this.sb;n.push("[key: "),this.visitTypeNode(e.keyType),n.push("]: "),this.visitTypeNode(e.valueType)}visitInterfaceDeclaration(e,n=!1){var t=e.decorators;if(t)for(let e=0,n=t.length;e<n;++e)this.serializeDecorator(t[e]);var r=this.sb;n?r.push("export default "):this.serializeExternalModifiers(e),r.push("interface "),this.visitIdentifierExpression(e.name);var i=e.typeParameters;if(null!=i&&i.length>0){r.push("<"),this.visitTypeParameter(i[0]);for(let e=1,n=i.length;e<n;++e)r.push(", "),this.visitTypeParameter(i[e]);r.push(">")}var s=e.extendsType;s&&(r.push(" extends "),this.visitTypeNode(s)),r.push(" {\n");var o=++this.indentLevel,l=e.members;for(let e=0,n=l.length;e<n;++e)a.indent(r,o),this.visitNodeAndTerminate(l[e]);--this.indentLevel,r.push("}")}visitMethodDeclaration(e){var n=e.decorators;if(n)for(let e=0,t=n.length;e<t;++e)this.serializeDecorator(n[e]);this.serializeAccessModifiers(e),e.is(s.CommonFlags.GET)?this.sb.push("get "):e.is(s.CommonFlags.SET)&&this.sb.push("set "),this.visitFunctionCommon(e)}visitNamespaceDeclaration(e,n=!1){var t=e.decorators;if(t)for(let e=0,n=t.length;e<n;++e)this.serializeDecorator(t[e]);var r=this.sb;n?r.push("export default "):this.serializeExternalModifiers(e),r.push("namespace "),this.visitIdentifierExpression(e.name);var i=e.members;if(i.length){r.push(" {\n");let e=++this.indentLevel;for(let n=0,t=i.length;n<t;++n)a.indent(r,e),this.visitNodeAndTerminate(i[n]);a.indent(r,--this.indentLevel),r.push("}")}else r.push(" {}")}visitReturnStatement(e){var n=e.value;n?(this.sb.push("return "),this.visitNode(n)):this.sb.push("return")}visitSwitchCase(e){var n=this.sb,t=e.label;t?(n.push("case "),this.visitNode(t),n.push(":\n")):n.push("default:\n");var r=e.statements,i=r.length;if(i){let e=++this.indentLevel;a.indent(n,e),this.visitNodeAndTerminate(r[0]);for(let t=1;t<i;++t)a.indent(n,e),this.visitNodeAndTerminate(r[t]);--this.indentLevel}}visitSwitchStatement(e){var n=this.sb;n.push("switch ("),this.visitNode(e.condition),n.push(") {\n");var t=++this.indentLevel,r=e.cases;for(let e=0,i=r.length;e<i;++e)a.indent(n,t),this.visitSwitchCase(r[e]),n.push("\n");--this.indentLevel,n.push("}")}visitThrowStatement(e){this.sb.push("throw "),this.visitNode(e.value)}visitTryStatement(e){var n=this.sb;n.push("try {\n");var t=++this.indentLevel,r=e.statements;for(let e=0,i=r.length;e<i;++e)a.indent(n,t),this.visitNodeAndTerminate(r[e]);var i=e.catchVariable;if(i){a.indent(n,t-1),n.push("} catch ("),this.visitIdentifierExpression(i),n.push(") {\n");let r=e.catchStatements;if(r)for(let e=0,i=r.length;e<i;++e)a.indent(n,t),this.visitNodeAndTerminate(r[e])}var s=e.finallyStatements;if(s){a.indent(n,t-1),n.push("} finally {\n");for(let e=0,r=s.length;e<r;++e)a.indent(n,t),this.visitNodeAndTerminate(s[e])}a.indent(n,t-1),n.push("}")}visitTypeDeclaration(e){var n=e.decorators;if(n)for(let e=0,t=n.length;e<t;++e)this.serializeDecorator(n[e]);var t=this.sb;this.serializeExternalModifiers(e),t.push("type "),this.visitIdentifierExpression(e.name);var r=e.typeParameters;if(r){let e=r.length;if(e){t.push("<");for(let n=0;n<e;++n)this.visitTypeParameter(r[n]);t.push(">")}}t.push(" = "),this.visitTypeNode(e.type)}visitVariableDeclaration(e){this.visitIdentifierExpression(e.name);var n=e.type,t=this.sb;e.flags&s.CommonFlags.DEFINITELY_ASSIGNED&&t.push("!"),n&&(t.push(": "),this.visitTypeNode(n));var r=e.initializer;r&&(t.push(" = "),this.visitNode(r))}visitVariableStatement(e){var n=e.decorators;if(n)for(let e=0,t=n.length;e<t;++e)this.serializeDecorator(n[e]);var t=this.sb,r=e.declarations,i=assert(r.length),a=r[0];this.serializeExternalModifiers(a),t.push(a.is(s.CommonFlags.CONST)?"const ":a.is(s.CommonFlags.LET)?"let ":"var "),this.visitVariableDeclaration(e.declarations[0]);for(let n=1;n<i;++n)t.push(", "),this.visitVariableDeclaration(e.declarations[n])}visitWhileStatement(e){var n=this.sb;n.push("while ("),this.visitNode(e.condition),e.statement.kind==r.NodeKind.EMPTY?n.push(")"):(n.push(") "),this.visitNode(e.statement))}serializeDecorator(e){var n=this.sb;n.push("@"),this.visitNode(e.name);var t=e.args;if(t){n.push("(");let e=t.length;if(e){this.visitNode(t[0]);for(let r=1;r<e;++r)n.push(", "),this.visitNode(t[r])}n.push(")\n")}else n.push("\n");a.indent(n,this.indentLevel)}serializeParameter(e){var n=this.sb,t=e.parameterKind,i=e.implicitFieldDeclaration;i&&this.serializeAccessModifiers(i),t==r.ParameterKind.REST&&n.push("..."),this.visitIdentifierExpression(e.name);var a=e.type,s=e.initializer;a&&(t!=r.ParameterKind.OPTIONAL||s||n.push("?"),r.isTypeOmitted(a)||(n.push(": "),this.visitTypeNode(a))),s&&(n.push(" = "),this.visitNode(s))}serializeExternalModifiers(e){var n=this.sb;e.is(s.CommonFlags.EXPORT)?n.push("export "):e.is(s.CommonFlags.IMPORT)?n.push("import "):e.is(s.CommonFlags.DECLARE)&&n.push("declare ")}serializeAccessModifiers(e){var n=this.sb;e.is(s.CommonFlags.PUBLIC)?n.push("public "):e.is(s.CommonFlags.PRIVATE)?n.push("private "):e.is(s.CommonFlags.PROTECTED)&&n.push("protected "),e.is(s.CommonFlags.STATIC)?n.push("static "):e.is(s.CommonFlags.ABSTRACT)&&n.push("abstract "),e.is(s.CommonFlags.READONLY)&&n.push("readonly ")}finish(){var e=this.sb.join("");return this.sb=[],e}}n.ASTBuilder=o},154:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.findUsedLocals=n.Flow=n.ConditionKind=n.FieldFlags=n.LocalFlags=n.FlowFlags=void 0;const r=t(699),i=t(974),a=t(656),s=t(200),o=t(256),l=t(910);var u,c;!function(e){e[e.NONE=0]="NONE",e[e.RETURNS=1]="RETURNS",e[e.RETURNS_WRAPPED=2]="RETURNS_WRAPPED",e[e.RETURNS_NONNULL=4]="RETURNS_NONNULL",e[e.THROWS=8]="THROWS",e[e.BREAKS=16]="BREAKS",e[e.CONTINUES=32]="CONTINUES",e[e.ACCESSES_THIS=64]="ACCESSES_THIS",e[e.CALLS_SUPER=128]="CALLS_SUPER",e[e.TERMINATES=256]="TERMINATES",e[e.CONDITIONALLY_RETURNS=512]="CONDITIONALLY_RETURNS",e[e.CONDITIONALLY_THROWS=1024]="CONDITIONALLY_THROWS",e[e.CONDITIONALLY_BREAKS=2048]="CONDITIONALLY_BREAKS",e[e.CONDITIONALLY_CONTINUES=4096]="CONDITIONALLY_CONTINUES",e[e.CONDITIONALLY_ACCESSES_THIS=8192]="CONDITIONALLY_ACCESSES_THIS",e[e.MAY_RETURN_NONTHIS=16384]="MAY_RETURN_NONTHIS",e[e.UNCHECKED_CONTEXT=32768]="UNCHECKED_CONTEXT",e[e.ANY_CATEGORICAL=511]="ANY_CATEGORICAL",e[e.ANY_CONDITIONAL=15872]="ANY_CONDITIONAL"}(n.FlowFlags||(n.FlowFlags={})),function(e){e[e.NONE=0]="NONE",e[e.CONSTANT=1]="CONSTANT",e[e.WRAPPED=2]="WRAPPED",e[e.NONNULL=4]="NONNULL",e[e.INITIALIZED=8]="INITIALIZED"}(u=n.LocalFlags||(n.LocalFlags={})),function(e){e[e.NONE=0]="NONE",e[e.INITIALIZED=1]="INITIALIZED"}(c=n.FieldFlags||(n.FieldFlags={})),function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.TRUE=1]="TRUE",e[e.FALSE=2]="FALSE"}(n.ConditionKind||(n.ConditionKind={}));class p{constructor(e){this.parentFunction=e,this.parent=null,this.outer=null,this.flags=0,this.continueLabel=null,this.breakLabel=null,this.scopedLocals=null,this.localFlags=[],this.thisFieldFlags=null,this.inlineFunction=null,this.inlineReturnLabel=null}static createParent(e){var n=new p(e);return e.is(s.CommonFlags.CONSTRUCTOR)&&n.initThisFieldFlags(),n}static createInline(e,n){var t=new p(e);return t.inlineFunction=n,t.inlineReturnLabel=n.internalName+"|inlined."+(n.nextInlineId++).toString(),n.is(s.CommonFlags.CONSTRUCTOR)&&t.initThisFieldFlags(),t}get isInline(){return null!==this.inlineFunction}get actualFunction(){var e=this.inlineFunction;return e||this.parentFunction}get returnType(){return this.actualFunction.signature.returnType}get contextualTypeArguments(){return this.actualFunction.contextualTypeArguments}is(e){return(this.flags&e)==e}isAny(e){return 0!=(this.flags&e)}set(e){this.flags|=e}unset(e){this.flags&=~e}fork(e=!1){var n=new p(this.parentFunction);if(n.parent=this,n.outer=this.outer,e?n.flags=-6193&this.flags:(n.flags=this.flags,n.continueLabel=this.continueLabel,n.breakLabel=this.breakLabel),n.localFlags=this.localFlags.slice(),this.actualFunction.is(s.CommonFlags.CONSTRUCTOR)){let e=assert(this.thisFieldFlags);n.thisFieldFlags=l.uniqueMap(e)}else assert(!this.thisFieldFlags);return n.inlineFunction=this.inlineFunction,n.inlineReturnLabel=this.inlineReturnLabel,n}getTempLocal(e,n=null){var t,r,i=this.parentFunction;switch(e.toNativeType()){case a.NativeType.I32:t=i.tempI32s;break;case a.NativeType.I64:t=i.tempI64s;break;case a.NativeType.F32:t=i.tempF32s;break;case a.NativeType.F64:t=i.tempF64s;break;case a.NativeType.V128:t=i.tempV128s;break;case a.NativeType.Funcref:t=i.tempFuncrefs;break;case a.NativeType.Externref:t=i.tempExternrefs;break;case a.NativeType.Exnref:t=i.tempExnrefs;break;case a.NativeType.Anyref:t=i.tempAnyrefs;break;default:throw new Error("concrete type expected")}if(n){if(null!==t&&t.length>0)for(let i=0,a=t.length;i<a;++i)if(!n.has(t[i].index)){r=t[i];let n=t.length-1;for(;i<n;)unchecked(t[i]=t[1+i++]);return t.length=n,r.type=e,r.flags=s.CommonFlags.NONE,this.unsetLocalFlag(r.index,-1),r}r=i.addLocal(e)}else null!==t&&t.length>0?((r=assert(t.pop())).type=e,r.flags=s.CommonFlags.NONE):r=i.addLocal(e);return this.unsetLocalFlag(r.index,-1),r}freeTempLocal(e){if(!e.is(s.CommonFlags.INLINED)){assert(e.index>=0);var n,t=this.parentFunction;switch(assert(null!=e.type),e.resetTemporaryName(),e.type.toNativeType()){case a.NativeType.I32:{let e=t.tempI32s;e?n=e:t.tempI32s=n=[];break}case a.NativeType.I64:{let e=t.tempI64s;e?n=e:t.tempI64s=n=[];break}case a.NativeType.F32:{let e=t.tempF32s;e?n=e:t.tempF32s=n=[];break}case a.NativeType.F64:{let e=t.tempF64s;e?n=e:t.tempF64s=n=[];break}case a.NativeType.V128:{let e=t.tempV128s;e?n=e:t.tempV128s=n=[];break}case a.NativeType.Funcref:{let e=t.tempFuncrefs;e?n=e:t.tempFuncrefs=n=[];break}case a.NativeType.Externref:{let e=t.tempExternrefs;e?n=e:t.tempExternrefs=n=[];break}case a.NativeType.Exnref:{let e=t.tempExnrefs;e?n=e:t.tempExnrefs=n=[];break}case a.NativeType.Anyref:{let e=t.tempAnyrefs;e?n=e:t.tempAnyrefs=n=[];break}default:throw new Error("concrete type expected")}assert(e.index>=0),n.push(e)}}getScopedLocal(e){var n=this.scopedLocals;return null!==n&&n.has(e)?assert(n.get(e)):null}addScopedLocal(e,n,t=null){var r=this.getTempLocal(n,t);r.setTemporaryName(e);var i=this.scopedLocals;return i?assert(!i.has(e)):this.scopedLocals=i=new Map,r.set(s.CommonFlags.SCOPED),i.set(e,r),r}addScopedDummyLocal(e,n){var t=new i.Local(e,-1,n,this.parentFunction),r=this.scopedLocals;return r?assert(!r.has(e)):this.scopedLocals=r=new Map,t.set(s.CommonFlags.SCOPED),r.set(e,t),t}addScopedAlias(e,n,t,r=null){var a=this.scopedLocals;if(a){if(a.has(e)){let n=assert(a.get(e));return r&&(n.declaration.range.source.isNative?this.parentFunction.program.error(o.DiagnosticCode.Duplicate_identifier_0,r.range,e):this.parentFunction.program.errorRelated(o.DiagnosticCode.Duplicate_identifier_0,r.range,n.declaration.name.range,e)),n}}else this.scopedLocals=a=new Map;assert(t<this.parentFunction.localsByIndex.length);var s=new i.Local(e,t,n,this.parentFunction);return a.set(e,s),s}get hasScopedLocals(){var e=this.scopedLocals;if(e)for(let n=Map_values(e),t=0,r=n.length;t<r;++t)if(unchecked(n[t]).is(s.CommonFlags.SCOPED))return!0;return!1}freeScopedDummyLocal(e){var n=assert(this.scopedLocals);assert(n.has(e));let t=assert(n.get(e));assert(-1==t.index),n.delete(e)}freeScopedLocals(){var e=this.scopedLocals;if(e){for(let n=Map_values(e),t=0,r=n.length;t<r;++t){let e=unchecked(n[t]);e.is(s.CommonFlags.SCOPED)&&this.freeTempLocal(e)}this.scopedLocals=null}}lookupLocal(e){var n=this;do{let t=n.scopedLocals;if(null!==t&&t.has(e))return assert(t.get(e));n=n.parent}while(n);var t=this.parentFunction.localsByName;return t.has(e)?assert(t.get(e)):null}lookup(e){var n=this.lookupLocal(e);return n||this.actualFunction.lookup(e)}isLocalFlag(e,n,t=!0){if(e<0)return t;var r=this.localFlags;return e<r.length&&(unchecked(r[e])&n)==n}isAnyLocalFlag(e,n,t=!0){if(e<0)return t;var r=this.localFlags;return e<r.length&&0!=(unchecked(r[e])&n)}setLocalFlag(e,n){if(!(e<0)){var t=this.localFlags,r=e<t.length?unchecked(t[e]):0;t[e]=r|n}}unsetLocalFlag(e,n){if(!(e<0)){var t=this.localFlags,r=e<t.length?unchecked(t[e]):0;t[e]=r&~n}}initThisFieldFlags(){var e=this.actualFunction;assert(e.is(s.CommonFlags.CONSTRUCTOR));var n=e.parent;assert(n.kind==i.ElementKind.CLASS);var t=n;this.thisFieldFlags=new Map;var r=t.members;if(r)for(let e=Map_values(r),n=0,a=e.length;n<a;++n){let r=e[n];if(r.kind==i.ElementKind.FIELD){let e=r;(e.parent!=t||null!==e.initializerNode||-1!=e.prototype.parameterIndex||e.type.isAny(640))&&this.setThisFieldFlag(e,c.INITIALIZED)}}}isThisFieldFlag(e,n){var t=this.thisFieldFlags;return!(null==t||!t.has(e))&&(changetype(t.get(e))&n)==n}setThisFieldFlag(e,n){var t=this.thisFieldFlags;if(t)if(assert(this.actualFunction.is(s.CommonFlags.CONSTRUCTOR)),t.has(e)){let r=changetype(t.get(e));t.set(e,r|n)}else t.set(e,n);else assert(!this.actualFunction.is(s.CommonFlags.CONSTRUCTOR))}pushBreakLabel(){var e=this.parentFunction,n=e.nextBreakId++,t=e.breakStack;t?t.push(n):e.breakStack=[n];var r=n.toString();return e.breakLabel=r,r}popBreakLabel(){var e=this.parentFunction,n=assert(e.breakStack),t=assert(n.length);n.pop(),t>1?e.breakLabel=n[t-2].toString():(e.breakLabel=null,e.breakStack=null)}inherit(e){assert(e.parentFunction==this.parentFunction),assert(e.parent==this);var n=e.flags;this.breakLabel!=e.breakLabel&&(2064&n&&(n&=-257),n&=-2065),this.continueLabel!=e.continueLabel&&(n&=-4129),this.flags=this.flags|n,this.localFlags=e.localFlags,this.thisFieldFlags=e.thisFieldFlags}inheritBranch(e,n=0){switch(assert(e.parentFunction==this.parentFunction),n){case 1:this.inherit(e);case 2:return}var t=this.flags,r=e.flags,i=0;i|=1&t?1:1&r?512:512&(t|r),i|=t&r&2,i|=t&r&4,i|=8&t?8:8&r?1024:1024&(t|r),16&t?i|=16:e.breakLabel==this.breakLabel?i|=16&r?2048:2048&(t|r):i|=2048&t,32&t?i|=32:e.continueLabel===this.continueLabel?i|=32&r?4096:4096&(t|r):i|=4096&t,64&t?i|=64&r?64:8192:64&r&&(i|=8192),i|=16384&(t|r),i|=t&r&128,256&t&&(i|=256),this.flags=i|32768&t;var a=this.localFlags,s=a.length,o=e.localFlags,l=o.length,c=max(s,l);for(let e=0;e<c;++e){let n=e<s?a[e]:0,t=e<l?o[e]:0;a[e]=n&t&(u.CONSTANT|u.WRAPPED|u.NONNULL|u.INITIALIZED)}}inheritMutual(e,n){assert(e.parentFunction==n.parentFunction),assert(e.parentFunction==this.parentFunction);var t=e.flags,r=n.flags,i=0;i|=1&t?1&r?1:512:1&r?512:512&(t|r),2&t&&2&r&&(i|=2),4&t&&4&r&&(i|=4),i|=8&t?8&r?8:1024:8&r?1024:1024&(t|r),i|=16&t?16&r?16:2048:16&r?2048:2048&(t|r),i|=32&t?32&r?32:4096:32&r?4096:4096&(t|r),i|=64&t?64&r?64:8192:64&r?8192:8192&(t|r),i|=16384&(t|r),128&t&&128&r&&(i|=128),256&t&&256&r&&(i|=256),this.flags=i|32768&this.flags;var a=this.localFlags;if(256&t){if(!(256&r)){let e=n.localFlags;for(let n=0,t=e.length;n<t;++n)a[n]=e[n]}}else if(256&r){let n=e.localFlags;for(let e=0,t=n.length;e<t;++e)a[e]=n[e]}else{let t=e.localFlags,r=t.length,i=n.localFlags,s=i.length,o=max(r,s);for(let e=0;e<o;++e){let n=e<r?t[e]:0,o=e<s?i[e]:0;a[e]=n&o&(u.CONSTANT|u.WRAPPED|u.NONNULL|u.INITIALIZED)}}var s=e.thisFieldFlags;if(s){let e=new Map,t=assert(n.thisFieldFlags);for(let n=Map_keys(s),r=0,i=n.length;r<i;++r){let i=n[r];0!=(changetype(s.get(i))&c.INITIALIZED)&&t.has(i)&&changetype(t.get(i))&c.INITIALIZED&&e.set(i,c.INITIALIZED)}this.thisFieldFlags=e}else assert(!n.thisFieldFlags)}static hasIncompatibleLocalStates(e,n){var t=e.localFlags.length,r=n.localFlags.length,i=e.parentFunction;assert(i===n.parentFunction);var a=i.localsByIndex;assert(a===n.parentFunction.localsByIndex);for(let i=0,s=min(t,r);i<s;++i){let t=a[i].type;if(t.isShortIntegerValue&&e.isLocalFlag(i,u.WRAPPED)&&!n.isLocalFlag(i,u.WRAPPED))return!0;if(t.isNullableReference&&e.isLocalFlag(i,u.NONNULL)&&!n.isLocalFlag(i,u.NONNULL))return!0}return!1}unifyLocalFlags(e){var n=this.localFlags.length,t=e.localFlags.length;for(let r=0,i=min(n,t);r<i;++r)this.isLocalFlag(r,u.WRAPPED)!=e.isLocalFlag(r,u.WRAPPED)&&this.unsetLocalFlag(r,u.WRAPPED),this.isLocalFlag(r,u.NONNULL)!=e.isLocalFlag(r,u.NONNULL)&&this.unsetLocalFlag(r,u.NONNULL)}isNonnull(e,n){if(!n.isNullableReference)return!0;switch(a.getExpressionId(e)){case a.ExpressionId.LocalSet:{if(!a.isLocalTee(e))break;let n=this.parentFunction.localsByIndex[a.getLocalSetIndex(e)];return!n.type.isNullableReference||this.isLocalFlag(n.index,u.NONNULL,!1)}case a.ExpressionId.LocalGet:{let n=this.parentFunction.localsByIndex[a.getLocalGetIndex(e)];return!n.type.isNullableReference||this.isLocalFlag(n.index,u.NONNULL,!1)}}return!1}inheritNonnullIfTrue(e,n=null){switch(a.getExpressionId(e)){case a.ExpressionId.LocalSet:{if(!a.isLocalTee(e))break;let t=this.parentFunction.localsByIndex[a.getLocalSetIndex(e)];n&&!n.isLocalFlag(t.index,u.NONNULL)||this.setLocalFlag(t.index,u.NONNULL),this.inheritNonnullIfTrue(a.getLocalSetValue(e),n);break}case a.ExpressionId.LocalGet:{let t=this.parentFunction.localsByIndex[a.getLocalGetIndex(e)];n&&!n.isLocalFlag(t.index,u.NONNULL)||this.setLocalFlag(t.index,u.NONNULL);break}case a.ExpressionId.If:{let t=a.getIfFalse(e);if(!t)break;a.getExpressionId(t)==a.ExpressionId.Const&&(a.getExpressionType(t)==a.NativeType.I32&&0==a.getConstValueI32(t)||a.getExpressionType(t)==a.NativeType.I64&&0==a.getConstValueI64Low(t)&&0==a.getConstValueI64High(t))&&(this.inheritNonnullIfTrue(a.getIfCondition(e),n),this.inheritNonnullIfTrue(a.getIfTrue(e),n));break}case a.ExpressionId.Unary:switch(a.getUnaryOp(e)){case a.UnaryOp.EqzI32:case a.UnaryOp.EqzI64:this.inheritNonnullIfFalse(a.getUnaryValue(e),n)}break;case a.ExpressionId.Binary:switch(a.getBinaryOp(e)){case a.BinaryOp.EqI32:{let t=a.getBinaryLeft(e),r=a.getBinaryRight(e);a.getExpressionId(t)==a.ExpressionId.Const&&0!=a.getConstValueI32(t)?this.inheritNonnullIfTrue(r,n):a.getExpressionId(r)==a.ExpressionId.Const&&0!=a.getConstValueI32(r)&&this.inheritNonnullIfTrue(t,n);break}case a.BinaryOp.EqI64:{let t=a.getBinaryLeft(e),r=a.getBinaryRight(e);a.getExpressionId(t)!=a.ExpressionId.Const||0==a.getConstValueI64Low(t)&&0==a.getConstValueI64High(t)?a.getExpressionId(r)==a.ExpressionId.Const&&0!=a.getConstValueI64Low(r)&&0!=a.getConstValueI64High(r)&&this.inheritNonnullIfTrue(t,n):this.inheritNonnullIfTrue(r,n);break}case a.BinaryOp.NeI32:{let t=a.getBinaryLeft(e),r=a.getBinaryRight(e);a.getExpressionId(t)==a.ExpressionId.Const&&0==a.getConstValueI32(t)?this.inheritNonnullIfTrue(r,n):a.getExpressionId(r)==a.ExpressionId.Const&&0==a.getConstValueI32(r)&&this.inheritNonnullIfTrue(t,n);break}case a.BinaryOp.NeI64:{let t=a.getBinaryLeft(e),r=a.getBinaryRight(e);a.getExpressionId(t)==a.ExpressionId.Const&&0==a.getConstValueI64Low(t)&&0==a.getConstValueI64High(t)?this.inheritNonnullIfTrue(r,n):a.getExpressionId(r)==a.ExpressionId.Const&&0==a.getConstValueI64Low(r)&&0==a.getConstValueI64High(r)&&this.inheritNonnullIfTrue(t,n);break}}}}inheritNonnullIfFalse(e,n=null){switch(a.getExpressionId(e)){case a.ExpressionId.Unary:switch(a.getUnaryOp(e)){case a.UnaryOp.EqzI32:case a.UnaryOp.EqzI64:this.inheritNonnullIfTrue(a.getUnaryValue(e),n)}break;case a.ExpressionId.If:{let t=a.getIfTrue(e);if(a.getExpressionId(t)==a.ExpressionId.Const){if(!a.getIfFalse(e))break;let r=a.getExpressionType(t);(r==a.NativeType.I32&&0!=a.getConstValueI32(t)||r==a.NativeType.I64&&(0!=a.getConstValueI64Low(t)||0!=a.getConstValueI64High(t)))&&(this.inheritNonnullIfFalse(a.getIfCondition(e),n),this.inheritNonnullIfFalse(a.getIfFalse(e),n))}break}case a.ExpressionId.Binary:switch(a.getBinaryOp(e)){case a.BinaryOp.EqI32:{let t=a.getBinaryLeft(e),r=a.getBinaryRight(e);a.getExpressionId(t)==a.ExpressionId.Const&&0==a.getConstValueI32(t)?this.inheritNonnullIfTrue(r,n):a.getExpressionId(r)==a.ExpressionId.Const&&0==a.getConstValueI32(r)&&this.inheritNonnullIfTrue(t,n);break}case a.BinaryOp.EqI64:{let t=a.getBinaryLeft(e),r=a.getBinaryRight(e);a.getExpressionId(t)==a.ExpressionId.Const&&0==a.getConstValueI64Low(t)&&0==a.getConstValueI64High(t)?this.inheritNonnullIfTrue(r,n):a.getExpressionId(r)==a.ExpressionId.Const&&0==a.getConstValueI64Low(r)&&0==a.getConstValueI64High(r)&&this.inheritNonnullIfTrue(t,n);break}case a.BinaryOp.NeI32:{let t=a.getBinaryLeft(e),r=a.getBinaryRight(e);a.getExpressionId(t)==a.ExpressionId.Const&&0!=a.getConstValueI32(t)?this.inheritNonnullIfTrue(r,n):a.getExpressionId(r)==a.ExpressionId.Const&&0!=a.getConstValueI32(r)&&this.inheritNonnullIfTrue(t,n);break}case a.BinaryOp.NeI64:{let t=a.getBinaryLeft(e),r=a.getBinaryRight(e);a.getExpressionId(t)!=a.ExpressionId.Const||0==a.getConstValueI64Low(t)&&0==a.getConstValueI64High(t)?a.getExpressionId(r)!=a.ExpressionId.Const||0==a.getConstValueI64Low(r)&&0==a.getConstValueI64High(r)||this.inheritNonnullIfTrue(t,n):this.inheritNonnullIfTrue(r,n);break}}}}canOverflow(e,n){if(assert(n!=r.Type.void),!n.isShortIntegerValue)return!1;var t;switch(a.getExpressionId(e)){case a.ExpressionId.LocalGet:{let t=this.parentFunction.localsByIndex[a.getLocalGetIndex(e)];return!this.isLocalFlag(t.index,u.WRAPPED,!0)||f(t.type,n)}case a.ExpressionId.LocalSet:return assert(a.isLocalTee(e)),this.canOverflow(a.getLocalSetValue(e),n);case a.ExpressionId.GlobalGet:{let t=assert(this.parentFunction.program.elementsByName.get(assert(a.getGlobalGetName(e))));return assert(t.kind==i.ElementKind.GLOBAL),f(t.type,n)}case a.ExpressionId.Binary:switch(a.getBinaryOp(e)){case a.BinaryOp.EqI32:case a.BinaryOp.EqI64:case a.BinaryOp.EqF32:case a.BinaryOp.EqF64:case a.BinaryOp.NeI32:case a.BinaryOp.NeI64:case a.BinaryOp.NeF32:case a.BinaryOp.NeF64:case a.BinaryOp.LtI32:case a.BinaryOp.LtU32:case a.BinaryOp.LtI64:case a.BinaryOp.LtU64:case a.BinaryOp.LtF32:case a.BinaryOp.LtF64:case a.BinaryOp.LeI32:case a.BinaryOp.LeU32:case a.BinaryOp.LeI64:case a.BinaryOp.LeU64:case a.BinaryOp.LeF32:case a.BinaryOp.LeF64:case a.BinaryOp.GtI32:case a.BinaryOp.GtU32:case a.BinaryOp.GtI64:case a.BinaryOp.GtU64:case a.BinaryOp.GtF32:case a.BinaryOp.GtF64:case a.BinaryOp.GeI32:case a.BinaryOp.GeU32:case a.BinaryOp.GeI64:case a.BinaryOp.GeU64:case a.BinaryOp.GeF32:case a.BinaryOp.GeF64:return!1;case a.BinaryOp.MulI32:return!(a.getExpressionId(t=a.getBinaryLeft(e))==a.ExpressionId.Const&&(0==a.getConstValueI32(t)||1==a.getConstValueI32(t)&&!this.canOverflow(a.getBinaryRight(e),n))||a.getExpressionId(t=a.getBinaryRight(e))==a.ExpressionId.Const&&(0==a.getConstValueI32(t)||1==a.getConstValueI32(t)&&!this.canOverflow(a.getBinaryLeft(e),n)));case a.BinaryOp.AndI32:return!(a.getExpressionId(t=a.getBinaryLeft(e))==a.ExpressionId.Const&&a.getConstValueI32(t)<=n.computeSmallIntegerMask(r.Type.i32)||!this.canOverflow(t,n)||a.getExpressionId(t=a.getBinaryRight(e))==a.ExpressionId.Const&&a.getConstValueI32(t)<=n.computeSmallIntegerMask(r.Type.i32)||!this.canOverflow(t,n));case a.BinaryOp.ShlI32:{let r=32-n.size;return a.getExpressionId(t=a.getBinaryRight(e))!=a.ExpressionId.Const||a.getConstValueI32(t)<r}case a.BinaryOp.ShrI32:{let r=32-n.size;return this.canOverflow(a.getBinaryLeft(e),n)&&(a.getExpressionId(t=a.getBinaryRight(e))!=a.ExpressionId.Const||a.getConstValueI32(t)<r)}case a.BinaryOp.ShrU32:{let r=32-n.size;return n.isSignedIntegerValue?!(a.getExpressionId(t=a.getBinaryRight(e))==a.ExpressionId.Const&&a.getConstValueI32(t)>r):this.canOverflow(a.getBinaryLeft(e),n)&&!(a.getExpressionId(t=a.getBinaryRight(e))==a.ExpressionId.Const&&a.getConstValueI32(t)>=r)}case a.BinaryOp.DivU32:case a.BinaryOp.RemI32:case a.BinaryOp.RemU32:return this.canOverflow(a.getBinaryLeft(e),n)||this.canOverflow(a.getBinaryRight(e),n)}break;case a.ExpressionId.Unary:switch(a.getUnaryOp(e)){case a.UnaryOp.EqzI32:case a.UnaryOp.EqzI64:return!1;case a.UnaryOp.ClzI32:case a.UnaryOp.CtzI32:case a.UnaryOp.PopcntI32:return n.size<7}break;case a.ExpressionId.Const:{let t=0;switch(a.getExpressionType(e)){case a.NativeType.I32:t=a.getConstValueI32(e);break;case a.NativeType.I64:t=a.getConstValueI64Low(e);break;case a.NativeType.F32:t=i32(a.getConstValueF32(e));break;case a.NativeType.F64:t=i32(a.getConstValueF64(e));break;default:assert(!1)}switch(n.kind){case 0:return t<i8.MIN_VALUE||t>i8.MAX_VALUE;case 1:return t<i16.MIN_VALUE||t>i16.MAX_VALUE;case 5:return t<0||t>u8.MAX_VALUE;case 6:return t<0||t>u16.MAX_VALUE;case 10:return 0!=(-2&t)}break}case a.ExpressionId.Load:{let t,i=a.isLoadSigned(e);switch(a.getLoadBytes(e)){case 1:t=i?r.Type.i8:r.Type.u8;break;case 2:t=i?r.Type.i16:r.Type.u16;break;default:t=i?r.Type.i32:r.Type.u32}return f(t,n)}case a.ExpressionId.Block:if(!a.getBlockName(e)){let t=assert(a.getBlockChildCount(e)),r=a.getBlockChildAt(e,t-1);return this.canOverflow(r,n)}break;case a.ExpressionId.If:return this.canOverflow(a.getIfTrue(e),n)||this.canOverflow(assert(a.getIfFalse(e)),n);case a.ExpressionId.Select:return this.canOverflow(a.getSelectThen(e),n)||this.canOverflow(a.getSelectElse(e),n);case a.ExpressionId.Call:{let t=this.parentFunction.program.instancesByName,r=assert(a.getCallTarget(e));if(t.has(r)){let e=assert(t.get(r));assert(e.kind==i.ElementKind.FUNCTION);let a=e,s=a.signature.returnType;return!a.flow.is(2)||f(s,n)}return!1}case a.ExpressionId.Unreachable:return!1}return!0}toString(){for(var e=0,n=this.parent;n;)n=n.parent,++e;var t=new Array;return this.is(1)&&t.push("RETURNS"),this.is(2)&&t.push("RETURNS_WRAPPED"),this.is(4)&&t.push("RETURNS_NONNULL"),this.is(8)&&t.push("THROWS"),this.is(16)&&t.push("BREAKS"),this.is(32)&&t.push("CONTINUES"),this.is(64)&&t.push("ACCESSES_THIS"),this.is(128)&&t.push("CALLS_SUPER"),this.is(256)&&t.push("TERMINATES"),this.is(512)&&t.push("CONDITIONALLY_RETURNS"),this.is(1024)&&t.push("CONDITIONALLY_THROWS"),this.is(2048)&&t.push("CONDITIONALLY_BREAKS"),this.is(4096)&&t.push("CONDITIONALLY_CONTINUES"),this.is(8192)&&t.push("CONDITIONALLY_ACCESSES_THIS"),this.is(16384)&&t.push("MAY_RETURN_NONTHIS"),"Flow("+this.actualFunction.toString()+")["+e.toString()+"] "+t.join(" ")}}function f(e,n){return n.isShortIntegerValue&&(!e.isIntegerValue||e.size>n.size||e.isSignedIntegerValue!=n.isSignedIntegerValue)}n.Flow=p;var d=t(416);Object.defineProperty(n,"findUsedLocals",{enumerable:!0,get:function(){return d.findUsedLocals}})},308:(e,n,t)=>{"use strict";t(352),t(292),t(620),t(875),t(710)},780:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t),Object.defineProperty(e,r,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),i=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)};Object.defineProperty(n,"__esModule",{value:!0}),n.buildTSD=n.buildIDL=n.compile=n.initializeProgram=n.getDependee=n.nextFile=n.parse=n.isError=n.isWarning=n.isInfo=n.formatDiagnostic=n.getSource=n.nextDiagnostic=n.newProgram=n.setPedantic=n.setOptimizeLevelHints=n.disableFeature=n.enableFeature=n.FEATURE_MEMORY64=n.FEATURE_GC=n.FEATURE_MULTI_VALUE=n.FEATURE_REFERENCE_TYPES=n.FEATURE_TAIL_CALLS=n.FEATURE_EXCEPTION_HANDLING=n.FEATURE_THREADS=n.FEATURE_SIMD=n.FEATURE_BULK_MEMORY=n.FEATURE_NONTRAPPING_F2I=n.FEATURE_MUTABLE_GLOBALS=n.FEATURE_SIGN_EXTENSION=n.setStackSize=n.DEFAULT_STACK_SIZE=n.setExportRuntime=n.setLowMemoryLimit=n.setNoUnsafe=n.setExplicitStart=n.setGlobalAlias=n.setTableBase=n.setMemoryBase=n.setSourceMap=n.setExportTable=n.setImportTable=n.setSharedMemory=n.setMaximumMemory=n.setInitialMemory=n.setImportMemory=n.setExportMemory=n.setNoAssert=n.setTarget=n.newOptions=void 0,n.util=void 0;const a=t(220),s=t(317),o=t(256);Object.defineProperty(n,"formatDiagnostic",{enumerable:!0,get:function(){return o.formatDiagnosticMessage}});const l=t(974);n.newOptions=function(){return new a.Options},n.setTarget=function(e,n){e.target=n},n.setNoAssert=function(e,n){e.noAssert=n},n.setExportMemory=function(e,n){e.exportMemory=n},n.setImportMemory=function(e,n){e.importMemory=n},n.setInitialMemory=function(e,n){e.initialMemory=n},n.setMaximumMemory=function(e,n){e.maximumMemory=n},n.setSharedMemory=function(e,n){e.sharedMemory=n},n.setImportTable=function(e,n){e.importTable=n},n.setExportTable=function(e,n){e.exportTable=n},n.setSourceMap=function(e,n){e.sourceMap=n},n.setMemoryBase=function(e,n){e.memoryBase=n},n.setTableBase=function(e,n){e.tableBase=n},n.setGlobalAlias=function(e,n,t){var r=e.globalAliases;r||(e.globalAliases=r=new Map),r.set(n,t)},n.setExplicitStart=function(e,n){e.explicitStart=n},n.setNoUnsafe=function(e,n){e.noUnsafe=n},n.setLowMemoryLimit=function(e,n){e.lowMemoryLimit=n},n.setExportRuntime=function(e,n){e.exportRuntime=n},n.DEFAULT_STACK_SIZE=16384,n.setStackSize=function(e,n){e.stackSize=n},n.FEATURE_SIGN_EXTENSION=1,n.FEATURE_MUTABLE_GLOBALS=2,n.FEATURE_NONTRAPPING_F2I=4,n.FEATURE_BULK_MEMORY=8,n.FEATURE_SIMD=16,n.FEATURE_THREADS=32,n.FEATURE_EXCEPTION_HANDLING=64,n.FEATURE_TAIL_CALLS=128,n.FEATURE_REFERENCE_TYPES=256,n.FEATURE_MULTI_VALUE=512,n.FEATURE_GC=1024,n.FEATURE_MEMORY64=2048,n.enableFeature=function(e,n){e.features|=n},n.disableFeature=function(e,n){e.features&=~n},n.setOptimizeLevelHints=function(e,n,t){e.optimizeLevelHint=n,e.shrinkLevelHint=t},n.setPedantic=function(e,n){e.pedantic=n},n.newProgram=function(e){return new l.Program(e)},n.nextDiagnostic=function(e){return e.diagnosticsOffset<e.diagnostics.length?e.diagnostics[e.diagnosticsOffset++]:null},n.getSource=function(e,n){return e.getSource(n)},n.isInfo=function(e){return e.category==o.DiagnosticCategory.INFO},n.isWarning=function(e){return e.category==o.DiagnosticCategory.WARNING},n.isError=function(e){return e.category==o.DiagnosticCategory.ERROR},n.parse=function(e,n,t,r=!1){e.parser.parseFile(n,t,r)},n.nextFile=function(e){return e.parser.nextFile()},n.getDependee=function(e,n){return e.parser.getDependee(n)},n.initializeProgram=function(e){e.initialize()},n.compile=function(e){return e.parser.finish(),new a.Compiler(e).compile()},n.buildIDL=function(e){return s.IDLBuilder.build(e)},n.buildTSD=function(e){return s.TSDBuilder.build(e)},i(t(60),n),i(t(200),n),i(t(220),n),i(t(317),n),i(t(256),n),i(t(154),n),i(t(656),n),i(t(215),n),i(t(974),n),i(t(742),n),i(t(411),n),i(t(699),n),i(t(393),n);const u=t(910);n.util=u,i(t(910),n)},656:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getLoopName=n.getIfFalse=n.getIfTrue=n.getIfCondition=n.getBlockChildAt=n.getBlockChildCount=n.getBlockName=n.getStoreValue=n.getStorePtr=n.getStoreOffset=n.getStoreBytes=n.isLoadSigned=n.getLoadPtr=n.getLoadOffset=n.getLoadBytes=n.getUnaryValue=n.getUnaryOp=n.getBinaryRight=n.getBinaryLeft=n.getBinaryOp=n.getGlobalGetName=n.isLocalTee=n.getLocalSetValue=n.getLocalSetIndex=n.getLocalGetIndex=n.isConstZero=n.getConstValueF64=n.getConstValueF32=n.getConstValueI64High=n.getConstValueI64Low=n.getConstValueI32=n.getExpressionType=n.getExpressionId=n.expandType=n.createType=n.Module=n.MemorySegment=n.ExpressionRunnerFlags=n.SIMDLoadOp=n.SIMDTernaryOp=n.SIMDShiftOp=n.SIMDReplaceOp=n.SIMDExtractOp=n.AtomicRMWOp=n.BinaryOp=n.UnaryOp=n.ExternalKind=n.ExpressionId=n.FeatureFlags=n.NativeType=void 0,n.needsExplicitUnreachable=n.BinaryModule=n.readString=n.allocPtrArray=n.hasSideEffects=n.getSideEffects=n.SideEffects=n.SwitchBuilder=n.Relooper=n.getEventResults=n.getEventParams=n.getEventAttribute=n.getEventName=n.getGlobalInit=n.isGlobalMutable=n.getGlobalType=n.getGlobalName=n.getFunctionVars=n.getFunctionResults=n.getFunctionParams=n.getFunctionName=n.getFunctionBody=n.getMemoryGrowDelta=n.getCallOperandAt=n.getCallOperandCount=n.getCallTarget=n.getReturnValue=n.getDropValue=n.getSelectCondition=n.getSelectElse=n.getSelectThen=n.getBreakCondition=n.getBreakName=n.getLoopBody=void 0;const r=t(346),i=t(200),a=t(292);var s,o,l,u,c;!function(e){e.None=0,e.Unreachable=1,e.I32=2,e.I64=3,e.F32=4,e.F64=5,e.V128=6,e.Funcref=7,e.Externref=8,e.Exnref=9,e.Anyref=10,e.Auto=-1}(s=n.NativeType||(n.NativeType={})),function(e){e[e.MVP=0]="MVP",e[e.Atomics=1]="Atomics",e[e.MutableGloabls=2]="MutableGloabls",e[e.NontrappingFPToInt=4]="NontrappingFPToInt",e[e.SIMD128=8]="SIMD128",e[e.BulkMemory=16]="BulkMemory",e[e.SignExt=32]="SignExt",e[e.ExceptionHandling=64]="ExceptionHandling",e[e.TailCall=128]="TailCall",e[e.ReferenceTypes=256]="ReferenceTypes",e[e.MultiValue=512]="MultiValue",e[e.GC=1024]="GC",e[e.Memory64=2048]="Memory64",e[e.All=4095]="All"}(o=n.FeatureFlags||(n.FeatureFlags={})),function(e){e[e.Invalid=0]="Invalid",e[e.Block=1]="Block",e[e.If=2]="If",e[e.Loop=3]="Loop",e[e.Break=4]="Break",e[e.Switch=5]="Switch",e[e.Call=6]="Call",e[e.CallIndirect=7]="CallIndirect",e[e.LocalGet=8]="LocalGet",e[e.LocalSet=9]="LocalSet",e[e.GlobalGet=10]="GlobalGet",e[e.GlobalSet=11]="GlobalSet",e[e.Load=12]="Load",e[e.Store=13]="Store",e[e.Const=14]="Const",e[e.Unary=15]="Unary",e[e.Binary=16]="Binary",e[e.Select=17]="Select",e[e.Drop=18]="Drop",e[e.Return=19]="Return",e[e.MemorySize=20]="MemorySize",e[e.MemoryGrow=21]="MemoryGrow",e[e.Nop=22]="Nop",e[e.Unreachable=23]="Unreachable",e[e.AtomicRMW=24]="AtomicRMW",e[e.AtomicCmpxchg=25]="AtomicCmpxchg",e[e.AtomicWait=26]="AtomicWait",e[e.AtomicNotify=27]="AtomicNotify",e[e.AtomicFence=28]="AtomicFence",e[e.SIMDExtract=29]="SIMDExtract",e[e.SIMDReplace=30]="SIMDReplace",e[e.SIMDShuffle=31]="SIMDShuffle",e[e.SIMDTernary=32]="SIMDTernary",e[e.SIMDShift=33]="SIMDShift",e[e.SIMDLoad=34]="SIMDLoad",e[e.MemoryInit=36]="MemoryInit",e[e.DataDrop=37]="DataDrop",e[e.MemoryCopy=38]="MemoryCopy",e[e.MemoryFill=39]="MemoryFill",e[e.Pop=40]="Pop",e[e.RefNull=41]="RefNull",e[e.RefIsNull=42]="RefIsNull",e[e.RefFunc=43]="RefFunc",e[e.RefEq=44]="RefEq",e[e.Try=45]="Try",e[e.Throw=46]="Throw",e[e.Rethrow=47]="Rethrow",e[e.BrOnExn=48]="BrOnExn",e[e.TupleMake=49]="TupleMake",e[e.TupleExtract=50]="TupleExtract",e[e.I31New=51]="I31New",e[e.I31Get=52]="I31Get",e[e.CallRef=53]="CallRef",e[e.RefTest=54]="RefTest",e[e.RefCast=55]="RefCast",e[e.BrOnCast=56]="BrOnCast",e[e.RttCanon=57]="RttCanon",e[e.RttSub=58]="RttSub",e[e.StructNew=59]="StructNew",e[e.StructGet=60]="StructGet",e[e.StructSet=61]="StructSet",e[e.ArrayNew=62]="ArrayNew",e[e.ArrayGet=63]="ArrayGet",e[e.ArraySet=64]="ArraySet",e[e.ArrayLen=64]="ArrayLen"}(l=n.ExpressionId||(n.ExpressionId={})),function(e){e[e.Function=0]="Function",e[e.Table=1]="Table",e[e.Memory=2]="Memory",e[e.Global=3]="Global",e[e.Event=4]="Event"}(n.ExternalKind||(n.ExternalKind={})),function(e){e[e.ClzI32=0]="ClzI32",e[e.ClzI64=1]="ClzI64",e[e.CtzI32=2]="CtzI32",e[e.CtzI64=3]="CtzI64",e[e.PopcntI32=4]="PopcntI32",e[e.PopcntI64=5]="PopcntI64",e[e.NegF32=6]="NegF32",e[e.NegF64=7]="NegF64",e[e.AbsF32=8]="AbsF32",e[e.AbsF64=9]="AbsF64",e[e.CeilF32=10]="CeilF32",e[e.CeilF64=11]="CeilF64",e[e.FloorF32=12]="FloorF32",e[e.FloorF64=13]="FloorF64",e[e.TruncF32=14]="TruncF32",e[e.TruncF64=15]="TruncF64",e[e.NearestF32=16]="NearestF32",e[e.NearestF64=17]="NearestF64",e[e.SqrtF32=18]="SqrtF32",e[e.SqrtF64=19]="SqrtF64",e[e.EqzI32=20]="EqzI32",e[e.EqzI64=21]="EqzI64",e[e.ExtendI32=22]="ExtendI32",e[e.ExtendU32=23]="ExtendU32",e[e.WrapI64=24]="WrapI64",e[e.TruncF32ToI32=25]="TruncF32ToI32",e[e.TruncF32ToI64=26]="TruncF32ToI64",e[e.TruncF32ToU32=27]="TruncF32ToU32",e[e.TruncF32ToU64=28]="TruncF32ToU64",e[e.TruncF64ToI32=29]="TruncF64ToI32",e[e.TruncF64ToI64=30]="TruncF64ToI64",e[e.TruncF64ToU32=31]="TruncF64ToU32",e[e.TruncF64ToU64=32]="TruncF64ToU64",e[e.ReinterpretF32=33]="ReinterpretF32",e[e.ReinterpretF64=34]="ReinterpretF64",e[e.ConvertI32ToF32=35]="ConvertI32ToF32",e[e.ConvertI32ToF64=36]="ConvertI32ToF64",e[e.ConvertU32ToF32=37]="ConvertU32ToF32",e[e.ConvertU32ToF64=38]="ConvertU32ToF64",e[e.ConvertI64ToF32=39]="ConvertI64ToF32",e[e.ConvertI64ToF64=40]="ConvertI64ToF64",e[e.ConvertU64ToF32=41]="ConvertU64ToF32",e[e.ConvertU64ToF64=42]="ConvertU64ToF64",e[e.PromoteF32=43]="PromoteF32",e[e.DemoteF64=44]="DemoteF64",e[e.ReinterpretI32=45]="ReinterpretI32",e[e.ReinterpretI64=46]="ReinterpretI64",e[e.ExtendI8ToI32=47]="ExtendI8ToI32",e[e.ExtendI16ToI32=48]="ExtendI16ToI32",e[e.ExtendI8ToI64=49]="ExtendI8ToI64",e[e.ExtendI16ToI64=50]="ExtendI16ToI64",e[e.ExtendI32ToI64=51]="ExtendI32ToI64",e[e.TruncF32ToI32Sat=52]="TruncF32ToI32Sat",e[e.TruncF32ToU32Sat=53]="TruncF32ToU32Sat",e[e.TruncF64ToI32Sat=54]="TruncF64ToI32Sat",e[e.TruncF64ToU32Sat=55]="TruncF64ToU32Sat",e[e.TruncF32ToI64Sat=56]="TruncF32ToI64Sat",e[e.TruncF32ToU64Sat=57]="TruncF32ToU64Sat",e[e.TruncF64ToI64Sat=58]="TruncF64ToI64Sat",e[e.TruncF64ToU64Sat=59]="TruncF64ToU64Sat",e[e.SplatI8x16=60]="SplatI8x16",e[e.SplatI16x8=61]="SplatI16x8",e[e.SplatI32x4=62]="SplatI32x4",e[e.SplatI64x2=63]="SplatI64x2",e[e.SplatF32x4=64]="SplatF32x4",e[e.SplatF64x2=65]="SplatF64x2",e[e.NotV128=66]="NotV128",e[e.AbsI8x16=67]="AbsI8x16",e[e.NegI8x16=68]="NegI8x16",e[e.AnyTrueI8x16=69]="AnyTrueI8x16",e[e.AllTrueI8x16=70]="AllTrueI8x16",e[e.BitmaskI8x16=71]="BitmaskI8x16",e[e.AbsI16x8=72]="AbsI16x8",e[e.NegI16x8=74]="NegI16x8",e[e.AnyTrueI16x8=75]="AnyTrueI16x8",e[e.AllTrueI16x8=76]="AllTrueI16x8",e[e.BitmaskI16x8=77]="BitmaskI16x8",e[e.AbsI32x4=78]="AbsI32x4",e[e.NegI32x4=79]="NegI32x4",e[e.AnyTrueI32x4=80]="AnyTrueI32x4",e[e.AllTrueI32x4=81]="AllTrueI32x4",e[e.BitmaskI32x4=82]="BitmaskI32x4",e[e.NegI64x2=83]="NegI64x2",e[e.AnyTrueI64x2=84]="AnyTrueI64x2",e[e.AllTrueI64x2=85]="AllTrueI64x2",e[e.AbsF32x4=86]="AbsF32x4",e[e.NegF32x4=87]="NegF32x4",e[e.SqrtF32x4=88]="SqrtF32x4",e[e.CeilF32x4=89]="CeilF32x4",e[e.FloorF32x4=90]="FloorF32x4",e[e.TruncF32x4=90]="TruncF32x4",e[e.NearestF32x4=91]="NearestF32x4",e[e.AbsF64x2=93]="AbsF64x2",e[e.NegF64x2=94]="NegF64x2",e[e.SqrtF64x2=95]="SqrtF64x2",e[e.CeilF64x2=96]="CeilF64x2",e[e.FloorF64x2=97]="FloorF64x2",e[e.TruncF64x2=97]="TruncF64x2",e[e.NearestF64x2=98]="NearestF64x2",e[e.TruncSatF32x4ToI32x4=100]="TruncSatF32x4ToI32x4",e[e.TruncSatF32x4ToU32x4=101]="TruncSatF32x4ToU32x4",e[e.TruncSatF64x2ToI64x2=102]="TruncSatF64x2ToI64x2",e[e.TruncSatF64x2ToU64x2=103]="TruncSatF64x2ToU64x2",e[e.ConvertI32x4ToF32x4=104]="ConvertI32x4ToF32x4",e[e.ConvertU32x4ToF32x4=105]="ConvertU32x4ToF32x4",e[e.ConvertI64x2ToF64x2=106]="ConvertI64x2ToF64x2",e[e.ConvertU64x2ToF64x2=107]="ConvertU64x2ToF64x2",e[e.WidenLowI8x16ToI16x8=108]="WidenLowI8x16ToI16x8",e[e.WidenHighI8x16ToI16x8=109]="WidenHighI8x16ToI16x8",e[e.WidenLowU8x16ToU16x8=110]="WidenLowU8x16ToU16x8",e[e.WidenHighU8x16ToU16x8=111]="WidenHighU8x16ToU16x8",e[e.WidenLowI16x8ToI32x4=112]="WidenLowI16x8ToI32x4",e[e.WidenHighI16x8ToI32x4=113]="WidenHighI16x8ToI32x4",e[e.WidenLowU16x8ToU32x4=114]="WidenLowU16x8ToU32x4",e[e.WidenHighU16x8ToU32x4=115]="WidenHighU16x8ToU32x4"}(n.UnaryOp||(n.UnaryOp={})),function(e){e[e.AddI32=0]="AddI32",e[e.SubI32=1]="SubI32",e[e.MulI32=2]="MulI32",e[e.DivI32=3]="DivI32",e[e.DivU32=4]="DivU32",e[e.RemI32=5]="RemI32",e[e.RemU32=6]="RemU32",e[e.AndI32=7]="AndI32",e[e.OrI32=8]="OrI32",e[e.XorI32=9]="XorI32",e[e.ShlI32=10]="ShlI32",e[e.ShrI32=11]="ShrI32",e[e.ShrU32=12]="ShrU32",e[e.RotlI32=13]="RotlI32",e[e.RotrI32=14]="RotrI32",e[e.EqI32=15]="EqI32",e[e.NeI32=16]="NeI32",e[e.LtI32=17]="LtI32",e[e.LtU32=18]="LtU32",e[e.LeI32=19]="LeI32",e[e.LeU32=20]="LeU32",e[e.GtI32=21]="GtI32",e[e.GtU32=22]="GtU32",e[e.GeI32=23]="GeI32",e[e.GeU32=24]="GeU32",e[e.AddI64=25]="AddI64",e[e.SubI64=26]="SubI64",e[e.MulI64=27]="MulI64",e[e.DivI64=28]="DivI64",e[e.DivU64=29]="DivU64",e[e.RemI64=30]="RemI64",e[e.RemU64=31]="RemU64",e[e.AndI64=32]="AndI64",e[e.OrI64=33]="OrI64",e[e.XorI64=34]="XorI64",e[e.ShlI64=35]="ShlI64",e[e.ShrI64=36]="ShrI64",e[e.ShrU64=37]="ShrU64",e[e.RotlI64=38]="RotlI64",e[e.RotrI64=39]="RotrI64",e[e.EqI64=40]="EqI64",e[e.NeI64=41]="NeI64",e[e.LtI64=42]="LtI64",e[e.LtU64=43]="LtU64",e[e.LeI64=44]="LeI64",e[e.LeU64=45]="LeU64",e[e.GtI64=46]="GtI64",e[e.GtU64=47]="GtU64",e[e.GeI64=48]="GeI64",e[e.GeU64=49]="GeU64",e[e.AddF32=50]="AddF32",e[e.SubF32=51]="SubF32",e[e.MulF32=52]="MulF32",e[e.DivF32=53]="DivF32",e[e.CopysignF32=54]="CopysignF32",e[e.MinF32=55]="MinF32",e[e.MaxF32=56]="MaxF32",e[e.EqF32=57]="EqF32",e[e.NeF32=58]="NeF32",e[e.LtF32=59]="LtF32",e[e.LeF32=60]="LeF32",e[e.GtF32=61]="GtF32",e[e.GeF32=62]="GeF32",e[e.AddF64=63]="AddF64",e[e.SubF64=64]="SubF64",e[e.MulF64=65]="MulF64",e[e.DivF64=66]="DivF64",e[e.CopysignF64=67]="CopysignF64",e[e.MinF64=68]="MinF64",e[e.MaxF64=69]="MaxF64",e[e.EqF64=70]="EqF64",e[e.NeF64=71]="NeF64",e[e.LtF64=72]="LtF64",e[e.LeF64=73]="LeF64",e[e.GtF64=74]="GtF64",e[e.GeF64=75]="GeF64",e[e.EqI8x16=76]="EqI8x16",e[e.NeI8x16=77]="NeI8x16",e[e.LtI8x16=78]="LtI8x16",e[e.LtU8x16=79]="LtU8x16",e[e.GtI8x16=80]="GtI8x16",e[e.GtU8x16=81]="GtU8x16",e[e.LeI8x16=82]="LeI8x16",e[e.LeU8x16=83]="LeU8x16",e[e.GeI8x16=84]="GeI8x16",e[e.GeU8x16=85]="GeU8x16",e[e.EqI16x8=86]="EqI16x8",e[e.NeI16x8=87]="NeI16x8",e[e.LtI16x8=88]="LtI16x8",e[e.LtU16x8=89]="LtU16x8",e[e.GtI16x8=90]="GtI16x8",e[e.GtU16x8=91]="GtU16x8",e[e.LeI16x8=92]="LeI16x8",e[e.LeU16x8=93]="LeU16x8",e[e.GeI16x8=94]="GeI16x8",e[e.GeU16x8=95]="GeU16x8",e[e.EqI32x4=96]="EqI32x4",e[e.NeI32x4=97]="NeI32x4",e[e.LtI32x4=98]="LtI32x4",e[e.LtU32x4=99]="LtU32x4",e[e.GtI32x4=100]="GtI32x4",e[e.GtU32x4=101]="GtU32x4",e[e.LeI32x4=102]="LeI32x4",e[e.LeU32x4=103]="LeU32x4",e[e.GeI32x4=104]="GeI32x4",e[e.GeU32x4=105]="GeU32x4",e[e.EqF32x4=106]="EqF32x4",e[e.NeF32x4=107]="NeF32x4",e[e.LtF32x4=108]="LtF32x4",e[e.GtF32x4=109]="GtF32x4",e[e.LeF32x4=110]="LeF32x4",e[e.GeF32x4=111]="GeF32x4",e[e.EqF64x2=112]="EqF64x2",e[e.NeF64x2=113]="NeF64x2",e[e.LtF64x2=114]="LtF64x2",e[e.GtF64x2=115]="GtF64x2",e[e.LeF64x2=116]="LeF64x2",e[e.GeF64x2=117]="GeF64x2",e[e.AndV128=118]="AndV128",e[e.OrV128=119]="OrV128",e[e.XorV128=120]="XorV128",e[e.AndNotV128=121]="AndNotV128",e[e.AddI8x16=122]="AddI8x16",e[e.AddSatI8x16=123]="AddSatI8x16",e[e.AddSatU8x16=124]="AddSatU8x16",e[e.SubI8x16=125]="SubI8x16",e[e.SubSatI8x16=126]="SubSatI8x16",e[e.SubSatU8x16=127]="SubSatU8x16",e[e.MulI8x16=128]="MulI8x16",e[e.MinI8x16=129]="MinI8x16",e[e.MinU8x16=130]="MinU8x16",e[e.MaxI8x16=131]="MaxI8x16",e[e.MaxU8x16=132]="MaxU8x16",e[e.AvgrU8x16=133]="AvgrU8x16",e[e.AddI16x8=134]="AddI16x8",e[e.AddSatI16x8=135]="AddSatI16x8",e[e.AddSatU16x8=136]="AddSatU16x8",e[e.SubI16x8=137]="SubI16x8",e[e.SubSatI16x8=138]="SubSatI16x8",e[e.SubSatU16x8=139]="SubSatU16x8",e[e.MulI16x8=140]="MulI16x8",e[e.MinI16x8=141]="MinI16x8",e[e.MinU16x8=142]="MinU16x8",e[e.MaxI16x8=143]="MaxI16x8",e[e.MaxU16x8=144]="MaxU16x8",e[e.AvgrU16x8=145]="AvgrU16x8",e[e.AddI32x4=151]="AddI32x4",e[e.SubI32x4=152]="SubI32x4",e[e.MulI32x4=153]="MulI32x4",e[e.MinI32x4=154]="MinI32x4",e[e.MinU32x4=155]="MinU32x4",e[e.MaxI32x4=156]="MaxI32x4",e[e.MaxU32x4=157]="MaxU32x4",e[e.DotI16x8=158]="DotI16x8",e[e.AddI64x2=163]="AddI64x2",e[e.SubI64x2=164]="SubI64x2",e[e.AddF32x4=170]="AddF32x4",e[e.SubF32x4=171]="SubF32x4",e[e.MulF32x4=172]="MulF32x4",e[e.DivF32x4=173]="DivF32x4",e[e.MinF32x4=174]="MinF32x4",e[e.MaxF32x4=175]="MaxF32x4",e[e.PminF32x4=176]="PminF32x4",e[e.PmaxF32x4=177]="PmaxF32x4",e[e.AddF64x2=178]="AddF64x2",e[e.SubF64x2=179]="SubF64x2",e[e.MulF64x2=180]="MulF64x2",e[e.DivF64x2=181]="DivF64x2",e[e.MinF64x2=182]="MinF64x2",e[e.MaxF64x2=183]="MaxF64x2",e[e.PminF64x2=184]="PminF64x2",e[e.PmaxF64x2=185]="PmaxF64x2",e[e.NarrowI16x8ToI8x16=186]="NarrowI16x8ToI8x16",e[e.NarrowU16x8ToU8x16=187]="NarrowU16x8ToU8x16",e[e.NarrowI32x4ToI16x8=188]="NarrowI32x4ToI16x8",e[e.NarrowU32x4ToU16x8=189]="NarrowU32x4ToU16x8",e[e.SwizzleV8x16=190]="SwizzleV8x16"}(u=n.BinaryOp||(n.BinaryOp={})),function(e){e[e.Add=0]="Add",e[e.Sub=1]="Sub",e[e.And=2]="And",e[e.Or=3]="Or",e[e.Xor=4]="Xor",e[e.Xchg=5]="Xchg"}(n.AtomicRMWOp||(n.AtomicRMWOp={})),function(e){e[e.ExtractLaneI8x16=0]="ExtractLaneI8x16",e[e.ExtractLaneU8x16=1]="ExtractLaneU8x16",e[e.ExtractLaneI16x8=2]="ExtractLaneI16x8",e[e.ExtractLaneU16x8=3]="ExtractLaneU16x8",e[e.ExtractLaneI32x4=4]="ExtractLaneI32x4",e[e.ExtractLaneI64x2=5]="ExtractLaneI64x2",e[e.ExtractLaneF32x4=6]="ExtractLaneF32x4",e[e.ExtractLaneF64x2=7]="ExtractLaneF64x2"}(n.SIMDExtractOp||(n.SIMDExtractOp={})),function(e){e[e.ReplaceLaneI8x16=0]="ReplaceLaneI8x16",e[e.ReplaceLaneI16x8=1]="ReplaceLaneI16x8",e[e.ReplaceLaneI32x4=2]="ReplaceLaneI32x4",e[e.ReplaceLaneI64x2=3]="ReplaceLaneI64x2",e[e.ReplaceLaneF32x4=4]="ReplaceLaneF32x4",e[e.ReplaceLaneF64x2=5]="ReplaceLaneF64x2"}(n.SIMDReplaceOp||(n.SIMDReplaceOp={})),function(e){e[e.ShlI8x16=0]="ShlI8x16",e[e.ShrI8x16=1]="ShrI8x16",e[e.ShrU8x16=2]="ShrU8x16",e[e.ShlI16x8=3]="ShlI16x8",e[e.ShrI16x8=4]="ShrI16x8",e[e.ShrU16x8=5]="ShrU16x8",e[e.ShlI32x4=6]="ShlI32x4",e[e.ShrI32x4=7]="ShrI32x4",e[e.ShrU32x4=8]="ShrU32x4",e[e.ShlI64x2=9]="ShlI64x2",e[e.ShrI64x2=10]="ShrI64x2",e[e.ShrU64x2=11]="ShrU64x2"}(n.SIMDShiftOp||(n.SIMDShiftOp={})),function(e){e[e.Bitselect=0]="Bitselect",e[e.QFMAF32x4=1]="QFMAF32x4",e[e.QFMSF32x4=2]="QFMSF32x4",e[e.QFMAF64x2=3]="QFMAF64x2",e[e.QFMSF64x2=4]="QFMSF64x2"}(n.SIMDTernaryOp||(n.SIMDTernaryOp={})),function(e){e[e.LoadSplatV8x16=0]="LoadSplatV8x16",e[e.LoadSplatV16x8=1]="LoadSplatV16x8",e[e.LoadSplatV32x4=2]="LoadSplatV32x4",e[e.LoadSplatV64x2=3]="LoadSplatV64x2",e[e.LoadI8ToI16x8=4]="LoadI8ToI16x8",e[e.LoadU8ToU16x8=5]="LoadU8ToU16x8",e[e.LoadI16ToI32x4=6]="LoadI16ToI32x4",e[e.LoadU16ToU32x4=7]="LoadU16ToU32x4",e[e.LoadI32ToI64x2=8]="LoadI32ToI64x2",e[e.LoadU32ToU64x2=9]="LoadU32ToU64x2"}(n.SIMDLoadOp||(n.SIMDLoadOp={})),function(e){e[e.Default=0]="Default",e[e.PreserveSideeffects=1]="PreserveSideeffects",e[e.TraverseCalls=2]="TraverseCalls"}(n.ExpressionRunnerFlags||(n.ExpressionRunnerFlags={})),n.MemorySegment=class{constructor(e,n){this.buffer=e,this.offset=n}};class p{constructor(e,n){this.ref=e,this.useShadowStack=n,this.hasTemporaryFunction=!1,this.cachedStringsToPointers=new Map,this.cachedPointersToStrings=new Map,this.lit=a._malloc(a._BinaryenSizeofLiteral())}static create(e){return new p(a._BinaryenModuleCreate(),e)}static createFrom(e,n){var t=b(e),r=new p(a._BinaryenModuleRead(t,e.length),n);return a._free(changetype(t)),r}i32(e){var n=this.lit;return a._BinaryenLiteralInt32(n,e),a._BinaryenConst(this.ref,n)}i64(e,n=0){var t=this.lit;return a._BinaryenLiteralInt64(t,e,n),a._BinaryenConst(this.ref,t)}f32(e){var n=this.lit;return a._BinaryenLiteralFloat32(n,e),a._BinaryenConst(this.ref,n)}f64(e){var n=this.lit;return a._BinaryenLiteralFloat64(n,e),a._BinaryenConst(this.ref,n)}v128(e){assert(16==e.length);var n=this.lit;for(let t=0;t<16;++t)a.__i32_store8(n+t,e[t]);return a._BinaryenLiteralVec128(n,n),a._BinaryenConst(this.ref,n)}ref_null(e){return a._BinaryenRefNull(this.ref,e)}unary(e,n){return a._BinaryenUnary(this.ref,e,n)}binary(e,n,t){return a._BinaryenBinary(this.ref,e,n,t)}memory_size(){return a._BinaryenMemorySize(this.ref)}memory_grow(e){return a._BinaryenMemoryGrow(this.ref,e)}local_get(e,n){return a._BinaryenLocalGet(this.ref,e,n)}tostack(e){if(this.useShadowStack){let n=a._BinaryenExpressionGetType(e);return assert(n==s.I32||n==s.Unreachable),this.call(r.BuiltinNames.tostack,[e],n)}return e}local_tee(e,n,t,r=s.Auto){return r==s.Auto&&(r=a._BinaryenExpressionGetType(n)),t&&this.useShadowStack&&(n=this.tostack(n)),a._BinaryenLocalTee(this.ref,e,n,r)}global_get(e,n){var t=this.allocStringCached(e);return a._BinaryenGlobalGet(this.ref,t,n)}load(e,n,t,r,i=0,s=e){return a._BinaryenLoad(this.ref,e,n,i,s,r,t)}store(e,n,t,r,i=0,s=e){return a._BinaryenStore(this.ref,e,i,s,n,t,r)}atomic_load(e,n,t,r=0){return a._BinaryenAtomicLoad(this.ref,e,r,t,n)}atomic_store(e,n,t,r,i=0){return a._BinaryenAtomicStore(this.ref,e,i,n,t,r)}atomic_rmw(e,n,t,r,i,s){return a._BinaryenAtomicRMW(this.ref,e,n,t,r,i,s)}atomic_cmpxchg(e,n,t,r,i,s){return a._BinaryenAtomicCmpxchg(this.ref,e,n,t,r,i,s)}atomic_wait(e,n,t,r){return a._BinaryenAtomicWait(this.ref,e,n,t,r)}atomic_notify(e,n){return a._BinaryenAtomicNotify(this.ref,e,n)}atomic_fence(){return a._BinaryenAtomicFence(this.ref)}local_set(e,n,t){return t&&this.useShadowStack&&(n=this.tostack(n)),a._BinaryenLocalSet(this.ref,e,n)}global_set(e,n){var t=this.allocStringCached(e);return a._BinaryenGlobalSet(this.ref,t,n)}block(e,n,t=s.None){var r=this.allocStringCached(e),i=v(n),o=a._BinaryenBlock(this.ref,r,i,n.length,t);return a._free(i),o}flatten(e,n=s.None){var t=e.length;if(0==t)return this.nop();if(1==t){let t=e[0];switch(d(t)){case l.Return:case l.Throw:case l.Unreachable:return t}let r=h(t);return assert(r==s.Unreachable||r==n),t}return this.block(null,e,n)}br(e,n=0,t=0){var r=this.allocStringCached(e);return a._BinaryenBreak(this.ref,r,n,t)}drop(e){return a._BinaryenDrop(this.ref,e)}maybeDropCondition(e,n){return 0!=(T(e)&~(c.ReadsLocal|c.ReadsGlobal))?this.block(null,[this.drop(e),n],h(n)):n}loop(e,n){var t=this.allocStringCached(e);return a._BinaryenLoop(this.ref,t,n)}if(e,n,t=0){return a._BinaryenIf(this.ref,e,n,t)}nop(){return a._BinaryenNop(this.ref)}return(e=0){return a._BinaryenReturn(this.ref,e)}select(e,n,t,r=s.Auto){return r==s.Auto&&(r=a._BinaryenExpressionGetType(e),assert(r==a._BinaryenExpressionGetType(n))),a._BinaryenSelect(this.ref,t,e,n,r)}switch(e,n,t,r=0){var i=e.length,s=new Array(i);for(let n=0;n<i;++n)s[n]=this.allocStringCached(e[n]);var o=v(s),l=this.allocStringCached(n),u=a._BinaryenSwitch(this.ref,o,i,l,t,r);return a._free(o),u}call(e,n,t,r=!1){var i=this.allocStringCached(e),s=v(n),o=r?a._BinaryenReturnCall(this.ref,i,s,n?n.length:0,t):a._BinaryenCall(this.ref,i,s,n?n.length:0,t);return a._free(s),o}return_call(e,n,t){return this.call(e,n,t,!0)}call_indirect(e,n,t,r,i=!1){var s=v(n),o=i?a._BinaryenReturnCallIndirect(this.ref,e,s,n?n.length:0,t,r):a._BinaryenCallIndirect(this.ref,e,s,n?n.length:0,t,r);return a._free(s),o}return_call_indirect(e,n,t,r){return this.call_indirect(e,n,t,r,!0)}unreachable(){return a._BinaryenUnreachable(this.ref)}memory_copy(e,n,t){return a._BinaryenMemoryCopy(this.ref,e,n,t)}memory_fill(e,n,t){return a._BinaryenMemoryFill(this.ref,e,n,t)}try(e,n){return a._BinaryenTry(this.ref,e,n)}throw(e,n){var t=this.allocStringCached(e),r=v(n),i=a._BinaryenThrow(this.ref,t,r,n.length);return a._free(r),i}rethrow(e){return a._BinaryenRethrow(this.ref,e)}br_on_exn(e,n,t){var r=this.allocStringCached(e),i=this.allocStringCached(n);return a._BinaryenBrOnExn(this.ref,r,i,t)}pop(e){return a._BinaryenPop(this.ref,e)}tuple_make(e){var n=v(e),t=a._BinaryenTupleMake(this.ref,n,e.length);return a._free(n),t}tuple_extract(e,n){return a._BinaryenTupleExtract(this.ref,e,n)}simd_extract(e,n,t){return a._BinaryenSIMDExtract(this.ref,e,n,t)}simd_replace(e,n,t,r){return a._BinaryenSIMDReplace(this.ref,e,n,t,r)}simd_shuffle(e,n,t){assert(16==t.length);var r=b(t),i=a._BinaryenSIMDShuffle(this.ref,e,n,r);return a._free(r),i}simd_ternary(e,n,t,r){return a._BinaryenSIMDTernary(this.ref,e,n,t,r)}simd_shift(e,n,t){return a._BinaryenSIMDShift(this.ref,e,n,t)}simd_load(e,n,t,r){return a._BinaryenSIMDLoad(this.ref,e,t,r,n)}ref_is_null(e){return a._BinaryenRefIsNull(this.ref,e)}ref_func(e,n){var t=this.allocStringCached(e);return a._BinaryenRefFunc(this.ref,t,n)}addGlobal(e,n,t,r){var i=this.allocStringCached(e);return a._BinaryenAddGlobal(this.ref,i,n,t,r)}getGlobal(e){var n=this.allocStringCached(e);return a._BinaryenGetGlobal(this.ref,n)}removeGlobal(e){var n=this.allocStringCached(e);a._BinaryenRemoveGlobal(this.ref,n)}addEvent(e,n,t,r){var i=this.allocStringCached(e);return a._BinaryenAddEvent(this.ref,i,n,t,r)}getEvent(e){var n=this.allocStringCached(e);return a._BinaryenGetEvent(this.ref,n)}removeEvent(e){var n=this.allocStringCached(e);a._BinaryenRemoveEvent(this.ref,n)}addFunction(e,n,t,r,i){var s=this.allocStringCached(e),o=v(r),l=a._BinaryenAddFunction(this.ref,s,n,t,o,r?r.length:0,i);return a._free(o),l}getFunction(e){var n=this.allocStringCached(e);return a._BinaryenGetFunction(this.ref,n)}removeFunction(e){var n=this.allocStringCached(e);a._BinaryenRemoveFunction(this.ref,n)}hasFunction(e){var n=this.allocStringCached(e);return 0!=a._BinaryenGetFunction(this.ref,n)}addTemporaryFunction(e,n,t){this.hasTemporaryFunction=assert(!this.hasTemporaryFunction);var r=this.allocStringCached(""),i=v(n),s=a._BinaryenAddFunction(this.ref,r,f(n),e,0,0,t);return a._free(i),s}removeTemporaryFunction(){this.hasTemporaryFunction=!assert(this.hasTemporaryFunction);var e=this.allocStringCached("");a._BinaryenRemoveFunction(this.ref,e)}setStart(e){a._BinaryenSetStart(this.ref,e)}addFunctionExport(e,n){var t=this.allocStringCached(e),r=this.allocStringCached(n);return a._BinaryenAddFunctionExport(this.ref,t,r)}addTableExport(e,n){var t=this.allocStringCached(e),r=this.allocStringCached(n);return a._BinaryenAddTableExport(this.ref,t,r)}addMemoryExport(e,n){var t=this.allocStringCached(e),r=this.allocStringCached(n);return a._BinaryenAddMemoryExport(this.ref,t,r)}addGlobalExport(e,n){var t=this.allocStringCached(e),r=this.allocStringCached(n);return a._BinaryenAddGlobalExport(this.ref,t,r)}addEventExport(e,n){var t=this.allocStringCached(e),r=this.allocStringCached(n);return a._BinaryenAddEventExport(this.ref,t,r)}removeExport(e){var n=this.allocStringCached(e);a._BinaryenRemoveExport(this.ref,n)}hasExport(e){var n=this.allocStringCached(e);return 0!=a._BinaryenGetExport(this.ref,n)}addFunctionImport(e,n,t,r,i){var s=this.allocStringCached(e),o=this.allocStringCached(n),l=this.allocStringCached(t);a._BinaryenAddFunctionImport(this.ref,s,o,l,r,i)}addTableImport(e,n,t){var r=this.allocStringCached(e),i=this.allocStringCached(n),s=this.allocStringCached(t);a._BinaryenAddTableImport(this.ref,r,i,s)}addMemoryImport(e,n,t,r=!1){var i=this.allocStringCached(e),s=this.allocStringCached(n),o=this.allocStringCached(t);a._BinaryenAddMemoryImport(this.ref,i,s,o,r)}addGlobalImport(e,n,t,r,i=!1){var s=this.allocStringCached(e),o=this.allocStringCached(n),l=this.allocStringCached(t);a._BinaryenAddGlobalImport(this.ref,s,o,l,r,i)}addEventImport(e,n,t,r,i,s){var o=this.allocStringCached(e),l=this.allocStringCached(n),u=this.allocStringCached(t);a._BinaryenAddEventImport(this.ref,o,l,u,r,i,s)}setMemory(e,n,t,r,s=null,o=!1){var l=this.allocStringCached(s),u=t.length,c=new Array(u),p=new Uint8Array(u),f=new Array(u),d=new Array(u);for(let e=0;e<u;++e){let n=t[e],a=n.buffer,s=n.offset;c[e]=b(a),p[e]=0,f[e]=r==i.Target.WASM64?this.i64(i64_low(s),i64_high(s)):this.i32(i64_low(s)),d[e]=a.length}var h=v(c),g=b(p),x=v(f),m=function(e){if(!e)return 0;var n=e.length,t=a._malloc(n<<2),r=t;for(let t=0;t<n;++t){let n=e[t];a.__i32_store(r,n),r+=4}return t}(d);a._BinaryenSetMemory(this.ref,e,n,l,h,g,x,m,u,o),a._free(m),a._free(x),a._free(g),a._free(h);for(let e=u-1;e>=0;--e)a._free(c[e])}setFunctionTable(e,n,t,r){var i=t.length,s=new Array(i);for(let e=0;e<i;++e)s[e]=this.allocStringCached(t[e]);var o=v(s);a._BinaryenSetFunctionTable(this.ref,e,n,o,i,r),a._free(o)}addCustomSection(e,n){var t=this.allocStringCached(e),r=b(n);a._BinaryenAddCustomSection(this.ref,t,r,n.length),a._free(r)}getOptimizeLevel(){return a._BinaryenGetOptimizeLevel()}setOptimizeLevel(e){a._BinaryenSetOptimizeLevel(e)}getShrinkLevel(){return a._BinaryenGetShrinkLevel()}setShrinkLevel(e){a._BinaryenSetShrinkLevel(e)}getDebugInfo(){return a._BinaryenGetDebugInfo()}setDebugInfo(e){a._BinaryenSetDebugInfo(e)}getLowMemoryUnused(){return a._BinaryenGetLowMemoryUnused()}setLowMemoryUnused(e){a._BinaryenSetLowMemoryUnused(e)}getFastMath(){return a._BinaryenGetFastMath()}setFastMath(e){a._BinaryenSetFastMath(e)}getPassArgument(e){var n=this.allocStringCached(e),t=a._BinaryenGetPassArgument(n);return t?F(t):null}setPassArgument(e,n){var t=this.allocStringCached(e),r=this.allocStringCached(n);a._BinaryenSetPassArgument(t,r)}clearPassArguments(){a._BinaryenClearPassArguments()}getAlwaysInlineMaxSize(){return a._BinaryenGetAlwaysInlineMaxSize()}setAlwaysInlineMaxSize(e){a._BinaryenSetAlwaysInlineMaxSize(e)}getFlexibleInlineMaxSize(){return a._BinaryenGetFlexibleInlineMaxSize()}setFlexibleInlineMaxSize(e){a._BinaryenSetFlexibleInlineMaxSize(e)}getOneCallerInlineMaxSize(){return a._BinaryenGetOneCallerInlineMaxSize()}setOneCallerInlineMaxSize(e){a._BinaryenSetOneCallerInlineMaxSize(e)}getAllowInliningFunctionsWithLoops(){return a._BinaryenGetAllowInliningFunctionsWithLoops()}setAllowInliningFunctionsWithLoops(e){a._BinaryenSetAllowInliningFunctionsWithLoops(e)}getFeatures(){return a._BinaryenModuleGetFeatures(this.ref)}setFeatures(e){a._BinaryenModuleSetFeatures(this.ref,e)}runPass(e,n=0){var t=A(e);n?a._BinaryenFunctionRunPasses(n,this.ref,t,1):a._BinaryenModuleRunPasses(this.ref,t,1),a._free(t)}runPasses(e,n=0){var t=e.length,r=new Array(t);for(let n=0;n<t;++n)r[n]=A(e[n]);var i=v(r);n?a._BinaryenFunctionRunPasses(n,this.ref,i,t):a._BinaryenModuleRunPasses(this.ref,i,t),a._free(i);for(let e=t-1;e>=0;--e)a._free(r[e])}optimize(e,n,t=!1){if((e>=3||n>=2)&&(e=4),this.setOptimizeLevel(e),this.setShrinkLevel(n),this.setDebugInfo(t),this.setFastMath(!0),this.clearPassArguments(),e>=2&&0==n?(this.setAlwaysInlineMaxSize(12),this.setFlexibleInlineMaxSize(70),this.setOneCallerInlineMaxSize(200),this.setAllowInliningFunctionsWithLoops(e>=3)):(this.setAlwaysInlineMaxSize(e<=1||n>=2?2:6),this.setFlexibleInlineMaxSize(65),this.setOneCallerInlineMaxSize(80),this.setAllowInliningFunctionsWithLoops(!1)),e>0||n>0){let t=new Array;t.push("duplicate-function-elimination"),t.push("remove-unused-module-elements"),(e>=3||n>=1)&&(t.push("simplify-locals-notee-nostructure"),t.push("rse"),t.push("vacuum"),t.push("ssa-nomerge"),t.push("simplify-globals-optimizing"),t.push("remove-unused-brs"),t.push("remove-unused-names"),t.push("merge-blocks"),t.push("precompute-propagate")),e>=3&&(t.push("flatten"),t.push("vacuum"),t.push("simplify-locals-notee-nostructure"),t.push("merge-locals"),t.push("code-folding"),t.push("flatten"),t.push("vacuum"),t.push("local-cse"),t.push("reorder-locals")),t.push("optimize-instructions"),(e>=3||n>=1)&&t.push("dce"),t.push("remove-unused-names"),t.push("remove-unused-brs"),e>=3||n>=2?(t.push("inlining"),t.push("precompute-propagate")):t.push("precompute"),(e>=2||n>=1)&&(t.push("pick-load-signs"),t.push("simplify-globals-optimizing")),e>=3&&n<=1&&t.push("licm"),t.push("simplify-locals-nostructure"),t.push("vacuum"),t.push("reorder-locals"),t.push("remove-unused-brs"),t.push("coalesce-locals"),t.push("simplify-locals"),t.push("vacuum"),t.push("reorder-locals"),t.push("coalesce-locals"),t.push("reorder-locals"),(e>=3||n>=1)&&t.push("merge-locals"),t.push("vacuum"),(e>=2||n>=1)&&t.push("simplify-globals-optimizing"),t.push("merge-blocks"),t.push("remove-unused-brs"),t.push("remove-unused-names"),t.push("merge-blocks"),e>=3&&t.push("optimize-instructions"),(e>=2||n>=1)&&(t.push("rse"),t.push("vacuum")),(e>=2||n>=1)&&(t.push("simplify-globals-optimizing"),t.push("dae-optimizing")),(e>=2||n>=2)&&t.push("inlining-optimizing"),this.getLowMemoryUnused()&&(e>=3||n>=1?t.push("optimize-added-constants-propagate"):t.push("optimize-added-constants")),t.push("duplicate-import-elimination"),e>=2||n>=2?t.push("simplify-globals-optimizing"):(t.push("simplify-globals"),t.push("vacuum")),(e>=3||n>=1)&&t.push("code-folding"),e>=2||n>=1?t.push("precompute-propagate"):t.push("precompute"),t.push("directize"),t.push("dae-optimizing"),t.push("inlining-optimizing"),(e>=2||n>=1)&&(t.push("rse"),t.push("code-pushing"),e>=3&&(t.push("simplify-globals"),t.push("vacuum"),t.push("precompute-propagate"),t.push("inlining-optimizing"),t.push("directize"),t.push("dae-optimizing"),t.push("merge-locals"),t.push("coalesce-locals"),t.push("simplify-locals"),t.push("vacuum"),t.push("inlining"),t.push("precompute-propagate"),t.push("vacuum"),t.push("coalesce-locals")),t.push("remove-unused-brs"),t.push("remove-unused-names"),t.push("vacuum"),t.push("optimize-instructions"),t.push("simplify-globals-optimizing")),t.push("duplicate-function-elimination"),t.push("remove-unused-nonfunction-module-elements"),t.push("memory-packing"),t.push("remove-unused-module-elements"),this.runPasses(t)}}validate(){return 1==a._BinaryenModuleValidate(this.ref)}interpret(){a._BinaryenModuleInterpret(this.ref)}toBinary(e=null){var n=this.lit;assert(a._BinaryenSizeofLiteral()>=12);var t,r,i=A(e);a._BinaryenModuleAllocateAndWrite(n,this.ref,i),t=assert(a.__i32_load(n));var s=a.__i32_load(n+4);r=a.__i32_load(n+8);var o=new C(function(e,n){var t=new Uint8Array(n);for(let r=0;r<n;++r)t[r]=a.__i32_load8_u(e+r);return t}(t,s),F(r));return i&&a._free(i),a._free(t),r&&a._free(r),o}toText(e=!0){throw new Error("not implemented")}toAsmjs(){throw new Error("not implemented")}allocStringCached(e){if(null===e)return 0;var n=this.cachedStringsToPointers;if(n.has(e))return changetype(n.get(e));var t=A(e);return n.set(e,t),t}readStringCached(e){if(0==e)return null;var n=this.cachedPointersToStrings;if(n.has(e))return changetype(this.cachedPointersToStrings.get(e));var t=F(e);return n.set(e,t),t}dispose(){assert(this.ref);for(let e=Map_values(this.cachedStringsToPointers),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);a._free(t)}this.cachedStringsToPointers.clear(),this.cachedPointersToStrings.clear(),a._free(this.lit),a._BinaryenModuleDispose(this.ref),this.ref=0}createRelooper(){return E.create(this)}cloneExpression(e,n=!1,t=i32.MAX_VALUE){if(t<0)return 0;var r,i;switch(t-=1,a._BinaryenExpressionGetId(e)){case l.Const:switch(a._BinaryenExpressionGetType(e)){case s.I32:return this.i32(a._BinaryenConstGetValueI32(e));case s.I64:return this.i64(a._BinaryenConstGetValueI64Low(e),a._BinaryenConstGetValueI64High(e));case s.F32:return this.f32(a._BinaryenConstGetValueF32(e));case s.F64:return this.f64(a._BinaryenConstGetValueF64(e));case s.V128:case s.Externref:return 0;default:throw new Error("concrete type expected")}case l.LocalGet:return a._BinaryenLocalGet(this.ref,a._BinaryenLocalGetGetIndex(e),a._BinaryenExpressionGetType(e));case l.GlobalGet:{let n=a._BinaryenGlobalGetGetName(e);if(!n)break;return a._BinaryenGlobalGet(this.ref,n,a._BinaryenExpressionGetType(e))}case l.Load:if(!(r=this.cloneExpression(a._BinaryenLoadGetPtr(e),n,t)))break;return a._BinaryenLoadIsAtomic(e)?a._BinaryenAtomicLoad(this.ref,a._BinaryenLoadGetBytes(e),a._BinaryenLoadGetOffset(e),a._BinaryenExpressionGetType(e),r):a._BinaryenLoad(this.ref,a._BinaryenLoadGetBytes(e),a._BinaryenLoadIsSigned(e),a._BinaryenLoadGetOffset(e),a._BinaryenLoadGetAlign(e),a._BinaryenExpressionGetType(e),r);case l.Unary:if(!(r=this.cloneExpression(a._BinaryenUnaryGetValue(e),n,t)))break;return a._BinaryenUnary(this.ref,a._BinaryenUnaryGetOp(e),r);case l.Binary:if(!(r=this.cloneExpression(a._BinaryenBinaryGetLeft(e),n,t)))break;if(!(i=this.cloneExpression(a._BinaryenBinaryGetRight(e),n,t)))break;return a._BinaryenBinary(this.ref,a._BinaryenBinaryGetOp(e),r,i)}return 0}copyExpression(e){return a._BinaryenExpressionCopy(e,this.ref)}runExpression(e,n,t=50,r=1){var i=a._ExpressionRunnerCreate(this.ref,n,t,r),s=a._ExpressionRunnerRunAndDispose(i,e);return s&&(assert(d(s)==l.Const),assert(h(s)==h(e))),s}addDebugInfoFile(e){var n=A(e),t=a._BinaryenModuleAddDebugInfoFileName(this.ref,n);return a._free(n),t}getDebugInfoFile(e){return F(a._BinaryenModuleGetDebugInfoFileName(this.ref,e))}setDebugLocation(e,n,t,r,i){a._BinaryenFunctionSetDebugLocation(e,n,t,r,i)}}function f(e){if(!e)return s.None;switch(e.length){case 0:return s.None;case 1:return e[0]}var n=v(e),t=a._BinaryenTypeCreate(n,e.length);return a._free(n),t}function d(e){return a._BinaryenExpressionGetId(e)}function h(e){return a._BinaryenExpressionGetType(e)}function g(e){return a._BinaryenConstGetValueI32(e)}function x(e){return a._BinaryenConstGetValueI64Low(e)}function m(e){return a._BinaryenConstGetValueI64High(e)}function _(e){return a._BinaryenConstGetValueF32(e)}function y(e){return a._BinaryenConstGetValueF64(e)}n.Module=p,p.UNLIMITED_MEMORY=-1,p.UNLIMITED_TABLE=-1,n.createType=f,n.expandType=function(e){var n=a._BinaryenTypeArity(e),t=a._malloc(n<<2);a._BinaryenTypeExpand(e,t);var r=new Array(n);for(let e=0;e<n;++e)r[e]=a.__i32_load(t+(e<<2));return a._free(t),r},n.getExpressionId=d,n.getExpressionType=h,n.getConstValueI32=g,n.getConstValueI64Low=x,n.getConstValueI64High=m,n.getConstValueF32=_,n.getConstValueF64=y,n.isConstZero=function(e){if(d(e)!=l.Const)return!1;var n=h(e);return n==s.I32?0==g(e):n==s.I64?0==x(e)&&0==m(e):n==s.F32?0==_(e):n==s.F64&&0==y(e)},n.getLocalGetIndex=function(e){return a._BinaryenLocalGetGetIndex(e)},n.getLocalSetIndex=function(e){return a._BinaryenLocalSetGetIndex(e)},n.getLocalSetValue=function(e){return a._BinaryenLocalSetGetValue(e)},n.isLocalTee=function(e){return a._BinaryenLocalSetIsTee(e)},n.getGlobalGetName=function(e){return F(a._BinaryenGlobalGetGetName(e))},n.getBinaryOp=function(e){return a._BinaryenBinaryGetOp(e)},n.getBinaryLeft=function(e){return a._BinaryenBinaryGetLeft(e)},n.getBinaryRight=function(e){return a._BinaryenBinaryGetRight(e)},n.getUnaryOp=function(e){return a._BinaryenUnaryGetOp(e)},n.getUnaryValue=function(e){return a._BinaryenUnaryGetValue(e)},n.getLoadBytes=function(e){return a._BinaryenLoadGetBytes(e)},n.getLoadOffset=function(e){return a._BinaryenLoadGetOffset(e)},n.getLoadPtr=function(e){return a._BinaryenLoadGetPtr(e)},n.isLoadSigned=function(e){return a._BinaryenLoadIsSigned(e)},n.getStoreBytes=function(e){return a._BinaryenStoreGetBytes(e)},n.getStoreOffset=function(e){return a._BinaryenStoreGetOffset(e)},n.getStorePtr=function(e){return a._BinaryenStoreGetPtr(e)},n.getStoreValue=function(e){return a._BinaryenStoreGetValue(e)},n.getBlockName=function(e){return F(a._BinaryenBlockGetName(e))},n.getBlockChildCount=function(e){return a._BinaryenBlockGetNumChildren(e)},n.getBlockChildAt=function(e,n){return a._BinaryenBlockGetChildAt(e,n)},n.getIfCondition=function(e){return a._BinaryenIfGetCondition(e)},n.getIfTrue=function(e){return a._BinaryenIfGetIfTrue(e)},n.getIfFalse=function(e){return a._BinaryenIfGetIfFalse(e)},n.getLoopName=function(e){return F(a._BinaryenLoopGetName(e))},n.getLoopBody=function(e){return a._BinaryenLoopGetBody(e)},n.getBreakName=function(e){return F(a._BinaryenBreakGetName(e))},n.getBreakCondition=function(e){return a._BinaryenBreakGetCondition(e)},n.getSelectThen=function(e){return a._BinaryenSelectGetIfTrue(e)},n.getSelectElse=function(e){return a._BinaryenSelectGetIfFalse(e)},n.getSelectCondition=function(e){return a._BinaryenSelectGetCondition(e)},n.getDropValue=function(e){return a._BinaryenDropGetValue(e)},n.getReturnValue=function(e){return a._BinaryenReturnGetValue(e)},n.getCallTarget=function(e){return F(a._BinaryenCallGetTarget(e))},n.getCallOperandCount=function(e){return a._BinaryenCallGetNumOperands(e)},n.getCallOperandAt=function(e,n){return a._BinaryenCallGetOperandAt(e,n)},n.getMemoryGrowDelta=function(e){return a._BinaryenMemoryGrowGetDelta(e)},n.getFunctionBody=function(e){return a._BinaryenFunctionGetBody(e)},n.getFunctionName=function(e){return F(a._BinaryenFunctionGetName(e))},n.getFunctionParams=function(e){return a._BinaryenFunctionGetParams(e)},n.getFunctionResults=function(e){return a._BinaryenFunctionGetResults(e)},n.getFunctionVars=function(e){var n=a._BinaryenFunctionGetNumVars(e),t=new Array(n);for(let r=0;r<n;++r)t[r]=a._BinaryenFunctionGetVar(e,r);return t},n.getGlobalName=function(e){return F(a._BinaryenGlobalGetName(e))},n.getGlobalType=function(e){return a._BinaryenGlobalGetType(e)},n.isGlobalMutable=function(e){return a._BinaryenGlobalIsMutable(e)},n.getGlobalInit=function(e){return a._BinaryenGlobalGetInitExpr(e)},n.getEventName=function(e){return F(a._BinaryenEventGetName(e))},n.getEventAttribute=function(e){return a._BinaryenEventGetAttribute(e)},n.getEventParams=function(e){return a._BinaryenEventGetParams(e)},n.getEventResults=function(e){return a._BinaryenEventGetResults(e)};class E{constructor(e,n){this.module=e,this.ref=n}static create(e){return new E(e,a._RelooperCreate(e.ref))}addBlock(e){return a._RelooperAddBlock(this.ref,e)}addBranch(e,n,t=0,r=0){a._RelooperAddBranch(e,n,t,r)}addBlockWithSwitch(e,n){return a._RelooperAddBlockWithSwitch(this.ref,e,n)}addBranchForSwitch(e,n,t,r=0){var i=function(e){if(!e)return 0;var n=e.length,t=a._malloc(n<<2),r=t;for(let t=0;t<n;++t){let n=e[t];a.__i32_store(r,n),r+=4}return t}(t);a._RelooperAddBranchForSwitch(e,n,i,t.length,r),a._free(i)}renderAndDispose(e,n){return a._RelooperRenderAndDispose(this.ref,e,n)}}function T(e,n=o.All){return a._BinaryenExpressionGetSideEffects(e,n)}function b(e){if(!e)return 0;var n=e.length,t=a._malloc(n);for(let r=0;r<n;++r)a.__i32_store8(t+r,e[r]);return t}function v(e){if(!e)return 0;assert(ASC_TARGET!=i.Target.WASM64);var n=e.length,t=a._malloc(n<<2),r=t;for(let t=0,i=n;t<i;++t){let n=e[t];a.__i32_store(r,n),r+=4}return t}function A(e){if(null===e)return 0;var n=a._malloc(function(e){var n=0;for(let t=0,r=e.length;t<r;++t){let i=e.charCodeAt(t);i>=55296&&i<=57343&&t+1<r&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++t)),n+=i<=127?1:i<=2047?2:i<=65535?3:4}return n}(e)+1)>>>0,t=n;for(let n=0,r=e.length;n<r;++n){let i=e.charCodeAt(n);i>=55296&&i<=57343&&n+1<r&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++n)),i<=127?a.__i32_store8(t++,i):i<=2047?(a.__i32_store8(t++,192|i>>>6),a.__i32_store8(t++,128|63&i)):i<=65535?(a.__i32_store8(t++,224|i>>>12),a.__i32_store8(t++,128|i>>>6&63),a.__i32_store8(t++,128|63&i)):(assert(i<2097152,"Invalid Unicode code point during allocString"),a.__i32_store8(t++,240|i>>>18),a.__i32_store8(t++,128|i>>>12&63),a.__i32_store8(t++,128|i>>>6&63),a.__i32_store8(t++,128|63&i))}return a.__i32_store8(t,0),n}function F(e){if(!e)return null;for(var n,t,r,i,s=new Array;n=a.__i32_load8_u(e++);)if(128&n)if(t=63&a.__i32_load8_u(e++),192!=(224&n))if(r=63&a.__i32_load8_u(e++),224==(240&n)?n=(15&n)<<12|t<<6|r:(i=63&a.__i32_load8_u(e++),240==(248&n)?n=(7&n)<<18|t<<12|r<<6|i:assert(!1,"Invalid UTF8 sequence during readString")),n<65536)s.push(n);else{let e=n-65536;s.push(55296|e>>>10),s.push(56320|1023&e)}else s.push((31&n)<<6|t);else s.push(n);return String.fromCharCodes(s)}n.Relooper=E,n.SwitchBuilder=class{constructor(e,n){this.values=new Array,this.indexes=new Array,this.cases=new Array,this.defaultIndex=-1,this.module=e,this.condition=n}addCase(e,n){var t=this.cases,r=t.indexOf(n);r<0&&(r=t.length,t.push(n)),this.values.push(e),this.indexes.push(r)}addDefault(e){assert(-1==this.defaultIndex);var n=this.cases;this.defaultIndex=n.length,n.push(e)}render(e,n=""){var t=this.module,r=this.cases,i=r.length;if(!i)return t.drop(this.condition);var a=this.values,o=a.length,l=this.indexes,c=new Array(1+o+1),p=new Array(i);for(let e=0;e<i;++e)p[e]="case"+e.toString()+n;c[0]=t.local_set(e,this.condition,!1);for(let n=0;n<o;++n){let r=l[n];c[1+n]=t.br(p[r],t.binary(u.EqI32,t.local_get(e,s.I32),t.i32(a[n])))}var f=this.defaultIndex,d="default"+n;c[1+o]=t.br(~f?p[f]:d);var h=t.block(p[0],c);for(let e=1;e<i;++e){let n=r[e-1];n.unshift(h),h=t.block(p[e],n)}var g=r[i-1];return g.unshift(h),t.block(~f?null:d,g)}},function(e){e[e.None=0]="None",e[e.Branches=1]="Branches",e[e.Calls=2]="Calls",e[e.ReadsLocal=4]="ReadsLocal",e[e.WritesLocal=8]="WritesLocal",e[e.ReadsGlobal=16]="ReadsGlobal",e[e.WritesGlobal=32]="WritesGlobal",e[e.ReadsMemory=64]="ReadsMemory",e[e.WritesMemory=128]="WritesMemory",e[e.ImplicitTrap=256]="ImplicitTrap",e[e.IsAtomic=512]="IsAtomic",e[e.Throws=1024]="Throws",e[e.DanglingPop=2048]="DanglingPop",e[e.Any=4095]="Any"}(c=n.SideEffects||(n.SideEffects={})),n.getSideEffects=T,n.hasSideEffects=function(e,n=o.All){return T(e,n)!=c.None},n.allocPtrArray=v,n.readString=F;class C{constructor(e,n){this.output=e,this.sourceMap=n}}n.BinaryModule=C,n.needsExplicitUnreachable=function e(n){if(a._BinaryenExpressionGetType(n)!=s.Unreachable)return!1;switch(a._BinaryenExpressionGetId(n)){case l.Unreachable:case l.Return:return!1;case l.Break:return 0!=a._BinaryenBreakGetCondition(n);case l.Block:if(!a._BinaryenBlockGetName(n)){let t=a._BinaryenBlockGetNumChildren(n);return t>0&&e(a._BinaryenBlockGetChildAt(n,t-1))}}return!0}},215:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Precedence=n.Parser=void 0;const r=t(200),i=t(411),a=t(256),s=t(910),o=t(60);class l{constructor(e,n){this.source=e,this.reportNode=n}}class u extends a.DiagnosticEmitter{constructor(e=null,n=null){super(e),this.backlog=new Array,this.seenlog=new Set,this.donelog=new Set,this.onComment=null,this.currentSource=null,this.dependees=new Map,this.tryParseSignatureIsSignature=!1,this.parseParametersThis=null,this.sources=n||new Array}parseFile(e,n,t){var l=s.normalizePath(n),u=o.mangleInternalPath(n);if(!this.donelog.has(u)){if(this.donelog.add(u),this.seenlog.add(u),null===e){let e=this.dependees,t=null;return e.has(u)&&(t=assert(e.get(u))),void this.error(a.DiagnosticCode.File_0_not_found,t?t.reportNode.range:null,n)}var c=new o.Source(t?o.SourceKind.USER_ENTRY:n.startsWith(r.LIBRARY_PREFIX)?n.indexOf(r.PATH_DELIMITER,r.LIBRARY_PREFIX.length)<0?o.SourceKind.LIBRARY_ENTRY:o.SourceKind.LIBRARY:o.SourceKind.USER,l,e);this.sources.push(c),this.currentSource=c;var p=new i.Tokenizer(c,this.diagnostics);p.onComment=this.onComment;for(var f=c.statements;!p.skip(i.Token.ENDOFFILE);){let e=this.parseTopLevelStatement(p,null);e?f.push(e):this.skipStatement(p)}}}parseTopLevelStatement(e,n=null){for(var t=r.CommonFlags.NONE,s=-1,l=null;e.skip(i.Token.AT);){s<0&&(s=e.tokenPos);let n=this.parseDecorator(e);n?l?l.push(n):l=[n]:this.skipStatement(e)}var u=0,c=0,p=0,f=0;e.skip(i.Token.EXPORT)&&(s<0&&(s=e.tokenPos),t|=r.CommonFlags.EXPORT,u=e.tokenPos,c=e.pos,e.skip(i.Token.DEFAULT)&&(p=e.tokenPos,f=e.pos));var d=0,h=0,g=null!=n&&n.is(r.CommonFlags.AMBIENT);e.skip(i.Token.DECLARE)?g?this.error(a.DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,e.range()):(s<0&&(s=e.tokenPos),d=s,h=e.pos,t|=r.CommonFlags.DECLARE|r.CommonFlags.AMBIENT):g&&(t|=r.CommonFlags.AMBIENT);var x=null,m=e.peek();switch(s<0&&(s=e.nextTokenPos),m){case i.Token.CONST:e.next(),t|=r.CommonFlags.CONST,x=e.skip(i.Token.ENUM)?this.parseEnum(e,t,l,s):this.parseVariable(e,t,l,s),l=null;break;case i.Token.LET:t|=r.CommonFlags.LET;case i.Token.VAR:e.next(),x=this.parseVariable(e,t,l,s),l=null;break;case i.Token.ENUM:e.next(),x=this.parseEnum(e,t,l,s),l=null;break;case i.Token.FUNCTION:e.next(),x=this.parseFunction(e,t,l,s),l=null;break;case i.Token.ABSTRACT:{let n=e.mark();e.next();let s=e.tokenPos,o=e.pos,l=e.peek(!0);if(e.nextTokenOnNewLine){e.reset(n),x=this.parseStatement(e,!0);break}if(l!=i.Token.CLASS){l==i.Token.INTERFACE&&this.error(a.DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,e.range(s,o)),e.reset(n),x=this.parseStatement(e,!0);break}e.discard(n),t|=r.CommonFlags.ABSTRACT}case i.Token.CLASS:case i.Token.INTERFACE:e.next(),x=this.parseClassOrInterface(e,t,l,s),l=null;break;case i.Token.NAMESPACE:{let n=e.mark();e.next(),e.peek(!1,i.IdentifierHandling.PREFER)==i.Token.IDENTIFIER?(e.discard(n),x=this.parseNamespace(e,t,l,s),l=null):(e.reset(n),x=this.parseStatement(e,!0));break}case i.Token.IMPORT:e.next(),x=(t|=r.CommonFlags.IMPORT)&r.CommonFlags.EXPORT?this.parseExportImport(e,s):this.parseImport(e);break;case i.Token.TYPE:{let n=e.mark();e.next(),e.peek(!1,i.IdentifierHandling.PREFER)==i.Token.IDENTIFIER?(e.discard(n),x=this.parseTypeDeclaration(e,t,l,s),l=null):(e.reset(n),x=this.parseStatement(e,!0));break}default:t&r.CommonFlags.EXPORT?f&&e.skipIdentifier(i.IdentifierHandling.PREFER)?(h&&this.error(a.DiagnosticCode.An_export_assignment_cannot_have_modifiers,e.range(d,h)),x=this.parseExportDefaultAlias(e,s,p,f),p=f=0):x=this.parseExport(e,s,0!=(t&r.CommonFlags.DECLARE)):(c&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(u,c),"export"),h&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(d,h),"declare"),n||(x=this.parseStatement(e,!0)))}if(l)for(let e=0,n=l.length;e<n;++e)this.error(a.DiagnosticCode.Decorators_are_not_valid_here,l[e].range);if(f&&null!==x)switch(x.kind){case o.NodeKind.ENUMDECLARATION:case o.NodeKind.FUNCTIONDECLARATION:case o.NodeKind.CLASSDECLARATION:case o.NodeKind.INTERFACEDECLARATION:case o.NodeKind.NAMESPACEDECLARATION:return o.Node.createExportDefaultStatement(x,e.range(s,e.pos));default:this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(p,f),"default")}return x}nextFile(){var e=this.backlog;return e.length?assert(e.shift()):null}getDependee(e){var n=this.dependees;return n.has(e)?assert(n.get(e)).source.internalPath:null}finish(){if(this.backlog.length)throw new Error("backlog is not empty");this.backlog=[],this.seenlog.clear(),this.donelog.clear(),this.dependees.clear()}parseTypeName(e){for(var n=o.Node.createSimpleTypeName(e.readIdentifier(),e.range()),t=n;e.skip(i.Token.DOT);){if(!e.skip(i.Token.IDENTIFIER))return this.error(a.DiagnosticCode.Identifier_expected,e.range(e.pos)),null;{let n=o.Node.createSimpleTypeName(e.readIdentifier(),e.range());t.next=n,t=n}}return n}parseType(e,n=!0,t=!1){var r,s=e.next(),l=e.tokenPos;if(s==i.Token.OPENPAREN){let s=e.skip(i.Token.OPENPAREN),o=this.tryParseFunctionType(e);if(o){if(s){if(!e.skip(i.Token.CLOSEPAREN))return this.error(a.DiagnosticCode._0_expected,e.range(),")"),null;if(!e.skip(i.Token.BAR))return this.error(a.DiagnosticCode._0_expected,e.range(),"|"),null;e.skip(i.Token.NULL)||this.error(a.DiagnosticCode._0_expected,e.range(),"null"),o.isNullable=!0}return o}if(s||this.tryParseSignatureIsSignature)return this.error(a.DiagnosticCode.Unexpected_token,e.range()),null;if(!n)return this.error(a.DiagnosticCode.Unexpected_token,e.range()),null;{let n=this.parseType(e,!1,t);if(!n)return null;if(!e.skip(i.Token.CLOSEPAREN))return t||this.error(a.DiagnosticCode._0_expected,e.range(e.pos),")"),null;(r=n).range.start=l,r.range.end=e.pos}}else if(s==i.Token.VOID)r=o.Node.createNamedType(o.Node.createSimpleTypeName("void",e.range()),[],!1,e.range(l,e.pos));else if(s==i.Token.THIS)r=o.Node.createNamedType(o.Node.createSimpleTypeName("this",e.range()),[],!1,e.range(l,e.pos));else if(s==i.Token.TRUE||s==i.Token.FALSE)r=o.Node.createNamedType(o.Node.createSimpleTypeName("bool",e.range()),[],!1,e.range(l,e.pos));else if(s==i.Token.NULL)r=o.Node.createNamedType(o.Node.createSimpleTypeName("null",e.range()),[],!1,e.range(l,e.pos));else if(s==i.Token.STRINGLITERAL)e.readString(),r=o.Node.createNamedType(o.Node.createSimpleTypeName("string",e.range()),[],!1,e.range(l,e.pos));else{if(s!=i.Token.IDENTIFIER)return t||this.error(a.DiagnosticCode.Type_expected,e.range()),null;{let n=this.parseTypeName(e);if(!n)return null;let s=null;if(e.skip(i.Token.LESSTHAN)){do{let n=this.parseType(e,!0,t);if(!n)return null;s?s.push(n):s=[n]}while(e.skip(i.Token.COMMA));if(!e.skip(i.Token.GREATERTHAN))return t||this.error(a.DiagnosticCode._0_expected,e.range(e.pos),">"),null}s||(s=[]),r=o.Node.createNamedType(n,s,!1,e.range(l,e.pos))}}for(;e.skip(i.Token.BAR);){if(!e.skip(i.Token.NULL)){let n=e.pos,r=this.parseType(e,!1,!0);return t||this.error(a.DiagnosticCode._0_expected,r?r.range:e.range(n),"null"),null}r.isNullable=!0}for(;e.skip(i.Token.OPENBRACKET);){let n=e.tokenPos;if(!e.skip(i.Token.CLOSEBRACKET))return t||this.error(a.DiagnosticCode._0_expected,e.range(),"]"),null;let s=e.range(n,e.pos),u=!1;if(e.skip(i.Token.BAR)){if(!e.skip(i.Token.NULL))return t||this.error(a.DiagnosticCode._0_expected,e.range(),"null"),null;u=!0}if(r=o.Node.createNamedType(o.Node.createSimpleTypeName("Array",s),[r],u,e.range(l,e.pos)),u)break}return r}tryParseFunctionType(e){var n,t=e.mark(),r=e.tokenPos,s=null,l=null,u=!1,c=null,p=o.ParameterKind.DEFAULT;if(e.skip(i.Token.CLOSEPAREN))u=!0,e.discard(t),s=[];else{u=!1;do{let n=-1,r=o.ParameterKind.DEFAULT;if(e.skip(i.Token.DOT_DOT_DOT)&&(n=e.tokenPos,u=!0,e.discard(t),r=o.ParameterKind.REST),e.skip(i.Token.THIS)){if(n<0&&(n=e.tokenPos),!e.skip(i.Token.COLON))return e.reset(t),this.tryParseSignatureIsSignature=!1,null;{u=!0,e.discard(t);let n=this.parseType(e,!1);if(!n)return null;if(n.kind!=o.NodeKind.NAMEDTYPE)return this.error(a.DiagnosticCode.Identifier_expected,n.range),this.tryParseSignatureIsSignature=!0,null;l=n}}else{if(!e.skipIdentifier())return u?this.error(a.DiagnosticCode.Identifier_expected,e.range()):e.reset(t),this.tryParseSignatureIsSignature=u,null;{n<0&&(n=e.tokenPos);let l=o.Node.createIdentifierExpression(e.readIdentifier(),e.range(e.tokenPos,e.pos));if(e.skip(i.Token.QUESTION)&&(u=!0,e.discard(t),r==o.ParameterKind.REST?this.error(a.DiagnosticCode.A_rest_parameter_cannot_be_optional,e.range()):r=o.ParameterKind.OPTIONAL),e.skip(i.Token.COLON)){u=!0,e.discard(t);let i=this.parseType(e);if(!i)return this.tryParseSignatureIsSignature=u,null;let a=o.Node.createParameter(r,l,i,null,e.range(n,e.pos));s?s.push(a):s=[a]}else if(u||e.peek()==i.Token.COMMA&&(u=!0,e.discard(t)),u){let t=o.Node.createParameter(r,l,o.Node.createOmittedType(e.range(e.pos)),null,e.range(n,e.pos));s?s.push(t):s=[t],this.error(a.DiagnosticCode.Type_expected,t.type.range)}else s||(c=l,p=r)}}}while(e.skip(i.Token.COMMA));if(!e.skip(i.Token.CLOSEPAREN))return u?this.error(a.DiagnosticCode._0_expected,e.range(),")"):e.reset(t),this.tryParseSignatureIsSignature=u,null}if(!e.skip(i.Token.EQUALS_GREATERTHAN))return u?this.error(a.DiagnosticCode._0_expected,e.range(),"=>"):e.reset(t),this.tryParseSignatureIsSignature=u,null;if(!u&&(u=!0,e.discard(t),c)){let e=o.Node.createParameter(p,c,o.Node.createOmittedType(c.range.atEnd),null,c.range);s?s.push(e):s=[e],this.error(a.DiagnosticCode.Type_expected,e.type.range)}return(n=this.parseType(e))?(this.tryParseSignatureIsSignature=!0,s||(s=[]),o.Node.createFunctionType(s,n,l,!1,e.range(r,e.pos))):(this.tryParseSignatureIsSignature=u,null)}parseDecorator(e){var n=e.tokenPos;if(e.skipIdentifier()){let t,r=e.readIdentifier(),s=o.Node.createIdentifierExpression(r,e.range(n,e.pos));for(;e.skip(i.Token.DOT);){if(!e.skipIdentifier(i.IdentifierHandling.PREFER))return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;r=e.readIdentifier(),s=o.Node.createPropertyAccessExpression(s,o.Node.createIdentifierExpression(r,e.range()),e.range(n,e.pos))}if(!e.skip(i.Token.OPENPAREN))return o.Node.createDecorator(s,null,e.range(n,e.pos));if(t=this.parseArguments(e),t)return o.Node.createDecorator(s,t,e.range(n,e.pos))}else this.error(a.DiagnosticCode.Identifier_expected,e.range());return null}parseVariable(e,n,t,r,a=!1){var s=new Array;do{let r=this.parseVariableDeclaration(e,n,t,a);if(!r)return null;s.push(r)}while(e.skip(i.Token.COMMA));var l=o.Node.createVariableStatement(t,s,e.range(r,e.pos));return e.skip(i.Token.SEMICOLON),l}parseVariableDeclaration(e,n,t,s=!1){if(!e.skipIdentifier())return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;var l=o.Node.createIdentifierExpression(e.readIdentifier(),e.range());i.isIllegalVariableIdentifier(l.text)&&this.error(a.DiagnosticCode.Identifier_expected,l.range);var u=n;e.skip(i.Token.EXCLAMATION)&&(u|=r.CommonFlags.DEFINITELY_ASSIGNED);var c=null;e.skip(i.Token.COLON)&&(c=this.parseType(e,!0));var p=null;if(e.skip(i.Token.EQUALS)){if(u&r.CommonFlags.AMBIENT&&this.error(a.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,e.range()),!(p=this.parseExpression(e,2)))return null}else s||(u&r.CommonFlags.CONST?u&r.CommonFlags.AMBIENT||this.error(a.DiagnosticCode._const_declarations_must_be_initialized,l.range):c||this.error(a.DiagnosticCode.Type_expected,e.range(e.pos)));var f=i.Range.join(l.range,e.range());return null!==p&&0!=(u&r.CommonFlags.DEFINITELY_ASSIGNED)&&this.error(a.DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,f),o.Node.createVariableDeclaration(l,t,u,c,p,f)}parseEnum(e,n,t,s){if(e.next()!=i.Token.IDENTIFIER)return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;var l=o.Node.createIdentifierExpression(e.readIdentifier(),e.range());if(e.next()!=i.Token.OPENBRACE)return this.error(a.DiagnosticCode._0_expected,e.range(),"{"),null;for(var u=new Array;!e.skip(i.Token.CLOSEBRACE);){let n=this.parseEnumValue(e,r.CommonFlags.NONE);if(!n)return null;if(u.push(n),!e.skip(i.Token.COMMA)){if(e.skip(i.Token.CLOSEBRACE))break;return this.error(a.DiagnosticCode._0_expected,e.range(),"}"),null}}var c=o.Node.createEnumDeclaration(l,t,n,u,e.range(s,e.pos));return e.skip(i.Token.SEMICOLON),c}parseEnumValue(e,n){if(!e.skipIdentifier())return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;var t=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),r=null;return e.skip(i.Token.EQUALS)&&!(r=this.parseExpression(e,2))?null:o.Node.createEnumValueDeclaration(t,n,r,i.Range.join(t.range,e.range()))}parseReturn(e){var n=e.tokenPos,t=null;if(e.peek(!0)!=i.Token.SEMICOLON&&e.nextToken!=i.Token.CLOSEBRACE&&!e.nextTokenOnNewLine&&!(t=this.parseExpression(e)))return null;var r=o.Node.createReturnStatement(t,e.range(n,e.pos));return e.skip(i.Token.SEMICOLON),r}parseTypeParameters(e){for(var n=new Array,t=!1,r=e.tokenPos;!e.skip(i.Token.GREATERTHAN);){let r=this.parseTypeParameter(e);if(!r)return null;if(null!==r.defaultType?t=!0:t&&(this.error(a.DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,r.range),r.defaultType=null),n.push(r),!e.skip(i.Token.COMMA)){if(e.skip(i.Token.GREATERTHAN))break;return this.error(a.DiagnosticCode._0_expected,e.range(),">"),null}}return n.length||this.error(a.DiagnosticCode.Type_parameter_list_cannot_be_empty,e.range(r,e.pos)),n}parseTypeParameter(e){if(e.next()==i.Token.IDENTIFIER){let n=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),t=null;if(e.skip(i.Token.EXTENDS)){let n=this.parseType(e);if(!n)return null;if(n.kind!=o.NodeKind.NAMEDTYPE)return this.error(a.DiagnosticCode.Identifier_expected,n.range),null;t=n}let r=null;if(e.skip(i.Token.EQUALS)){let n=this.parseType(e);if(!n)return null;if(n.kind!=o.NodeKind.NAMEDTYPE)return this.error(a.DiagnosticCode.Identifier_expected,n.range),null;r=n}return o.Node.createTypeParameter(n,t,r,i.Range.join(n.range,e.range()))}return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null}parseParameters(e,n=!1){var t=new Array,r=null,s=!1,l=!1,u=null;if(this.parseParametersThis=null,e.skip(i.Token.THIS)){if(!e.skip(i.Token.COLON))return this.error(a.DiagnosticCode._0_expected,e.range(),":"),null;if(!(u=this.parseType(e)))return null;if(u.kind==o.NodeKind.NAMEDTYPE?this.parseParametersThis=u:this.error(a.DiagnosticCode.Identifier_expected,u.range),!e.skip(i.Token.COMMA))return e.skip(i.Token.CLOSEPAREN)?t:(this.error(a.DiagnosticCode._0_expected,e.range(),")"),null)}for(;!e.skip(i.Token.CLOSEPAREN);){let u=this.parseParameter(e,n);if(!u)return null;switch(null===r||l||(this.error(a.DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,r.name.range),l=!0),u.parameterKind){default:s&&this.error(a.DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,u.name.range);break;case o.ParameterKind.OPTIONAL:s=!0;break;case o.ParameterKind.REST:r=u}if(t.push(u),!e.skip(i.Token.COMMA)){if(e.skip(i.Token.CLOSEPAREN))break;return this.error(a.DiagnosticCode._0_expected,e.range(),")"),null}}return t}parseParameter(e,n=!1){var t=!1,s=!1,l=null,u=r.CommonFlags.NONE;if(n&&(e.skip(i.Token.PUBLIC)?(l=e.range(),u|=r.CommonFlags.PUBLIC):e.skip(i.Token.PROTECTED)?(l=e.range(),u|=r.CommonFlags.PROTECTED):e.skip(i.Token.PRIVATE)&&(l=e.range(),u|=r.CommonFlags.PRIVATE),e.peek()==i.Token.READONLY)){let n=e.mark();e.next(),e.peek()!=i.Token.COLON?(e.discard(n),l||(l=e.range()),u|=r.CommonFlags.READONLY):e.reset(n)}if(e.skip(i.Token.DOT_DOT_DOT)&&(u?this.error(a.DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,e.range()):l=e.range(),t=!0),e.skipIdentifier()){t||(l=e.range());let n=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),r=null;if((s=e.skip(i.Token.QUESTION))&&t&&this.error(a.DiagnosticCode.A_rest_parameter_cannot_be_optional,n.range),e.skip(i.Token.COLON)){if(r=this.parseType(e),!r)return null}else r=o.Node.createOmittedType(e.range(e.pos));let c=null;if(e.skip(i.Token.EQUALS)&&(t&&this.error(a.DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,n.range),s?this.error(a.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,n.range):s=!0,c=this.parseExpression(e,2),!c))return null;let p=o.Node.createParameter(t?o.ParameterKind.REST:s?o.ParameterKind.OPTIONAL:o.ParameterKind.DEFAULT,n,r,c,i.Range.join(assert(l),e.range()));return p.flags|=u,p}return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null}parseFunction(e,n,t,s){if(!e.skipIdentifier())return this.error(a.DiagnosticCode.Identifier_expected,e.range(e.pos)),null;var l=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),u=-1,c=null;if(e.skip(i.Token.LESSTHAN)){if(u=e.tokenPos,!(c=this.parseTypeParameters(e)))return null;n|=r.CommonFlags.GENERIC}if(!e.skip(i.Token.OPENPAREN))return this.error(a.DiagnosticCode._0_expected,e.range(e.pos),"("),null;u<0&&(u=e.tokenPos);var p=this.parseParameters(e);if(!p)return null;var f=this.parseParametersThis,d=0!=(n&r.CommonFlags.SET);d&&(1!=p.length&&this.error(a.DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,l.range),p.length>0&&null!==p[0].initializer&&this.error(a.DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,l.range)),n&r.CommonFlags.GET&&p.length&&this.error(a.DiagnosticCode.A_get_accessor_cannot_have_parameters,l.range);var h=null;if(e.skip(i.Token.COLON)&&!(h=this.parseType(e,!0,d)))return null;h||(h=o.Node.createOmittedType(e.range(e.pos)),d||this.error(a.DiagnosticCode.Type_expected,h.range));var g=o.Node.createFunctionType(p,h,f,!1,e.range(u,e.pos)),x=null;if(e.skip(i.Token.OPENBRACE)){if(n&r.CommonFlags.AMBIENT&&this.error(a.DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,e.range()),!(x=this.parseBlockStatement(e,!1)))return null}else n&r.CommonFlags.AMBIENT||this.error(a.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,e.range(e.pos));var m=o.Node.createFunctionDeclaration(l,t,n,c,g,x,0,e.range(s,e.pos));return e.skip(i.Token.SEMICOLON),m}parseFunctionExpression(e){var n,t=e.tokenPos,r=0;if(e.token==i.Token.FUNCTION){if(n=e.skipIdentifier()?o.Node.createIdentifierExpression(e.readIdentifier(),e.range()):o.Node.createEmptyIdentifierExpression(e.range(e.pos)),!e.skip(i.Token.OPENPAREN))return this.error(a.DiagnosticCode._0_expected,e.range(e.pos),"("),null}else r=1,assert(e.token==i.Token.OPENPAREN),n=o.Node.createEmptyIdentifierExpression(e.range(e.tokenPos));var s=e.pos,l=this.parseParameters(e);return l?this.parseFunctionExpressionCommon(e,n,l,this.parseParametersThis,r,t,s):null}parseFunctionExpressionCommon(e,n,t,s,l,u=-1,c=-1){u<0&&(u=n.range.start),c<0&&(c=u);var p=null;if(2!=l&&e.skip(i.Token.COLON)){if(!(p=this.parseType(e)))return null}else p=o.Node.createOmittedType(e.range(e.pos));if(l&&!e.skip(i.Token.EQUALS_GREATERTHAN))return this.error(a.DiagnosticCode._0_expected,e.range(e.pos),"=>"),null;var f=o.Node.createFunctionType(t,p,s,!1,e.range(c,e.pos)),d=null;if(l)if(e.skip(i.Token.OPENBRACE))d=this.parseBlockStatement(e,!1);else{let n=this.parseExpression(e,2);n&&(d=o.Node.createExpressionStatement(n))}else{if(!e.skip(i.Token.OPENBRACE))return this.error(a.DiagnosticCode._0_expected,e.range(e.pos),"{"),null;d=this.parseBlockStatement(e,!1)}if(!d)return null;var h=o.Node.createFunctionDeclaration(n,null,r.CommonFlags.NONE,null,f,d,l,e.range(u,e.pos));return o.Node.createFunctionExpression(h)}parseClassOrInterface(e,n,t,s){var l=e.token==i.Token.INTERFACE;if(!e.skipIdentifier())return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;var u=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),c=null;if(e.skip(i.Token.LESSTHAN)){if(!(c=this.parseTypeParameters(e)))return null;n|=r.CommonFlags.GENERIC}var p=null;if(e.skip(i.Token.EXTENDS)){let n=this.parseType(e);if(!n)return null;if(n.kind!=o.NodeKind.NAMEDTYPE)return this.error(a.DiagnosticCode.Identifier_expected,n.range),null;p=n}var f=null;if(e.skip(i.Token.IMPLEMENTS)){l&&this.error(a.DiagnosticCode.Interface_declaration_cannot_have_implements_clause,e.range());do{let n=this.parseType(e);if(!n)return null;if(n.kind!=o.NodeKind.NAMEDTYPE)return this.error(a.DiagnosticCode.Identifier_expected,n.range),null;l||(f||(f=[]),f.push(n))}while(e.skip(i.Token.COMMA))}if(!e.skip(i.Token.OPENBRACE))return this.error(a.DiagnosticCode._0_expected,e.range(),"{"),null;var d,h=new Array;if(l?(assert(!f),d=o.Node.createInterfaceDeclaration(u,t,n,c,p,null,h,e.range(s,e.pos))):d=o.Node.createClassDeclaration(u,t,n,c,p,f,h,e.range(s,e.pos)),!e.skip(i.Token.CLOSEBRACE))do{let n=this.parseClassMember(e,d);if(n)n.kind==o.NodeKind.INDEXSIGNATURE?d.indexSignature=n:(assert(n instanceof o.DeclarationStatement),h.push(n));else if(this.skipStatement(e),e.skip(i.Token.ENDOFFILE))return this.error(a.DiagnosticCode._0_expected,e.range(),"}"),null}while(!e.skip(i.Token.CLOSEBRACE));return d.range.end=e.pos,d}parseClassExpression(e){var n,t=e.tokenPos;if(n=e.skipIdentifier()?o.Node.createIdentifierExpression(e.readIdentifier(),e.range()):o.Node.createEmptyIdentifierExpression(e.range(e.pos)),!e.skip(i.Token.OPENBRACE))return this.error(a.DiagnosticCode._0_expected,e.range(e.pos),"{"),null;var s=new Array,l=o.Node.createClassDeclaration(n,null,r.CommonFlags.NONE,null,null,null,s,e.range(t,e.pos));if(!e.skip(i.Token.CLOSEBRACE))do{let n=this.parseClassMember(e,l);if(n)n.kind==o.NodeKind.INDEXSIGNATURE?l.indexSignature=n:(assert(l instanceof o.DeclarationStatement),s.push(n));else if(this.skipStatement(e),e.skip(i.Token.ENDOFFILE))return this.error(a.DiagnosticCode._0_expected,e.range(),"}"),null}while(!e.skip(i.Token.CLOSEBRACE));return l.range.end=e.pos,o.Node.createClassExpression(l)}parseClassMember(e,n){var t=n.kind==o.NodeKind.INTERFACEDECLARATION,s=0,l=null;if(e.skip(i.Token.AT)){s=e.tokenPos;do{let n=this.parseDecorator(e);if(!n)break;l||(l=new Array),l.push(n)}while(e.skip(i.Token.AT));t&&null!==l&&this.error(a.DiagnosticCode.Decorators_are_not_valid_here,i.Range.join(l[0].range,l[l.length-1].range))}var u=n.flags&r.CommonFlags.AMBIENT;t&&(u|=r.CommonFlags.VIRTUAL);var c=0,p=0;e.skip(i.Token.PUBLIC)?(t?this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(),"public"):(u|=r.CommonFlags.PUBLIC,c=e.tokenPos,p=e.pos),s||(s=e.tokenPos)):e.skip(i.Token.PRIVATE)?(t?this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(),"private"):(u|=r.CommonFlags.PRIVATE,c=e.tokenPos,p=e.pos),s||(s=e.tokenPos)):e.skip(i.Token.PROTECTED)&&(t?this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(),"protected"):(u|=r.CommonFlags.PROTECTED,c=e.tokenPos,p=e.pos),s||(s=e.tokenPos));var f=0,d=0,h=0,g=0;e.skip(i.Token.STATIC)?(t?this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(),"static"):(u|=r.CommonFlags.STATIC,f=e.tokenPos,d=e.pos),s||(s=e.tokenPos)):(u|=r.CommonFlags.INSTANCE,e.skip(i.Token.ABSTRACT)&&(t||!n.is(r.CommonFlags.ABSTRACT)?this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(),"abstract"):(u|=r.CommonFlags.ABSTRACT,h=e.tokenPos,g=e.pos),s||(s=e.tokenPos)),n.flags&r.CommonFlags.GENERIC&&(u|=r.CommonFlags.GENERIC_CONTEXT));var x=0,m=0;if(e.peek()==i.Token.READONLY){let n=e.mark();e.next(),e.peek()!=i.Token.COLON?(e.discard(n),u|=r.CommonFlags.READONLY,x=e.tokenPos,m=e.pos,s||(s=x)):e.reset(n)}var _=e.mark(),y=!1,E=!1,T=0,b=0,v=!1,A=0,F=0;t||(e.skip(i.Token.GET)?e.peek(!0,i.IdentifierHandling.PREFER)!=i.Token.IDENTIFIER||e.nextTokenOnNewLine?e.reset(_):(u|=r.CommonFlags.GET,E=!0,T=e.tokenPos,b=e.pos,s||(s=T),u&r.CommonFlags.READONLY&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(x,m),"readonly")):e.skip(i.Token.SET)?e.peek(!0,i.IdentifierHandling.PREFER)!=i.Token.IDENTIFIER||e.nextTokenOnNewLine?e.reset(_):(u|=r.CommonFlags.SET,v=!0,A=e.tokenPos,F=e.pos,s||(s=A),u&r.CommonFlags.READONLY&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(x,m),"readonly")):e.skip(i.Token.CONSTRUCTOR)&&(u|=r.CommonFlags.CONSTRUCTOR,y=!0,s||(s=e.tokenPos),u&r.CommonFlags.STATIC&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(f,d),"static"),u&r.CommonFlags.ABSTRACT&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(h,g),"abstract"),u&r.CommonFlags.READONLY&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(x,m),"readonly")));var C,I=E||v;if(y)C=o.Node.createConstructorExpression(e.range());else{if(!I&&e.skip(i.Token.OPENBRACKET)){s||(s=e.tokenPos),u&r.CommonFlags.PUBLIC?this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(c,p),"public"):(u&r.CommonFlags.PROTECTED||u&r.CommonFlags.PRIVATE)&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(c,p),"protected"),u&r.CommonFlags.STATIC&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(f,d),"static"),u&r.CommonFlags.ABSTRACT&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(h,g),"abstract");let n=this.parseIndexSignature(e,u,l);return n?(e.skip(i.Token.SEMICOLON),n):(u&r.CommonFlags.READONLY&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(x,m),"readonly"),null)}if(!e.skipIdentifier(i.IdentifierHandling.ALWAYS))return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;s||(s=e.tokenPos),C=o.Node.createIdentifierExpression(e.readIdentifier(),e.range())}var S=null;if(e.skip(i.Token.LESSTHAN)){let n=e.tokenPos;if(!(S=this.parseTypeParameters(e)))return null;y?this.error(a.DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,e.range(n,e.pos)):I?this.error(a.DiagnosticCode.An_accessor_cannot_have_type_parameters,e.range(n,e.pos)):u|=r.CommonFlags.GENERIC}if(e.skip(i.Token.OPENPAREN)){let c=e.tokenPos,p=this.parseParameters(e,y);if(!p)return null;let f=this.parseParametersThis;if(y)for(let e=0,t=p.length;e<t;++e){let t=p[e];if(t.isAny(r.CommonFlags.PUBLIC|r.CommonFlags.PROTECTED|r.CommonFlags.PRIVATE|r.CommonFlags.READONLY)){let i=o.Node.createFieldDeclaration(t.name,null,t.flags|r.CommonFlags.INSTANCE,t.type,null,t.range);i.parameterIndex=e,t.implicitFieldDeclaration=i,n.members.push(i)}}else E?p.length&&this.error(a.DiagnosticCode.A_get_accessor_cannot_have_parameters,C.range):v?(1!=p.length&&this.error(a.DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,C.range),p.length>0&&null!==p[0].initializer&&this.error(a.DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,C.range)):"constructor"==C.text&&this.error(a.DiagnosticCode._0_keyword_cannot_be_used_here,C.range,"constructor");let d=null;if(e.skip(i.Token.COLON)){if(C.kind==o.NodeKind.CONSTRUCTOR?this.error(a.DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,e.range()):v&&this.error(a.DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,e.range()),d=this.parseType(e,v||C.kind==o.NodeKind.CONSTRUCTOR),!d)return null}else d=o.Node.createOmittedType(e.range(e.pos)),v||C.kind==o.NodeKind.CONSTRUCTOR||this.error(a.DiagnosticCode.Type_expected,d.range);let h=o.Node.createFunctionType(p,d,f,!1,e.range(c,e.pos)),g=null;if(e.skip(i.Token.OPENBRACE)){if(u&r.CommonFlags.AMBIENT?this.error(a.DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,e.range()):u&r.CommonFlags.ABSTRACT?this.error(a.DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,e.range(),C.text):t&&this.error(a.DiagnosticCode._0_expected,e.range(),";"),g=this.parseBlockStatement(e,!1),!g)return null}else t||u&(r.CommonFlags.AMBIENT|r.CommonFlags.ABSTRACT)||this.error(a.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,e.range());let x=o.Node.createMethodDeclaration(C,l,u,S,h,g,e.range(s,e.pos));return t&&e.skip(i.Token.COMMA)||e.skip(i.Token.SEMICOLON),x}if(y)this.error(a.DiagnosticCode.Constructor_implementation_is_missing,C.range);else{if(!I){u&r.CommonFlags.ABSTRACT&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(h,g),"abstract"),u&r.CommonFlags.GET&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(T,b),"get"),u&r.CommonFlags.SET&&this.error(a.DiagnosticCode._0_modifier_cannot_be_used_here,e.range(A,F),"set");let n=null;if(e.skip(i.Token.QUESTION)&&this.error(a.DiagnosticCode.Optional_properties_are_not_supported,e.range(s,e.pos)),e.skip(i.Token.EXCLAMATION)&&(u|=r.CommonFlags.DEFINITELY_ASSIGNED),e.skip(i.Token.COLON)){if(n=this.parseType(e),!n)return null}else this.error(a.DiagnosticCode.Type_expected,e.range());let c=null;if(e.skip(i.Token.EQUALS)&&(c=this.parseExpression(e),!c))return null;let p=e.range(s,e.pos);0==(u&r.CommonFlags.DEFINITELY_ASSIGNED)||!t&&null===c&&0==(u&r.CommonFlags.STATIC)||this.error(a.DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,p);let f=o.Node.createFieldDeclaration(C,l,u,n,c,p);return t&&e.skip(i.Token.COMMA)||e.skip(i.Token.SEMICOLON),f}this.error(a.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,C.range)}return null}parseIndexSignature(e,n,t){null!==t&&t.length>0&&this.error(a.DiagnosticCode.Decorators_are_not_valid_here,i.Range.join(t[0].range,t[t.length-1].range));var r=e.tokenPos;if(e.skipIdentifier())if("key"==e.readIdentifier())if(e.skip(i.Token.COLON)){let t=this.parseType(e);if(!t)return null;if(t.kind!=o.NodeKind.NAMEDTYPE)return this.error(a.DiagnosticCode.Type_expected,e.range()),null;if(e.skip(i.Token.CLOSEBRACKET)){if(e.skip(i.Token.COLON)){let i=this.parseType(e);return i?i.kind!=o.NodeKind.NAMEDTYPE?(this.error(a.DiagnosticCode.Identifier_expected,i.range),null):o.Node.createIndexSignature(t,i,n,e.range(r,e.pos)):null}this.error(a.DiagnosticCode._0_expected,e.range(),":")}else this.error(a.DiagnosticCode._0_expected,e.range(),"]")}else this.error(a.DiagnosticCode._0_expected,e.range(),":");else this.error(a.DiagnosticCode._0_expected,e.range(),"key");else this.error(a.DiagnosticCode.Identifier_expected,e.range());return null}parseNamespace(e,n,t,r){if(e.skipIdentifier()){let s=o.Node.createIdentifierExpression(e.readIdentifier(),e.range());if(e.skip(i.Token.OPENBRACE)){let l=new Array,u=o.Node.createNamespaceDeclaration(s,t,n,l,e.range(r,e.pos));for(;!e.skip(i.Token.CLOSEBRACE);){let n=this.parseTopLevelStatement(e,u);if(n)l.push(n);else if(this.skipStatement(e),e.skip(i.Token.ENDOFFILE))return this.error(a.DiagnosticCode._0_expected,e.range(),"}"),null}return u.range.end=e.pos,e.skip(i.Token.SEMICOLON),u}this.error(a.DiagnosticCode._0_expected,e.range(),"{")}else this.error(a.DiagnosticCode.Identifier_expected,e.range());return null}parseExport(e,n,t){var r=null,s=assert(this.currentSource);if(e.skip(i.Token.OPENBRACE)){let u=new Array;for(;!e.skip(i.Token.CLOSEBRACE);){let n=this.parseExportMember(e);if(!n)return null;if(u.push(n),!e.skip(i.Token.COMMA)){if(e.skip(i.Token.CLOSEBRACE))break;return this.error(a.DiagnosticCode._0_expected,e.range(),"}"),null}}if(e.skip(i.Token.FROM)){if(!e.skip(i.Token.STRINGLITERAL))return this.error(a.DiagnosticCode.String_literal_expected,e.range()),null;r=o.Node.createStringLiteralExpression(e.readString(),e.range())}let c=o.Node.createExportStatement(u,r,t,e.range(n,e.pos));if(null!==r){let e=assert(c.internalPath);this.seenlog.has(e)||(this.dependees.set(e,new l(s,r)),this.backlog.push(e),this.seenlog.add(e))}return e.skip(i.Token.SEMICOLON),c}if(e.skip(i.Token.ASTERISK))if(e.skip(i.Token.FROM)){if(e.skip(i.Token.STRINGLITERAL)){r=o.Node.createStringLiteralExpression(e.readString(),e.range());let a=o.Node.createExportStatement(null,r,t,e.range(n,e.pos)),u=assert(a.internalPath),c=e.source,p=c.exportPaths;return p?p.includes(u)||p.push(u):c.exportPaths=[u],this.seenlog.has(u)||(this.dependees.set(u,new l(s,r)),this.backlog.push(u)),e.skip(i.Token.SEMICOLON),a}this.error(a.DiagnosticCode.String_literal_expected,e.range())}else this.error(a.DiagnosticCode._0_expected,e.range(),"from");else this.error(a.DiagnosticCode._0_expected,e.range(),"{");return null}parseExportMember(e){if(e.skipIdentifier(i.IdentifierHandling.ALWAYS)){let n=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),t=null;if(e.skip(i.Token.AS)){if(!e.skipIdentifier(i.IdentifierHandling.ALWAYS))return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;t=o.Node.createIdentifierExpression(e.readIdentifier(),e.range())}return t?o.Node.createExportMember(n,t,i.Range.join(n.range,t.range)):o.Node.createExportMember(n,null,n.range)}return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null}parseExportDefaultAlias(e,n,t,r){var a=e.readIdentifier(),s=e.range(),l=o.Node.createExportStatement([o.Node.createExportMember(o.Node.createIdentifierExpression(a,s),o.Node.createIdentifierExpression("default",e.range(t,r)),s)],null,!1,e.range(n,e.pos));return e.skip(i.Token.SEMICOLON),l}parseImport(e){var n=e.tokenPos,t=null,r=null,s=!1;if(e.skip(i.Token.OPENBRACE))for(t=new Array;!e.skip(i.Token.CLOSEBRACE);){let n=this.parseImportDeclaration(e);if(!n)return null;if(t.push(n),!e.skip(i.Token.COMMA)){if(e.skip(i.Token.CLOSEBRACE))break;return this.error(a.DiagnosticCode._0_expected,e.range(),"}"),null}}else if(e.skip(i.Token.ASTERISK)){if(!e.skip(i.Token.AS))return this.error(a.DiagnosticCode._0_expected,e.range(),"as"),null;if(!e.skipIdentifier())return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;r=o.Node.createIdentifierExpression(e.readIdentifier(),e.range())}else if(e.skip(i.Token.IDENTIFIER,i.IdentifierHandling.PREFER)){let n=e.readIdentifier(),r=e.range();if(t=[o.Node.createImportDeclaration(o.Node.createIdentifierExpression("default",r),o.Node.createIdentifierExpression(n,r),r)],e.skip(i.Token.COMMA))return this.error(a.DiagnosticCode.Not_implemented_0,e.range(),"Mixed default and named imports"),null}else s=!0;if(s||e.skip(i.Token.FROM)){if(e.skip(i.Token.STRINGLITERAL)){let a,s=o.Node.createStringLiteralExpression(e.readString(),e.range());r?(assert(!t),a=o.Node.createWildcardImportStatement(r,s,e.range(n,e.pos))):a=o.Node.createImportStatement(t,s,e.range(n,e.pos));let u=a.internalPath;return this.seenlog.has(u)||(this.dependees.set(u,new l(assert(this.currentSource),s)),this.backlog.push(u)),e.skip(i.Token.SEMICOLON),a}this.error(a.DiagnosticCode.String_literal_expected,e.range())}else this.error(a.DiagnosticCode._0_expected,e.range(),"from");return null}parseImportDeclaration(e){if(e.skipIdentifier(i.IdentifierHandling.ALWAYS)){let n=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),t=null;if(e.skip(i.Token.AS)){if(!e.skipIdentifier())return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;t=o.Node.createIdentifierExpression(e.readIdentifier(),e.range())}return t?o.Node.createImportDeclaration(n,t,i.Range.join(n.range,t.range)):o.Node.createImportDeclaration(n,null,n.range)}return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null}parseExportImport(e,n){if(e.skipIdentifier()){let t=o.Node.createIdentifierExpression(e.readIdentifier(),e.range());if(e.skip(i.Token.EQUALS)){if(e.skipIdentifier()){let r=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),a=o.Node.createExportImportStatement(r,t,e.range(n,e.pos));return e.skip(i.Token.SEMICOLON),a}this.error(a.DiagnosticCode.Identifier_expected,e.range())}else this.error(a.DiagnosticCode._0_expected,e.range(),"=")}else this.error(a.DiagnosticCode.Identifier_expected,e.range());return null}parseStatement(e,n=!1){var t=e.mark(),s=null;switch(e.next()){case i.Token.BREAK:s=this.parseBreak(e);break;case i.Token.CONST:s=this.parseVariable(e,r.CommonFlags.CONST,null,e.tokenPos);break;case i.Token.CONTINUE:s=this.parseContinue(e);break;case i.Token.DO:s=this.parseDoStatement(e);break;case i.Token.FOR:s=this.parseForStatement(e);break;case i.Token.IF:s=this.parseIfStatement(e);break;case i.Token.LET:s=this.parseVariable(e,r.CommonFlags.LET,null,e.tokenPos);break;case i.Token.VAR:s=this.parseVariable(e,r.CommonFlags.NONE,null,e.tokenPos);break;case i.Token.OPENBRACE:s=this.parseBlockStatement(e,n);break;case i.Token.RETURN:n&&this.error(a.DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,e.range()),s=this.parseReturn(e);break;case i.Token.SEMICOLON:return o.Node.createEmptyStatement(e.range(e.tokenPos));case i.Token.SWITCH:s=this.parseSwitchStatement(e);break;case i.Token.THROW:s=this.parseThrowStatement(e);break;case i.Token.TRY:s=this.parseTryStatement(e);break;case i.Token.VOID:s=this.parseVoidStatement(e);break;case i.Token.WHILE:s=this.parseWhileStatement(e);break;case i.Token.TYPE:if(e.peek(!1,i.IdentifierHandling.PREFER)==i.Token.IDENTIFIER){s=this.parseTypeDeclaration(e,r.CommonFlags.NONE,null,e.tokenPos);break}default:e.reset(t),s=this.parseExpressionStatement(e)}return s?e.discard(t):(e.reset(t),this.skipStatement(e)),s}parseBlockStatement(e,n){for(var t=e.tokenPos,r=new Array;!e.skip(i.Token.CLOSEBRACE);){let t=e.mark(),a=this.parseStatement(e,n);if(a)e.discard(t),r.push(a);else{if(e.token==i.Token.ENDOFFILE)return null;e.reset(t),this.skipStatement(e)}}var a=o.Node.createBlockStatement(r,e.range(t,e.pos));return e.skip(i.Token.SEMICOLON),a}parseBreak(e){var n=null;e.peek(!0)!=i.Token.IDENTIFIER||e.nextTokenOnNewLine||(e.next(i.IdentifierHandling.PREFER),n=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()));var t=o.Node.createBreakStatement(n,e.range());return e.skip(i.Token.SEMICOLON),t}parseContinue(e){var n=null;e.peek(!0)!=i.Token.IDENTIFIER||e.nextTokenOnNewLine||(e.next(i.IdentifierHandling.PREFER),n=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()));var t=o.Node.createContinueStatement(n,e.range());return e.skip(i.Token.SEMICOLON),t}parseDoStatement(e){var n=e.tokenPos,t=this.parseStatement(e);if(!t)return null;if(e.skip(i.Token.WHILE))if(e.skip(i.Token.OPENPAREN)){let r=this.parseExpression(e);if(!r)return null;if(e.skip(i.Token.CLOSEPAREN)){let a=o.Node.createDoStatement(t,r,e.range(n,e.pos));return e.skip(i.Token.SEMICOLON),a}this.error(a.DiagnosticCode._0_expected,e.range(),")")}else this.error(a.DiagnosticCode._0_expected,e.range(),"(");else this.error(a.DiagnosticCode._0_expected,e.range(),"while");return null}parseExpressionStatement(e){var n=this.parseExpression(e);if(!n)return null;var t=o.Node.createExpressionStatement(n);return e.skip(i.Token.SEMICOLON),t}parseForStatement(e){var n=e.tokenPos;if(e.skip(i.Token.OPENPAREN)){let t=null;if(e.skip(i.Token.CONST))t=this.parseVariable(e,r.CommonFlags.CONST,null,e.tokenPos,!0);else if(e.skip(i.Token.LET))t=this.parseVariable(e,r.CommonFlags.LET,null,e.tokenPos,!0);else if(e.skip(i.Token.VAR))t=this.parseVariable(e,r.CommonFlags.NONE,null,e.tokenPos,!0);else if(!e.skip(i.Token.SEMICOLON)&&(t=this.parseExpressionStatement(e),!t))return null;if(t){if(e.skip(i.Token.OF)){if(t.kind==o.NodeKind.EXPRESSION)return t.expression.kind!=o.NodeKind.IDENTIFIER?(this.error(a.DiagnosticCode.Identifier_expected,t.range),null):this.parseForOfStatement(e,n,t);if(t.kind==o.NodeKind.VARIABLE){let r=t.declarations;for(let e=0,n=r.length;e<n;++e){let n=r[e].initializer;n&&this.error(a.DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,n.range)}return this.parseForOfStatement(e,n,t)}return this.error(a.DiagnosticCode.Identifier_expected,t.range),null}if(t.kind==o.NodeKind.VARIABLE){let e=t.declarations;for(let n=0,t=e.length;n<t;++n){let t=e[n];t.initializer||(t.flags&r.CommonFlags.CONST?this.error(a.DiagnosticCode._const_declarations_must_be_initialized,t.name.range):t.type||this.error(a.DiagnosticCode.Type_expected,t.name.range.atEnd))}}}if(e.token==i.Token.SEMICOLON){let r=null;if(!e.skip(i.Token.SEMICOLON)&&(r=this.parseExpressionStatement(e),!r))return null;if(e.token==i.Token.SEMICOLON){let s=null;if(!e.skip(i.Token.CLOSEPAREN)){if(s=this.parseExpression(e),!s)return null;if(!e.skip(i.Token.CLOSEPAREN))return this.error(a.DiagnosticCode._0_expected,e.range(),")"),null}let l=this.parseStatement(e);return l?o.Node.createForStatement(t,r?r.expression:null,s,l,e.range(n,e.pos)):null}this.error(a.DiagnosticCode._0_expected,e.range(),";")}else this.error(a.DiagnosticCode._0_expected,e.range(),";")}else this.error(a.DiagnosticCode._0_expected,e.range(),"(");return null}parseForOfStatement(e,n,t){var r=this.parseExpression(e);if(!r)return null;if(!e.skip(i.Token.CLOSEPAREN))return this.error(a.DiagnosticCode._0_expected,e.range(),")"),null;var s=this.parseStatement(e);return s?o.Node.createForOfStatement(t,r,s,e.range(n,e.pos)):null}parseIfStatement(e){var n=e.tokenPos;if(e.skip(i.Token.OPENPAREN)){let t=this.parseExpression(e);if(!t)return null;if(e.skip(i.Token.CLOSEPAREN)){let r=this.parseStatement(e);if(!r)return null;let a=null;return e.skip(i.Token.ELSE)&&(a=this.parseStatement(e),!a)?null:o.Node.createIfStatement(t,r,a,e.range(n,e.pos))}this.error(a.DiagnosticCode._0_expected,e.range(),")")}else this.error(a.DiagnosticCode._0_expected,e.range(),"(");return null}parseSwitchStatement(e){var n=e.tokenPos;if(e.skip(i.Token.OPENPAREN)){let t=this.parseExpression(e);if(!t)return null;if(e.skip(i.Token.CLOSEPAREN)){if(e.skip(i.Token.OPENBRACE)){let r=new Array;for(;!e.skip(i.Token.CLOSEBRACE);){let n=this.parseSwitchCase(e);if(!n)return null;r.push(n)}let a=o.Node.createSwitchStatement(t,r,e.range(n,e.pos));return e.skip(i.Token.SEMICOLON),a}this.error(a.DiagnosticCode._0_expected,e.range(),"{")}else this.error(a.DiagnosticCode._0_expected,e.range(),")")}else this.error(a.DiagnosticCode._0_expected,e.range(),"(");return null}parseSwitchCase(e){var n,t,r=e.tokenPos;if(e.skip(i.Token.CASE)){let s=this.parseExpression(e);if(!s)return null;if(e.skip(i.Token.COLON)){for(n=new Array;e.peek()!=i.Token.CASE&&e.nextToken!=i.Token.DEFAULT&&e.nextToken!=i.Token.CLOSEBRACE;){if(!(t=this.parseStatement(e)))return null;n.push(t)}return o.Node.createSwitchCase(s,n,e.range(r,e.pos))}this.error(a.DiagnosticCode._0_expected,e.range(),":")}else if(e.skip(i.Token.DEFAULT)){if(e.skip(i.Token.COLON)){for(n=new Array;e.peek()!=i.Token.CASE&&e.nextToken!=i.Token.DEFAULT&&e.nextToken!=i.Token.CLOSEBRACE;){if(!(t=this.parseStatement(e)))return null;n.push(t)}return o.Node.createSwitchCase(null,n,e.range(r,e.pos))}this.error(a.DiagnosticCode._0_expected,e.range(),":")}else this.error(a.DiagnosticCode._case_or_default_expected,e.range());return null}parseThrowStatement(e){var n=e.tokenPos,t=this.parseExpression(e);if(!t)return null;var r=o.Node.createThrowStatement(t,e.range(n,e.pos));return e.skip(i.Token.SEMICOLON),r}parseTryStatement(e){var n,t=e.tokenPos;if(e.skip(i.Token.OPENBRACE)){let r=new Array;for(;!e.skip(i.Token.CLOSEBRACE);){if(!(n=this.parseStatement(e)))return null;r.push(n)}let s=null,l=null,u=null;if(e.skip(i.Token.CATCH)){if(!e.skip(i.Token.OPENPAREN))return this.error(a.DiagnosticCode._0_expected,e.range(),"("),null;if(!e.skipIdentifier())return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;if(s=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),!e.skip(i.Token.CLOSEPAREN))return this.error(a.DiagnosticCode._0_expected,e.range(),")"),null;if(!e.skip(i.Token.OPENBRACE))return this.error(a.DiagnosticCode._0_expected,e.range(),"{"),null;for(l=[];!e.skip(i.Token.CLOSEBRACE);){if(!(n=this.parseStatement(e)))return null;l.push(n)}}if(e.skip(i.Token.FINALLY)){if(!e.skip(i.Token.OPENBRACE))return this.error(a.DiagnosticCode._0_expected,e.range(),"{"),null;for(u=[];!e.skip(i.Token.CLOSEBRACE);){if(!(n=this.parseStatement(e)))return null;u.push(n)}}if(!l&&!u)return this.error(a.DiagnosticCode._0_expected,e.range(),"catch"),null;let c=o.Node.createTryStatement(r,s,l,u,e.range(t,e.pos));return e.skip(i.Token.SEMICOLON),c}return this.error(a.DiagnosticCode._0_expected,e.range(),"{"),null}parseTypeDeclaration(e,n,t,s){if(e.skipIdentifier()){let l=o.Node.createIdentifierExpression(e.readIdentifier(),e.range()),u=null;if(e.skip(i.Token.LESSTHAN)){if(u=this.parseTypeParameters(e),!u)return null;n|=r.CommonFlags.GENERIC}if(e.skip(i.Token.EQUALS)){let r=this.parseType(e);if(!r)return null;let a=o.Node.createTypeDeclaration(l,t,n,u,r,e.range(s,e.pos));return e.skip(i.Token.SEMICOLON),a}this.error(a.DiagnosticCode._0_expected,e.range(),"=")}else this.error(a.DiagnosticCode.Identifier_expected,e.range());return null}parseVoidStatement(e){var n=e.tokenPos,t=this.parseExpression(e,21);if(!t)return null;var r=o.Node.createVoidStatement(t,e.range(n,e.pos));return e.skip(i.Token.SEMICOLON),r}parseWhileStatement(e){var n=e.tokenPos;if(e.skip(i.Token.OPENPAREN)){let t=this.parseExpression(e);if(!t)return null;if(e.skip(i.Token.CLOSEPAREN)){let r=this.parseStatement(e);if(!r)return null;let a=o.Node.createWhileStatement(t,r,e.range(n,e.pos));return e.skip(i.Token.SEMICOLON),a}this.error(a.DiagnosticCode._0_expected,e.range(),")")}else this.error(a.DiagnosticCode._0_expected,e.range(),"(");return null}parseExpressionStart(e){var n=e.next(i.IdentifierHandling.PREFER),t=e.tokenPos;switch(n){case i.Token.DOT_DOT_DOT:case i.Token.YIELD:case i.Token.EXCLAMATION:case i.Token.TILDE:case i.Token.PLUS:case i.Token.MINUS:case i.Token.TYPEOF:case i.Token.VOID:case i.Token.DELETE:{let r=this.parseExpression(e,17);return r?o.Node.createUnaryPrefixExpression(n,r,e.range(t,e.pos)):null}case i.Token.PLUS_PLUS:case i.Token.MINUS_MINUS:{let r=this.parseExpression(e,17);if(!r)return null;switch(r.kind){case o.NodeKind.IDENTIFIER:case o.NodeKind.ELEMENTACCESS:case o.NodeKind.PROPERTYACCESS:break;default:this.error(a.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,r.range)}return o.Node.createUnaryPrefixExpression(n,r,e.range(t,e.pos))}case i.Token.NEW:{if(!e.skipIdentifier())return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;let n=this.parseTypeName(e);if(!n)return null;let r=null,s=null;if(e.skip(i.Token.OPENPAREN)||null!==(r=this.tryParseTypeArgumentsBeforeArguments(e))){if(s=this.parseArguments(e),!s)return null}else s=[];return o.Node.createNewExpression(n,r,s,e.range(t,e.pos))}case i.Token.NULL:return o.Node.createNullExpression(e.range());case i.Token.TRUE:return o.Node.createTrueExpression(e.range());case i.Token.FALSE:return o.Node.createFalseExpression(e.range());case i.Token.THIS:return o.Node.createThisExpression(e.range());case i.Token.CONSTRUCTOR:return o.Node.createConstructorExpression(e.range());case i.Token.OPENPAREN:{if(e.skip(i.Token.CLOSEPAREN))return this.parseFunctionExpressionCommon(e,o.Node.createEmptyIdentifierExpression(e.range(t)),[],null,1);let n=e.mark(),r=!0;do{switch(e.next(i.IdentifierHandling.PREFER)){case i.Token.DOT_DOT_DOT:return e.reset(n),this.parseFunctionExpression(e);case i.Token.IDENTIFIER:switch(e.readIdentifier(),e.next()){case i.Token.CLOSEPAREN:if(!e.skip(i.Token.COLON)&&!e.skip(i.Token.EQUALS_GREATERTHAN)){r=!1;break}case i.Token.COLON:return e.reset(n),this.parseFunctionExpression(e);case i.Token.QUESTION:if(e.skip(i.Token.COLON)||e.skip(i.Token.COMMA)||e.skip(i.Token.CLOSEPAREN))return e.reset(n),this.parseFunctionExpression(e);r=!1;break;case i.Token.COMMA:break;default:r=!1}break;default:r=!1}}while(r);e.reset(n);let s=this.parseExpression(e);return s?e.skip(i.Token.CLOSEPAREN)?(s=o.Node.createParenthesizedExpression(s,e.range(t,e.pos)),this.maybeParseCallExpression(e,s)):(this.error(a.DiagnosticCode._0_expected,e.range(),")"),null):null}case i.Token.OPENBRACKET:{let n=new Array;for(;!e.skip(i.Token.CLOSEBRACKET);){let t;if(e.peek()==i.Token.COMMA)t=o.Node.createOmittedExpression(e.range(e.pos));else if(t=this.parseExpression(e,2),!t)return null;if(n.push(t),!e.skip(i.Token.COMMA)){if(e.skip(i.Token.CLOSEBRACKET))break;return this.error(a.DiagnosticCode._0_expected,e.range(),"]"),null}}return o.Node.createArrayLiteralExpression(n,e.range(t,e.pos))}case i.Token.OPENBRACE:{let n,t=e.tokenPos,r=new Array,s=new Array;for(;!e.skip(i.Token.CLOSEBRACE);){if(e.skipIdentifier())n=o.Node.createIdentifierExpression(e.readIdentifier(),e.range());else{if(!e.skip(i.Token.STRINGLITERAL))return this.error(a.DiagnosticCode.Identifier_expected,e.range()),null;n=o.Node.createIdentifierExpression(e.readString(),e.range()),n.isQuoted=!0}if(r.push(n),e.skip(i.Token.COLON)){let n=this.parseExpression(e,2);if(!n)return null;s.push(n)}else{if(n.isQuoted)return this.error(a.DiagnosticCode._0_expected,e.range(),":"),null;s.push(n)}if(!e.skip(i.Token.COMMA)){if(e.skip(i.Token.CLOSEBRACE))break;return this.error(a.DiagnosticCode._0_expected,e.range(),"}"),null}}return o.Node.createObjectLiteralExpression(r,s,e.range(t,e.pos))}case i.Token.LESSTHAN:{let n=this.parseType(e);if(!n)return null;if(!e.skip(i.Token.GREATERTHAN))return this.error(a.DiagnosticCode._0_expected,e.range(),">"),null;let r=this.parseExpression(e,19);return r?o.Node.createAssertionExpression(o.AssertionKind.PREFIX,r,n,e.range(t,e.pos)):null}case i.Token.IDENTIFIER:{let n=e.readIdentifier();if("null"==n)return o.Node.createNullExpression(e.range());let r=o.Node.createIdentifierExpression(n,e.range(t,e.pos));return e.peek(!0)!=i.Token.EQUALS_GREATERTHAN||e.nextTokenOnNewLine?this.maybeParseCallExpression(e,r,!0):this.parseFunctionExpressionCommon(e,o.Node.createEmptyIdentifierExpression(e.range(t)),[o.Node.createParameter(o.ParameterKind.DEFAULT,r,o.Node.createOmittedType(r.range.atEnd),null,r.range)],null,2,t)}case i.Token.SUPER:{e.peek()!=i.Token.DOT&&e.nextToken!=i.Token.OPENPAREN&&this.error(a.DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,e.range());let n=o.Node.createSuperExpression(e.range(t,e.pos));return this.maybeParseCallExpression(e,n)}case i.Token.STRINGLITERAL:return o.Node.createStringLiteralExpression(e.readString(),e.range(t,e.pos));case i.Token.INTEGERLITERAL:{let n=e.readInteger();return e.checkForIdentifierStartAfterNumericLiteral(),o.Node.createIntegerLiteralExpression(n,e.range(t,e.pos))}case i.Token.FLOATLITERAL:{let n=e.readFloat();return e.checkForIdentifierStartAfterNumericLiteral(),o.Node.createFloatLiteralExpression(n,e.range(t,e.pos))}case i.Token.SLASH:{let n=e.readRegexpPattern();return e.skip(i.Token.SLASH)?o.Node.createRegexpLiteralExpression(n,e.readRegexpFlags(),e.range(t,e.pos)):(this.error(a.DiagnosticCode._0_expected,e.range(),"/"),null)}case i.Token.FUNCTION:{let n=this.parseFunctionExpression(e);return n?this.maybeParseCallExpression(e,n):null}case i.Token.CLASS:return this.parseClassExpression(e);default:return n==i.Token.ENDOFFILE?this.error(a.DiagnosticCode.Unexpected_end_of_text,e.range(t)):this.error(a.DiagnosticCode.Expression_expected,e.range()),null}}tryParseTypeArgumentsBeforeArguments(e){var n=e.mark();if(!e.skip(i.Token.LESSTHAN))return null;var t=e.tokenPos,r=null;do{if(e.peek()===i.Token.GREATERTHAN)break;let t=this.parseType(e,!0,!0);if(!t)return e.reset(n),null;r?r.push(t):r=[t]}while(e.skip(i.Token.COMMA));if(e.skip(i.Token.GREATERTHAN)){let n=e.pos;if(e.skip(i.Token.OPENPAREN))return r||this.error(a.DiagnosticCode.Type_argument_list_cannot_be_empty,e.range(t,n)),r}return e.reset(n),null}parseArguments(e){for(var n=new Array;!e.skip(i.Token.CLOSEPAREN);){let t=this.parseExpression(e,2);if(!t)return null;if(n.push(t),!e.skip(i.Token.COMMA)){if(e.skip(i.Token.CLOSEPAREN))break;return this.error(a.DiagnosticCode._0_expected,e.range(),")"),null}}return n}parseExpression(e,n=1){assert(0!=n);var t=this.parseExpressionStart(e);if(!t)return null;for(var r,s=t.range.start;(r=c(e.peek()))>=n;){let l=e.next();switch(l){case i.Token.AS:if(e.skip(i.Token.CONST))t=o.Node.createAssertionExpression(o.AssertionKind.CONST,t,null,e.range(s,e.pos));else{let n=this.parseType(e);if(!n)return null;t=o.Node.createAssertionExpression(o.AssertionKind.AS,t,n,e.range(s,e.pos))}break;case i.Token.EXCLAMATION:t=o.Node.createAssertionExpression(o.AssertionKind.NONNULL,t,null,e.range(s,e.pos)),t=this.maybeParseCallExpression(e,t);break;case i.Token.INSTANCEOF:{let n=this.parseType(e);if(!n)return null;t=o.Node.createInstanceOfExpression(t,n,e.range(s,e.pos));break}case i.Token.OPENBRACKET:{let n=this.parseExpression(e);if(!n)return null;if(!e.skip(i.Token.CLOSEBRACKET))return this.error(a.DiagnosticCode._0_expected,e.range(),"]"),null;t=o.Node.createElementAccessExpression(t,n,e.range(s,e.pos)),t=this.maybeParseCallExpression(e,t);break}case i.Token.PLUS_PLUS:case i.Token.MINUS_MINUS:t.kind!=o.NodeKind.IDENTIFIER&&t.kind!=o.NodeKind.ELEMENTACCESS&&t.kind!=o.NodeKind.PROPERTYACCESS&&this.error(a.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,t.range),t=o.Node.createUnaryPostfixExpression(l,t,e.range(s,e.pos));break;case i.Token.QUESTION:{let r=this.parseExpression(e);if(!r)return null;if(!e.skip(i.Token.COLON))return this.error(a.DiagnosticCode._0_expected,e.range(),":"),null;let l=this.parseExpression(e,n>1?2:1);if(!l)return null;t=o.Node.createTernaryExpression(t,r,l,e.range(s,e.pos));break}case i.Token.COMMA:{let n=[t];do{if(!(t=this.parseExpression(e,2)))return null;n.push(t)}while(e.skip(i.Token.COMMA));t=o.Node.createCommaExpression(n,e.range(s,e.pos));break}case i.Token.DOT:if(e.skipIdentifier(i.IdentifierHandling.ALWAYS)){let n=o.Node.createIdentifierExpression(e.readIdentifier(),e.range());t=o.Node.createPropertyAccessExpression(t,n,e.range(s,e.pos))}else{let n=this.parseExpression(e,r+1);if(!n)return null;if(n.kind!=o.NodeKind.CALL)return this.error(a.DiagnosticCode.Identifier_expected,n.range),null;if(!(t=this.joinPropertyCall(e,s,t,n)))return null}t=this.maybeParseCallExpression(e,t,!0);break;case i.Token.EQUALS:case i.Token.PLUS_EQUALS:case i.Token.MINUS_EQUALS:case i.Token.ASTERISK_ASTERISK_EQUALS:case i.Token.ASTERISK_EQUALS:case i.Token.SLASH_EQUALS:case i.Token.PERCENT_EQUALS:case i.Token.LESSTHAN_LESSTHAN_EQUALS:case i.Token.GREATERTHAN_GREATERTHAN_EQUALS:case i.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:case i.Token.AMPERSAND_EQUALS:case i.Token.CARET_EQUALS:case i.Token.BAR_EQUALS:case i.Token.ASTERISK_ASTERISK:{let n=this.parseExpression(e,r);if(!n)return null;t=o.Node.createBinaryExpression(l,t,n,e.range(s,e.pos));break}case i.Token.LESSTHAN:case i.Token.GREATERTHAN:case i.Token.LESSTHAN_EQUALS:case i.Token.GREATERTHAN_EQUALS:case i.Token.EQUALS_EQUALS:case i.Token.EQUALS_EQUALS_EQUALS:case i.Token.EXCLAMATION_EQUALS_EQUALS:case i.Token.EXCLAMATION_EQUALS:case i.Token.PLUS:case i.Token.MINUS:case i.Token.ASTERISK:case i.Token.SLASH:case i.Token.PERCENT:case i.Token.LESSTHAN_LESSTHAN:case i.Token.GREATERTHAN_GREATERTHAN:case i.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:case i.Token.AMPERSAND:case i.Token.BAR:case i.Token.CARET:case i.Token.AMPERSAND_AMPERSAND:case i.Token.BAR_BAR:{let n=this.parseExpression(e,r+1);if(!n)return null;t=o.Node.createBinaryExpression(l,t,n,e.range(s,e.pos));break}default:assert(!1)}}return t}joinPropertyCall(e,n,t,r){var i=r.expression;switch(i.kind){case o.NodeKind.IDENTIFIER:r.expression=o.Node.createPropertyAccessExpression(t,i,e.range(n,e.pos));break;case o.NodeKind.CALL:{let a=this.joinPropertyCall(e,n,t,i);if(!a)return null;r.expression=a,r.range=e.range(n,e.pos);break}default:return this.error(a.DiagnosticCode.Identifier_expected,r.range),null}return r}maybeParseCallExpression(e,n,t=!1){for(var r=null;e.skip(i.Token.OPENPAREN)||t&&null!==(r=this.tryParseTypeArgumentsBeforeArguments(e));){let i=this.parseArguments(e);if(!i)break;n=o.Node.createCallExpression(n,r,i,e.range(n.range.start,e.pos)),t=!1}return n}skipStatement(e){for(e.peek(!0),e.nextTokenOnNewLine&&e.next();;){let n=e.peek(!0);if(n==i.Token.ENDOFFILE||n==i.Token.SEMICOLON){e.next();break}if(e.nextTokenOnNewLine)break;switch(e.next()){case i.Token.IDENTIFIER:e.readIdentifier();break;case i.Token.STRINGLITERAL:e.readString();break;case i.Token.INTEGERLITERAL:e.readInteger(),e.checkForIdentifierStartAfterNumericLiteral();break;case i.Token.FLOATLITERAL:e.readFloat(),e.checkForIdentifierStartAfterNumericLiteral();break;case i.Token.OPENBRACE:this.skipBlock(e)}}}skipBlock(e){var n=1,t=!0;do{switch(e.next()){case i.Token.ENDOFFILE:this.error(a.DiagnosticCode._0_expected,e.range(),"}"),t=!1;break;case i.Token.OPENBRACE:++n;break;case i.Token.CLOSEBRACE:--n||(t=!1);break;case i.Token.IDENTIFIER:e.readIdentifier();break;case i.Token.STRINGLITERAL:e.readString();break;case i.Token.INTEGERLITERAL:e.readInteger(),e.checkForIdentifierStartAfterNumericLiteral();break;case i.Token.FLOATLITERAL:e.readFloat(),e.checkForIdentifierStartAfterNumericLiteral()}}while(t)}}function c(e){switch(e){case i.Token.COMMA:return 1;case i.Token.EQUALS:case i.Token.PLUS_EQUALS:case i.Token.MINUS_EQUALS:case i.Token.ASTERISK_ASTERISK_EQUALS:case i.Token.ASTERISK_EQUALS:case i.Token.SLASH_EQUALS:case i.Token.PERCENT_EQUALS:case i.Token.LESSTHAN_LESSTHAN_EQUALS:case i.Token.GREATERTHAN_GREATERTHAN_EQUALS:case i.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:case i.Token.AMPERSAND_EQUALS:case i.Token.CARET_EQUALS:case i.Token.BAR_EQUALS:return 4;case i.Token.QUESTION:return 5;case i.Token.BAR_BAR:return 6;case i.Token.AMPERSAND_AMPERSAND:return 7;case i.Token.BAR:return 8;case i.Token.CARET:return 9;case i.Token.AMPERSAND:return 10;case i.Token.EQUALS_EQUALS:case i.Token.EXCLAMATION_EQUALS:case i.Token.EQUALS_EQUALS_EQUALS:case i.Token.EXCLAMATION_EQUALS_EQUALS:return 11;case i.Token.AS:case i.Token.IN:case i.Token.INSTANCEOF:case i.Token.LESSTHAN:case i.Token.GREATERTHAN:case i.Token.LESSTHAN_EQUALS:case i.Token.GREATERTHAN_EQUALS:return 12;case i.Token.LESSTHAN_LESSTHAN:case i.Token.GREATERTHAN_GREATERTHAN:case i.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:return 13;case i.Token.PLUS:case i.Token.MINUS:return 14;case i.Token.ASTERISK:case i.Token.SLASH:case i.Token.PERCENT:return 15;case i.Token.ASTERISK_ASTERISK:return 16;case i.Token.PLUS_PLUS:case i.Token.MINUS_MINUS:return 18;case i.Token.DOT:case i.Token.NEW:case i.Token.OPENBRACKET:case i.Token.EXCLAMATION:return 20}return 0}n.Parser=u,function(e){e[e.NONE=0]="NONE",e[e.COMMA=1]="COMMA",e[e.SPREAD=2]="SPREAD",e[e.YIELD=3]="YIELD",e[e.ASSIGNMENT=4]="ASSIGNMENT",e[e.CONDITIONAL=5]="CONDITIONAL",e[e.LOGICAL_OR=6]="LOGICAL_OR",e[e.LOGICAL_AND=7]="LOGICAL_AND",e[e.BITWISE_OR=8]="BITWISE_OR",e[e.BITWISE_XOR=9]="BITWISE_XOR",e[e.BITWISE_AND=10]="BITWISE_AND",e[e.EQUALITY=11]="EQUALITY",e[e.RELATIONAL=12]="RELATIONAL",e[e.SHIFT=13]="SHIFT",e[e.ADDITIVE=14]="ADDITIVE",e[e.MULTIPLICATIVE=15]="MULTIPLICATIVE",e[e.EXPONENTIATED=16]="EXPONENTIATED",e[e.UNARY_PREFIX=17]="UNARY_PREFIX",e[e.UNARY_POSTFIX=18]="UNARY_POSTFIX",e[e.CALL=19]="CALL",e[e.MEMBERACCESS=20]="MEMBERACCESS",e[e.GROUPING=21]="GROUPING"}(n.Precedence||(n.Precedence={}))},416:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.findUsedLocals=void 0;const r=t(666),i=t(292);class a extends r.Visitor{constructor(e=new Set){super(),this.used=e}visitLocalGet(e){this.used.add(i._BinaryenLocalGetGetIndex(e))}visitLocalSet(e){this.used.add(i._BinaryenLocalSetGetIndex(e))}}var s=null;n.findUsedLocals=function(e,n=new Set){var t=s;return t?t.used=n:s=t=new a(n),t.visit(e),n}},666:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.replaceChild=n.Pass=n.Visitor=void 0;const r=t(656),i=t(292);class a{constructor(){this.stack=new Array,this._currentExpression=0}get currentExpression(){var e=this._currentExpression;if(!e)throw new Error("not walking expressions");return e}get parentExpressionOrNull(){var e=this.stack,n=e.length;return n?e[n-1]:0}visitBlock(e){}visitIf(e){}visitLoop(e){}visitBreak(e){}visitSwitch(e){}visitCallPre(e){}visitCall(e){}visitCallIndirectPre(e){}visitCallIndirect(e){}visitLocalGet(e){}visitLocalSet(e){}visitGlobalGet(e){}visitGlobalSet(e){}visitLoad(e){}visitStore(e){}visitConst(e){}visitUnary(e){}visitBinary(e){}visitSelect(e){}visitDrop(e){}visitReturn(e){}visitMemorySize(e){}visitMemoryGrow(e){}visitNop(e){}visitUnreachable(e){}visitAtomicRMW(e){}visitAtomicCmpxchg(e){}visitAtomicWait(e){}visitAtomicNotify(e){}visitAtomicFence(e){}visitSIMDExtract(e){}visitSIMDReplace(e){}visitSIMDShuffle(e){}visitSIMDTernary(e){}visitSIMDShift(e){}visitSIMDLoad(e){}visitMemoryInit(e){}visitDataDrop(e){}visitMemoryCopy(e){}visitMemoryFill(e){}visitPop(e){}visitRefNull(e){}visitRefIsNull(e){}visitRefFunc(e){}visitRefEq(e){}visitTry(e){}visitThrow(e){}visitRethrow(e){}visitBrOnExn(e){}visitTupleMake(e){}visitTupleExtract(e){}visitI31New(e){}visitI31Get(e){}visitCallRef(e){}visitRefTest(e){}visitRefCast(e){}visitBrOnCast(e){}visitRttCanon(e){}visitRttSub(e){}visitStructNew(e){}visitStructGet(e){}visitStructSet(e){}visitArrayNew(e){}visitArrayGet(e){}visitArraySet(e){}visitArrayLen(e){}visitName(e){}visitLabel(e){}visitIndex(e){}visitEvent(e){}visit(e){let n=this._currentExpression;switch(this._currentExpression=assert(e),i._BinaryenExpressionGetId(e)){case r.ExpressionId.Block:{this.stack.push(e);let n=i._BinaryenBlockGetName(e);n&&this.visitLabel(n);for(let n=0,t=i._BinaryenBlockGetNumChildren(e);n<t;++n)this.visit(i._BinaryenBlockGetChildAt(e,n));assert(this.stack.pop()==e),this.visitBlock(e);break}case r.ExpressionId.If:{this.stack.push(e),this.visit(i._BinaryenIfGetCondition(e)),this.visit(i._BinaryenIfGetIfTrue(e));let n=i._BinaryenIfGetIfFalse(e);n&&this.visit(n),assert(this.stack.pop()==e),this.visitIf(e);break}case r.ExpressionId.Loop:{this.stack.push(e);let n=i._BinaryenLoopGetName(e);n&&this.visitLabel(n),this.visit(i._BinaryenLoopGetBody(e)),assert(this.stack.pop()==e),this.visitLoop(e);break}case r.ExpressionId.Break:{this.stack.push(e),this.visitLabel(i._BinaryenBreakGetName(e));let n=i._BinaryenBreakGetCondition(e);n&&this.visit(n);let t=i._BinaryenBreakGetValue(e);t&&this.visit(t),assert(this.stack.pop()==e),this.visitBreak(e);break}case r.ExpressionId.Switch:{this.stack.push(e);let n=i._BinaryenSwitchGetDefaultName(e);n&&this.visitLabel(n);let t=i._BinaryenSwitchGetNumNames(e);for(let n=0;n<t;++n)this.visitLabel(i._BinaryenSwitchGetNameAt(e,n));this.visit(i._BinaryenSwitchGetCondition(e));let r=i._BinaryenSwitchGetValue(e);r&&this.visit(r),assert(this.stack.pop()==e),this.visitSwitch(e);break}case r.ExpressionId.Call:{this.visitCallPre(e),this.stack.push(e),this.visitName(i._BinaryenCallGetTarget(e));let n=i._BinaryenCallGetNumOperands(e);for(let t=0;t<n;++t)this.visit(i._BinaryenCallGetOperandAt(e,t));assert(this.stack.pop()==e),this.visitCall(e);break}case r.ExpressionId.CallIndirect:this.visitCallIndirectPre(e),this.stack.push(e),this.visit(i._BinaryenCallIndirectGetTarget(e));for(let n=0,t=i._BinaryenCallIndirectGetNumOperands(e);n<t;++n)this.visit(i._BinaryenCallIndirectGetOperandAt(e,n));assert(this.stack.pop()==e),this.visitCallIndirect(e);break;case r.ExpressionId.LocalGet:this.stack.push(e),this.visitIndex(i._BinaryenLocalGetGetIndex(e)),assert(this.stack.pop()==e),this.visitLocalGet(e);break;case r.ExpressionId.LocalSet:this.stack.push(e),this.visitIndex(i._BinaryenLocalSetGetIndex(e)),this.visit(i._BinaryenLocalSetGetValue(e)),assert(this.stack.pop()==e),this.visitLocalSet(e);break;case r.ExpressionId.GlobalGet:this.stack.push(e),this.visitName(i._BinaryenGlobalGetGetName(e)),assert(this.stack.pop()==e),this.visitGlobalGet(e);break;case r.ExpressionId.GlobalSet:this.stack.push(e),this.visitName(i._BinaryenGlobalSetGetName(e)),this.visit(i._BinaryenGlobalSetGetValue(e)),assert(this.stack.pop()==e),this.visitGlobalSet(e);break;case r.ExpressionId.Load:this.stack.push(e),this.visit(i._BinaryenLoadGetPtr(e)),assert(this.stack.pop()==e),this.visitLoad(e);break;case r.ExpressionId.Store:this.stack.push(e),this.visit(i._BinaryenStoreGetPtr(e)),this.visit(i._BinaryenStoreGetValue(e)),assert(this.stack.pop()==e),this.visitStore(e);break;case r.ExpressionId.Const:this.visitConst(e);break;case r.ExpressionId.Unary:this.stack.push(e),this.visit(i._BinaryenUnaryGetValue(e)),assert(this.stack.pop()==e),this.visitUnary(e);break;case r.ExpressionId.Binary:this.stack.push(e),this.visit(i._BinaryenBinaryGetLeft(e)),this.visit(i._BinaryenBinaryGetRight(e)),assert(this.stack.pop()==e),this.visitBinary(e);break;case r.ExpressionId.Select:this.stack.push(e),this.visit(i._BinaryenSelectGetIfTrue(e)),this.visit(i._BinaryenSelectGetIfFalse(e)),this.visit(i._BinaryenSelectGetCondition(e)),assert(this.stack.pop()==e),this.visitSelect(e);break;case r.ExpressionId.Drop:this.stack.push(e),this.visit(i._BinaryenDropGetValue(e)),assert(this.stack.pop()==e),this.visitDrop(e);break;case r.ExpressionId.Return:{let n=i._BinaryenReturnGetValue(e);n&&(this.stack.push(e),this.visit(n),assert(this.stack.pop()==e)),this.visitReturn(e);break}case r.ExpressionId.MemorySize:this.visitMemorySize(e);break;case r.ExpressionId.MemoryGrow:this.stack.push(e),this.visit(i._BinaryenMemoryGrowGetDelta(e)),assert(this.stack.pop()==e),this.visitMemoryGrow(e);break;case r.ExpressionId.Nop:this.visitNop(e);break;case r.ExpressionId.Unreachable:this.visitUnreachable(e);break;case r.ExpressionId.AtomicRMW:this.stack.push(e),this.visit(i._BinaryenAtomicRMWGetPtr(e)),this.visit(i._BinaryenAtomicRMWGetValue(e)),assert(this.stack.pop()==e),this.visitAtomicRMW(e);break;case r.ExpressionId.AtomicCmpxchg:this.stack.push(e),this.visit(i._BinaryenAtomicCmpxchgGetPtr(e)),this.visit(i._BinaryenAtomicCmpxchgGetExpected(e)),this.visit(i._BinaryenAtomicCmpxchgGetReplacement(e)),assert(this.stack.pop()==e),this.visitAtomicCmpxchg(e);break;case r.ExpressionId.AtomicWait:this.stack.push(e),this.visit(i._BinaryenAtomicWaitGetPtr(e)),this.visit(i._BinaryenAtomicWaitGetExpected(e)),this.visit(i._BinaryenAtomicWaitGetTimeout(e)),assert(this.stack.pop()==e),this.visitAtomicWait(e);break;case r.ExpressionId.AtomicNotify:this.stack.push(e),this.visit(i._BinaryenAtomicNotifyGetPtr(e)),this.visit(i._BinaryenAtomicNotifyGetNotifyCount(e)),assert(this.stack.pop()==e),this.visitAtomicNotify(e);break;case r.ExpressionId.AtomicFence:this.visitAtomicFence(e);break;case r.ExpressionId.SIMDExtract:this.stack.push(e),this.visit(i._BinaryenSIMDExtractGetVec(e)),assert(this.stack.pop()==e),this.visitSIMDExtract(e);break;case r.ExpressionId.SIMDReplace:this.stack.push(e),this.visit(i._BinaryenSIMDReplaceGetVec(e)),this.visit(i._BinaryenSIMDReplaceGetValue(e)),assert(this.stack.pop()==e),this.visitSIMDReplace(e);break;case r.ExpressionId.SIMDShuffle:this.stack.push(e),this.visit(i._BinaryenSIMDShuffleGetLeft(e)),this.visit(i._BinaryenSIMDShuffleGetRight(e)),assert(this.stack.pop()==e),this.visitSIMDShuffle(e);break;case r.ExpressionId.SIMDTernary:this.stack.push(e),this.visit(i._BinaryenSIMDTernaryGetA(e)),this.visit(i._BinaryenSIMDTernaryGetB(e)),this.visit(i._BinaryenSIMDTernaryGetC(e)),assert(this.stack.pop()==e),this.visitSIMDTernary(e);break;case r.ExpressionId.SIMDShift:this.stack.push(e),this.visit(i._BinaryenSIMDShiftGetVec(e)),this.visit(i._BinaryenSIMDShiftGetShift(e)),assert(this.stack.pop()==e),this.visitSIMDShift(e);break;case r.ExpressionId.SIMDLoad:this.stack.push(e),this.visit(i._BinaryenSIMDLoadGetPtr(e)),assert(this.stack.pop()==e),this.visitSIMDLoad(e);break;case r.ExpressionId.MemoryInit:this.stack.push(e),this.visit(i._BinaryenMemoryInitGetDest(e)),this.visit(i._BinaryenMemoryInitGetOffset(e)),this.visit(i._BinaryenMemoryInitGetSize(e)),assert(this.stack.pop()==e),this.visitMemoryInit(e);break;case r.ExpressionId.DataDrop:this.visitDataDrop(e);break;case r.ExpressionId.MemoryCopy:this.stack.push(e),this.visit(i._BinaryenMemoryCopyGetDest(e)),this.visit(i._BinaryenMemoryCopyGetSource(e)),this.visit(i._BinaryenMemoryCopyGetSize(e)),assert(this.stack.pop()==e),this.visitMemoryCopy(e);break;case r.ExpressionId.MemoryFill:this.stack.push(e),this.visit(i._BinaryenMemoryFillGetDest(e)),this.visit(i._BinaryenMemoryFillGetValue(e)),this.visit(i._BinaryenMemoryFillGetSize(e)),assert(this.stack.pop()==e),this.visitMemoryFill(e);break;case r.ExpressionId.Pop:this.visitPop(e);break;case r.ExpressionId.RefNull:this.visitRefNull(e);break;case r.ExpressionId.RefIsNull:this.stack.push(e),this.visit(i._BinaryenRefIsNullGetValue(e)),assert(this.stack.pop()==e),this.visitRefIsNull(e);break;case r.ExpressionId.RefFunc:this.stack.push(e),this.visitName(i._BinaryenRefFuncGetFunc(e)),assert(this.stack.pop()==e),this.visitRefFunc(e);break;case r.ExpressionId.RefEq:this.stack.push(e),this.visit(i._BinaryenRefEqGetLeft(e)),this.visit(i._BinaryenRefEqGetRight(e)),assert(this.stack.pop()==e),this.visitRefEq(e);break;case r.ExpressionId.Try:this.stack.push(e),this.visit(i._BinaryenTryGetBody(e)),this.visit(i._BinaryenTryGetCatchBody(e)),assert(this.stack.pop()==e),this.visitTry(e);break;case r.ExpressionId.Throw:{this.stack.push(e),this.visitEvent(i._BinaryenThrowGetEvent(e));let n=i._BinaryenThrowGetNumOperands(e);for(let t=0;t<n;++t)this.visit(i._BinaryenThrowGetOperandAt(e,t));assert(this.stack.pop()==e),this.visitThrow(e);break}case r.ExpressionId.Rethrow:this.stack.push(e),this.visit(i._BinaryenRethrowGetExnref(e)),assert(this.stack.pop()==e),this.visitRethrow(e);break;case r.ExpressionId.BrOnExn:this.stack.push(e),this.visitEvent(i._BinaryenBrOnExnGetEvent(e)),this.visitLabel(i._BinaryenBrOnExnGetName(e)),this.visit(i._BinaryenBrOnExnGetExnref(e)),assert(this.stack.pop()==e),this.visitBrOnExn(e);break;case r.ExpressionId.TupleMake:{let n=i._BinaryenTupleMakeGetNumOperands(e);if(n){this.stack.push(e);for(let t=0;t<n;++t)this.visit(i._BinaryenTupleMakeGetOperandAt(e,t));assert(this.stack.pop()==e)}this.visitTupleMake(e);break}case r.ExpressionId.TupleExtract:this.stack.push(e),this.visit(i._BinaryenTupleExtractGetTuple(e)),assert(this.stack.pop()==e),this.visitTupleExtract(e);break;case r.ExpressionId.I31New:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitI31New(e);break;case r.ExpressionId.I31Get:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitI31Get(e);break;case r.ExpressionId.CallRef:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitCallRef(e);break;case r.ExpressionId.RefTest:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitRefTest(e);break;case r.ExpressionId.RefCast:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitRefCast(e);break;case r.ExpressionId.BrOnCast:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitBrOnCast(e);break;case r.ExpressionId.RttCanon:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitRttCanon(e);break;case r.ExpressionId.RttSub:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitRttSub(e);break;case r.ExpressionId.StructNew:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitStructNew(e);break;case r.ExpressionId.StructGet:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitStructGet(e);break;case r.ExpressionId.StructSet:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitStructSet(e);break;case r.ExpressionId.ArrayNew:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitArrayNew(e);break;case r.ExpressionId.ArrayGet:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitArrayGet(e);break;case r.ExpressionId.ArraySet:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitArraySet(e);break;case r.ExpressionId.ArrayLen:this.stack.push(e),assert(!1),assert(this.stack.pop()==e),this.visitArrayLen(e);break;default:throw new Error("unexpected expression kind")}this._currentExpression=n}}function s(e,n,t){switch(i._BinaryenExpressionGetId(e)){case r.ExpressionId.Block:{let r=i._BinaryenBlockGetNumChildren(e);for(let a=0;a<r;++a){let r=i._BinaryenBlockGetChildAt(e,a);if(r==n)return i._BinaryenBlockSetChildAt(e,a,t),r}break}case r.ExpressionId.If:{let r=i._BinaryenIfGetCondition(e);if(r==n)return i._BinaryenIfSetCondition(e,t),r;let a=i._BinaryenIfGetIfTrue(e);if(a==n)return i._BinaryenIfSetIfTrue(e,t),a;let s=i._BinaryenIfGetIfFalse(e);if(s==n)return i._BinaryenIfSetIfFalse(e,t),s;break}case r.ExpressionId.Loop:{let r=i._BinaryenLoopGetBody(e);if(r==n)return i._BinaryenLoopSetBody(e,t),r;break}case r.ExpressionId.Break:{let r=i._BinaryenBreakGetCondition(e);if(r==n)return i._BinaryenBreakSetCondition(e,t),r;let a=i._BinaryenBreakGetValue(e);if(a==n)return i._BinaryenBreakSetValue(e,t),a;break}case r.ExpressionId.Switch:{let r=i._BinaryenSwitchGetCondition(e);if(r==n)return i._BinaryenSwitchSetCondition(e,t),r;let a=i._BinaryenSwitchGetValue(e);if(a==n)return i._BinaryenSwitchSetValue(e,t),a;break}case r.ExpressionId.Call:{let r=i._BinaryenCallGetNumOperands(e);for(let a=0;a<r;++a){let r=i._BinaryenCallGetOperandAt(e,a);if(r==n)return i._BinaryenCallSetOperandAt(e,a,t),r}break}case r.ExpressionId.CallIndirect:{let r=i._BinaryenCallIndirectGetTarget(e);if(r==n)return i._BinaryenCallIndirectSetTarget(e,t),r;let a=i._BinaryenCallIndirectGetNumOperands(e);for(let r=0;r<a;++r){let a=i._BinaryenCallIndirectGetOperandAt(e,r);if(a==n)return i._BinaryenCallIndirectSetOperandAt(e,r,t),a}break}case r.ExpressionId.LocalGet:break;case r.ExpressionId.LocalSet:{let r=i._BinaryenLocalSetGetValue(e);if(r==n)return i._BinaryenLocalSetSetValue(e,t),r;break}case r.ExpressionId.GlobalGet:break;case r.ExpressionId.GlobalSet:{let r=i._BinaryenGlobalSetGetValue(e);if(r==n)return i._BinaryenGlobalSetSetValue(e,t),r;break}case r.ExpressionId.Load:{let r=i._BinaryenLoadGetPtr(e);if(r==n)return i._BinaryenLoadSetPtr(e,t),r;break}case r.ExpressionId.Store:{let r=i._BinaryenStoreGetPtr(e);if(r==n)return i._BinaryenStoreSetPtr(e,t),r;let a=i._BinaryenStoreGetValue(e);if(a==n)return i._BinaryenStoreSetValue(e,t),a;break}case r.ExpressionId.Const:break;case r.ExpressionId.Unary:{let r=i._BinaryenUnaryGetValue(e);if(r==n)return i._BinaryenUnarySetValue(e,t),r;break}case r.ExpressionId.Binary:{let r=i._BinaryenBinaryGetLeft(e);if(r==n)return i._BinaryenBinarySetLeft(e,t),r;let a=i._BinaryenBinaryGetRight(e);if(a==n)return i._BinaryenBinarySetRight(e,t),a;break}case r.ExpressionId.Select:{let r=i._BinaryenSelectGetIfTrue(e);if(r==n)return i._BinaryenSelectSetIfTrue(e,t),r;let a=i._BinaryenSelectGetIfFalse(e);if(a==n)return i._BinaryenSelectSetIfFalse(e,t),a;let s=i._BinaryenSelectGetCondition(e);if(s==n)return i._BinaryenSelectSetCondition(e,t),s;break}case r.ExpressionId.Drop:{let r=i._BinaryenDropGetValue(e);if(r==n)return i._BinaryenDropSetValue(e,t),r;break}case r.ExpressionId.Return:{let r=i._BinaryenReturnGetValue(e);if(r==n)return i._BinaryenReturnSetValue(e,t),r;break}case r.ExpressionId.MemorySize:break;case r.ExpressionId.MemoryGrow:{let r=i._BinaryenMemoryGrowGetDelta(e);if(r==n)return i._BinaryenMemoryGrowSetDelta(e,t),r;break}case r.ExpressionId.Nop:case r.ExpressionId.Unreachable:break;case r.ExpressionId.AtomicRMW:{let r=i._BinaryenAtomicRMWGetPtr(e);if(r==n)return i._BinaryenAtomicRMWSetPtr(e,t),r;let a=i._BinaryenAtomicRMWGetValue(e);if(a==n)return i._BinaryenAtomicRMWSetValue(e,t),a;break}case r.ExpressionId.AtomicCmpxchg:{let r=i._BinaryenAtomicCmpxchgGetPtr(e);if(r==n)return i._BinaryenAtomicCmpxchgSetPtr(e,t),r;let a=i._BinaryenAtomicCmpxchgGetExpected(e);if(a==n)return i._BinaryenAtomicCmpxchgSetExpected(e,t),a;let s=i._BinaryenAtomicCmpxchgGetReplacement(e);if(s==n)return i._BinaryenAtomicCmpxchgSetReplacement(e,t),s;break}case r.ExpressionId.AtomicWait:{let r=i._BinaryenAtomicWaitGetPtr(e);if(r==n)return i._BinaryenAtomicWaitSetPtr(e,t),r;let a=i._BinaryenAtomicWaitGetExpected(e);if(a==n)return i._BinaryenAtomicWaitSetExpected(e,t),a;let s=i._BinaryenAtomicWaitGetTimeout(e);if(s==n)return i._BinaryenAtomicWaitSetTimeout(e,t),s;break}case r.ExpressionId.AtomicNotify:{let r=i._BinaryenAtomicNotifyGetPtr(e);if(r==n)return i._BinaryenAtomicNotifySetPtr(e,t),r;let a=i._BinaryenAtomicNotifyGetNotifyCount(e);if(a==n)return i._BinaryenAtomicNotifySetNotifyCount(e,t),a;break}case r.ExpressionId.AtomicFence:break;case r.ExpressionId.SIMDExtract:{let r=i._BinaryenSIMDExtractGetVec(e);if(r==n)return i._BinaryenSIMDExtractSetVec(e,t),r;break}case r.ExpressionId.SIMDReplace:{let r=i._BinaryenSIMDReplaceGetVec(e);if(r==n)return i._BinaryenSIMDReplaceSetVec(e,t),r;let a=i._BinaryenSIMDReplaceGetValue(e);if(a==n)return i._BinaryenSIMDReplaceSetValue(e,t),a;break}case r.ExpressionId.SIMDShuffle:{let r=i._BinaryenSIMDShuffleGetLeft(e);if(r==n)return i._BinaryenSIMDShuffleSetLeft(e,t),r;let a=i._BinaryenSIMDShuffleGetRight(e);if(a==n)return i._BinaryenSIMDShuffleSetRight(e,t),a;break}case r.ExpressionId.SIMDTernary:{let r=i._BinaryenSIMDTernaryGetA(e);if(r==n)return i._BinaryenSIMDTernarySetA(e,t),r;let a=i._BinaryenSIMDTernaryGetB(e);if(a==n)return i._BinaryenSIMDTernarySetB(e,t),a;let s=i._BinaryenSIMDTernaryGetC(e);if(s==n)return i._BinaryenSIMDTernarySetC(e,t),s;break}case r.ExpressionId.SIMDShift:{let r=i._BinaryenSIMDShiftGetVec(e);if(r==n)return i._BinaryenSIMDShiftSetVec(e,t),r;let a=i._BinaryenSIMDShiftGetShift(e);if(a==n)return i._BinaryenSIMDShiftSetShift(e,t),a;break}case r.ExpressionId.SIMDLoad:{let r=i._BinaryenSIMDLoadGetPtr(e);if(r==n)return i._BinaryenSIMDLoadSetPtr(e,t),r;break}case r.ExpressionId.MemoryInit:{let r=i._BinaryenMemoryInitGetDest(e);if(r==n)return i._BinaryenMemoryInitSetDest(e,t),r;let a=i._BinaryenMemoryInitGetOffset(e);if(a==n)return i._BinaryenMemoryInitSetOffset(e,t),a;let s=i._BinaryenMemoryInitGetSize(e);if(s==n)return i._BinaryenMemoryInitSetSize(e,t),s;break}case r.ExpressionId.DataDrop:break;case r.ExpressionId.MemoryCopy:{let r=i._BinaryenMemoryCopyGetDest(e);if(r==n)return i._BinaryenMemoryCopySetDest(e,t),r;let a=i._BinaryenMemoryCopyGetSource(e);if(a==n)return i._BinaryenMemoryCopySetSource(e,t),a;let s=i._BinaryenMemoryCopyGetSize(e);if(s==n)return i._BinaryenMemoryCopySetSize(e,t),s;break}case r.ExpressionId.MemoryFill:{let r=i._BinaryenMemoryFillGetDest(e);if(r==n)return i._BinaryenMemoryFillSetDest(e,t),r;let a=i._BinaryenMemoryFillGetValue(e);if(a==n)return i._BinaryenMemoryFillSetValue(e,t),a;let s=i._BinaryenMemoryFillGetSize(e);if(s==n)return i._BinaryenMemoryFillSetSize(e,t),s;break}case r.ExpressionId.Pop:case r.ExpressionId.RefNull:break;case r.ExpressionId.RefIsNull:{let r=i._BinaryenRefIsNullGetValue(e);if(r==n)return i._BinaryenRefIsNullSetValue(e,t),r;break}case r.ExpressionId.RefFunc:break;case r.ExpressionId.RefEq:{let r=i._BinaryenRefEqGetLeft(e);if(r==n)return i._BinaryenRefEqSetLeft(e,t),r;let a=i._BinaryenRefEqGetRight(e);if(a==n)return i._BinaryenRefEqSetRight(e,t),a;break}case r.ExpressionId.Try:{let r=i._BinaryenTryGetBody(e);if(r==n)return i._BinaryenTrySetBody(e,t),r;let a=i._BinaryenTryGetCatchBody(e);if(a==n)return i._BinaryenTrySetCatchBody(e,t),a;break}case r.ExpressionId.Throw:{let r=i._BinaryenThrowGetNumOperands(e);for(let a=0;a<r;++a){let r=i._BinaryenThrowGetOperandAt(e,a);if(r==n)return i._BinaryenThrowSetOperandAt(e,a,t),r}break}case r.ExpressionId.Rethrow:{let r=i._BinaryenRethrowGetExnref(e);if(r==n)return i._BinaryenRethrowSetExnref(e,t),r;break}case r.ExpressionId.BrOnExn:{let r=i._BinaryenBrOnExnGetExnref(e);if(r==n)return i._BinaryenBrOnExnSetExnref(e,t),r;break}case r.ExpressionId.TupleMake:{let r=i._BinaryenTupleMakeGetNumOperands(e);for(let a=0;a<r;++a){let r=i._BinaryenTupleMakeGetOperandAt(e,a);if(r==n)return i._BinaryenTupleMakeSetOperandAt(e,a,t),r}break}case r.ExpressionId.TupleExtract:{let r=i._BinaryenTupleExtractGetTuple(e);if(r==n)return i._BinaryenTupleExtractSetTuple(e,t),r;break}case r.ExpressionId.I31New:case r.ExpressionId.I31Get:case r.ExpressionId.CallRef:case r.ExpressionId.RefTest:case r.ExpressionId.RefCast:case r.ExpressionId.BrOnCast:case r.ExpressionId.RttCanon:case r.ExpressionId.RttSub:case r.ExpressionId.StructNew:case r.ExpressionId.StructGet:case r.ExpressionId.StructSet:case r.ExpressionId.ArrayNew:case r.ExpressionId.ArrayGet:case r.ExpressionId.ArraySet:case r.ExpressionId.ArrayLen:assert(!1);break;default:throw new Error("unexpected expression id")}return 0}n.Visitor=a,n.Pass=class extends a{constructor(e){super(),this.module=e,this._currentFunction=0,this._currentGlobal=0}get currentFunction(){var e=this._currentFunction;if(!e)throw new Error("not walking a function");return e}get currentGlobal(){var e=this._currentGlobal;if(!e)throw new Error("not walking a global");return e}walkModule(){this.walkFunctions(),this.walkGlobals()}walkFunctions(){var e=this.module.ref;for(let n=0,t=i._BinaryenGetNumFunctions(e);n<t;++n)this.walkFunction(i._BinaryenGetFunctionByIndex(e,n))}walkFunction(e){var n=i._BinaryenFunctionGetBody(e);n&&(this._currentFunction=e,this.visit(n),this._currentFunction=0)}walkGlobals(){var e=this.module.ref;for(let n=0,t=i._BinaryenGetNumGlobals(e);n<t;++n)this.walkGlobal(i._BinaryenGetGlobalByIndex(e,n))}walkGlobal(e){this._currentGlobal=e;var n=i._BinaryenGlobalGetInitExpr(e);n&&this.visit(n),this._currentGlobal=0}replaceCurrent(e){var n=this.currentExpression,t=this.currentFunction;if(i._BinaryenFunctionGetBody(t)==n)i._BinaryenFunctionSetBody(t,e);else{var r=assert(this.parentExpressionOrNull);if(!s(r,n,e))throw Error("failed to replace expression");i._BinaryenExpressionFinalize(r)}}},n.replaceChild=s},865:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.RtraceMemory=void 0;const r=t(666),i=t(656),a=t(292);class s extends r.Pass{constructor(e){super(e.module),this.seenStores=!1,this.ptrType=e.options.nativeSizeType}checkRT(){return this.module.readStringCached(a._BinaryenFunctionGetName(this.currentFunction)).startsWith("~lib/rt/")}visitStore(e){var n=this.module,t=a._BinaryenStoreGetPtr(e),r=a._BinaryenStoreGetOffset(e),i=a._BinaryenStoreGetBytes(e);a._BinaryenStoreSetPtr(e,n.call("~onstore",[t,n.i32(r),n.i32(i),n.i32(i32(this.checkRT()))],this.ptrType)),this.seenStores=!0}walkModule(){super.walkModule(),this.seenStores&&this.module.addFunctionImport("~onstore","rtrace","onstore",i.createType([this.ptrType,i.NativeType.I32,i.NativeType.I32,i.NativeType.I32]),this.ptrType)}}n.RtraceMemory=s},231:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.ShadowStackPass=void 0;const r=t(666),i=t(292),a=t(656),s=t(346);function o(e,n){return i._BinaryenExpressionGetId(n)==a.ExpressionId.Call&&e.readStringCached(i._BinaryenCallGetTarget(n))==s.BuiltinNames.tostack?(assert(1==i._BinaryenCallGetNumOperands(n)),i._BinaryenCallGetOperandAt(n,0)):0}class l extends r.Pass{constructor(e){super(e.module),this.slotMaps=new Map,this.tempMaps=new Map,this.exportMap=new Map,this.hasStackCheckFunction=!1,this.callSlotOffset=0,this.callSlotStack=new Array,this.compiler=e}get options(){return this.compiler.options}get ptrType(){return this.options.nativeSizeType}get ptrSize(){return this.ptrType==a.NativeType.I64?8:4}get ptrBinaryAdd(){return this.ptrType==a.NativeType.I64?a.BinaryOp.AddI64:a.BinaryOp.AddI32}get ptrBinarySub(){return this.ptrType==a.NativeType.I64?a.BinaryOp.SubI64:a.BinaryOp.SubI32}ptrConst(e){return this.ptrType==a.NativeType.I64?this.module.i64(e):this.module.i32(e)}noteSlot(e,n){let t;if(this.slotMaps.has(e)){if(t=changetype(this.slotMaps.get(e)),t.has(n))return changetype(t.get(n))}else t=new Map,this.slotMaps.set(e,t);let r=t.size;return t.set(n,r),r}noteExport(e,n){n.length&&this.exportMap.set(e,n)}getSharedTemp(e,n){let t;if(this.tempMaps.has(e)){if(t=changetype(this.tempMaps.get(e)),t.has(n))return changetype(t.get(n))}else t=new Map,this.tempMaps.set(e,t);let r=i._BinaryenFunctionGetNumLocals(e)+t.size;return t.set(n,r),r}makeStackOffset(e){assert(0!=e);var n=this.module,t=n.global_set(s.BuiltinNames.stack_pointer,n.binary(e>=0?this.ptrBinaryAdd:this.ptrBinarySub,n.global_get(s.BuiltinNames.stack_pointer,this.ptrType),this.ptrConst(abs(e))));return e>0?t:n.block(null,[t,this.makeStackCheck()],a.NativeType.None)}makeStackFill(e,n){assert(e>0);var t=this.module;if(this.options.hasFeature(8)&&e>16)n.push(t.memory_fill(t.global_get(s.BuiltinNames.stack_pointer,this.ptrType),t.i32(0),this.ptrConst(e)));else{let r=e;for(;r>=8;)n.push(t.store(8,t.global_get(s.BuiltinNames.stack_pointer,this.ptrType),t.i64(0),a.NativeType.I64,e-r)),r-=8;r&&(assert(4==r),n.push(t.store(4,t.global_get(s.BuiltinNames.stack_pointer,this.ptrType),t.i32(0),a.NativeType.I32,e-r)))}}makeStackCheck(){var e=this.module;return this.hasStackCheckFunction||(this.hasStackCheckFunction=!0,e.addFunction("~stack_check",a.NativeType.None,a.NativeType.None,null,e.if(e.binary(a.BinaryOp.LtI32,e.global_get(s.BuiltinNames.stack_pointer,this.ptrType),e.global_get(s.BuiltinNames.data_end,this.ptrType)),this.compiler.makeStaticAbort(this.compiler.ensureStaticString("stack overflow"),this.compiler.program.nativeSource)))),e.call("~stack_check",null,a.NativeType.None)}updateCallOperands(e){var n=this.module,t=0;for(let r=0,l=e.length;r<l;++r){let l=o(n,e[r]);if(!l)continue;if(a.isConstZero(l)){e[r]=l;continue}let u=this.currentFunction,c=i._BinaryenFunctionGetNumLocals(u),p=this.noteSlot(u,c+this.callSlotOffset+r),f=this.getSharedTemp(u,this.ptrType),d=new Array;d.push(n.local_set(f,l,!1)),d.push(n.store(this.ptrSize,n.global_get(s.BuiltinNames.stack_pointer,this.ptrType),n.local_get(f,this.ptrType),this.ptrType,p*this.ptrSize)),d.push(n.local_get(f,this.ptrType)),e[r]=n.block(null,d,this.ptrType),++t}return t}visitCallPre(e){var n=i._BinaryenCallGetNumOperands(e),t=new Array(n);for(let r=0;r<n;++r)t[r]=i._BinaryenCallGetOperandAt(e,r);let r=this.updateCallOperands(t);if(r){for(let n=0,r=t.length;n<r;++n)i._BinaryenCallSetOperandAt(e,n,t[n]);this.callSlotOffset+=r}this.callSlotStack.push(r)}visitCall(e){let n=this.callSlotStack.pop();n&&(this.callSlotOffset-=n)}visitCallIndirectPre(e){let n=i._BinaryenCallIndirectGetNumOperands(e),t=new Array(n);for(let r=0;r<n;++r)t[r]=i._BinaryenCallIndirectGetOperandAt(e,r);let r=this.updateCallOperands(t);if(r){for(let n=0,r=t.length;n<r;++n)i._BinaryenCallIndirectSetOperandAt(e,n,t[n]);this.callSlotOffset+=r}this.callSlotStack.push(r)}visitCallIndirect(e){let n=this.callSlotStack.pop();n&&(this.callSlotOffset-=n)}visitLocalSet(e){let n=i._BinaryenLocalSetGetValue(e),t=o(this.module,n);if(!t)return;if(a.isConstZero(t))return void i._BinaryenLocalSetSetValue(e,t);var r=this.module;let l=i._BinaryenLocalSetGetIndex(e),u=this.noteSlot(this.currentFunction,l),c=new Array;c.push(r.store(this.ptrSize,r.global_get(s.BuiltinNames.stack_pointer,this.ptrType),r.local_tee(l,t,!1),this.ptrType,u*this.ptrSize)),i._BinaryenLocalSetIsTee(e)?(c.push(r.local_get(l,this.ptrType)),this.replaceCurrent(r.flatten(c,this.ptrType))):this.replaceCurrent(r.flatten(c,a.NativeType.None))}updateFunction(e){let n=i._BinaryenFunctionGetName(e),t=i._BinaryenFunctionGetParams(e),r=i._BinaryenFunctionGetResults(e),s=assert(i._BinaryenFunctionGetBody(e)),o=i._BinaryenFunctionGetNumVars(e),l=new Array;for(let n=0;n<o;++n)l[n]=i._BinaryenFunctionGetVar(e,n);let u=this.tempMaps;if(u.has(e)){let n=changetype(u.get(e));for(let e=Map_keys(n),t=0,r=e.length;t<r;++t)l.push(e[t])}let c=this.module.ref;i._BinaryenRemoveFunction(c,n);let p=a.allocPtrArray(l);i._BinaryenAddFunction(c,n,t,r,p,l.length,s),i._free(p)}updateExport(e,n){var t=this.module,r=t.ref;assert(i._BinaryenExportGetKind(e)==a.ExternalKind.Function);var o=i._BinaryenExportGetValue(e),l=t.readStringCached(o),u=i._BinaryenExportGetName(e),c=i._BinaryenGetFunction(r,o),p=i._BinaryenFunctionGetParams(c),f=a.expandType(p),d=f.length,h=i._BinaryenFunctionGetResults(c),g=d,x=new Array,m=assert(n.length),_=m*this.ptrSize,y="export:"+l,E=t.allocStringCached(y);if(0==i._BinaryenGetFunction(r,E)){let e=new Array;e.push(this.makeStackOffset(-_));for(let r=0;r<m;++r)e.push(t.store(this.ptrSize,t.global_get(s.BuiltinNames.stack_pointer,this.ptrType),t.local_get(n[r],this.ptrType),this.ptrType,r*this.ptrSize));let o=new Array(d);for(let e=0;e<d;++e)o[e]=t.local_get(e,f[e]);if(h!=a.NativeType.None){let n=g++;x.push(h),e.push(t.local_set(n,t.call(l,o,h),!1)),e.push(this.makeStackOffset(+_)),e.push(t.local_get(n,h))}else e.push(t.call(l,o,h)),e.push(this.makeStackOffset(+_));let u=a.allocPtrArray(x);i._BinaryenAddFunction(r,E,p,h,u,x.length,t.block(null,e,h)),i._free(u)}i._BinaryenRemoveExport(r,u),i._BinaryenAddFunctionExport(r,E,u)}walkModule(){super.walkModule();var e=this.module,n=new u(this);for(let t=Map_keys(this.slotMaps),r=0,s=t.length;r<s;++r){let s=t[r],o=changetype(this.slotMaps.get(s)).size*this.ptrSize;n.frameSize=o,n.walkFunction(s);let l=new Array;l.push(this.makeStackOffset(-o)),this.makeStackFill(o,l);let u=i._BinaryenFunctionGetBody(s),c=i._BinaryenExpressionGetType(u);if(c==a.NativeType.Unreachable)l.push(u);else if(c==a.NativeType.None)l.push(u),l.push(this.makeStackOffset(+o));else{let n=this.getSharedTemp(s,c);l.push(e.local_set(n,u,!1)),l.push(this.makeStackOffset(+o)),l.push(e.local_get(n,c))}i._BinaryenFunctionSetBody(s,e.flatten(l,c))}for(let e=Map_keys(this.tempMaps),n=0,t=e.length;n<t;++n)this.updateFunction(e[n]);var t=this.exportMap;for(let n=Map_keys(t),r=0,a=n.length;r<a;++r){let a=n[r],s=i._BinaryenGetExport(e.ref,e.allocStringCached(a)),o=changetype(t.get(a));this.updateExport(s,o)}}}n.ShadowStackPass=l;class u extends r.Pass{constructor(e){super(e.module),this.frameSize=0,this.parentPass=e}visitReturn(e){assert(this.frameSize);var n=this.module,t=i._BinaryenReturnGetValue(e),r=new Array;if(t){let a=i._BinaryenExpressionGetType(t),s=this.parentPass.getSharedTemp(this.currentFunction,a);r.push(n.local_set(s,t,!1)),r.push(this.parentPass.makeStackOffset(+this.frameSize)),i._BinaryenReturnSetValue(e,n.local_get(s,a))}else r.push(this.parentPass.makeStackOffset(+this.frameSize));r.push(e),this.replaceCurrent(n.flatten(r,a.NativeType.Unreachable))}}},974:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getDefaultParameterName=n.mangleInternalName=n.Interface=n.InterfacePrototype=n.Class=n.ClassPrototype=n.IndexSignature=n.Property=n.PropertyPrototype=n.Field=n.FieldPrototype=n.Function=n.FunctionPrototype=n.Local=n.Parameter=n.Global=n.EnumValue=n.VariableLikeElement=n.ConstantValueKind=n.Enum=n.Namespace=n.TypeDefinition=n.File=n.TypedElement=n.isTypedElement=n.DeclaredElement=n.isDeclaredElement=n.Element=n.DecoratorFlags=n.ElementKind=n.Program=n.OperatorKind=void 0;const r=t(200),i=t(256),a=t(699),s=t(411),o=t(60),l=t(910),u=t(742),c=t(154),p=t(215),f=t(346),d=15;class h{constructor(e,n,t,r,i){this.localFile=e,this.localIdentifier=n,this.foreignIdentifier=t,this.foreignPath=r,this.foreignPathAlt=i}}class g{constructor(e,n,t,r){this.localIdentifier=e,this.foreignIdentifier=n,this.foreignPath=t,this.foreignPathAlt=r}}class x{constructor(e,n,t){this.foreignPath=e,this.foreignPathAlt=n,this.pathLiteral=t}}var m,_,y;!function(e){e[e.INVALID=0]="INVALID",e[e.INDEXED_GET=1]="INDEXED_GET",e[e.INDEXED_SET=2]="INDEXED_SET",e[e.UNCHECKED_INDEXED_GET=3]="UNCHECKED_INDEXED_GET",e[e.UNCHECKED_INDEXED_SET=4]="UNCHECKED_INDEXED_SET",e[e.ADD=5]="ADD",e[e.SUB=6]="SUB",e[e.MUL=7]="MUL",e[e.DIV=8]="DIV",e[e.REM=9]="REM",e[e.POW=10]="POW",e[e.BITWISE_AND=11]="BITWISE_AND",e[e.BITWISE_OR=12]="BITWISE_OR",e[e.BITWISE_XOR=13]="BITWISE_XOR",e[e.BITWISE_SHL=14]="BITWISE_SHL",e[e.BITWISE_SHR=15]="BITWISE_SHR",e[e.BITWISE_SHR_U=16]="BITWISE_SHR_U",e[e.EQ=17]="EQ",e[e.NE=18]="NE",e[e.GT=19]="GT",e[e.GE=20]="GE",e[e.LT=21]="LT",e[e.LE=22]="LE",e[e.PLUS=23]="PLUS",e[e.MINUS=24]="MINUS",e[e.NOT=25]="NOT",e[e.BITWISE_NOT=26]="BITWISE_NOT",e[e.PREFIX_INC=27]="PREFIX_INC",e[e.PREFIX_DEC=28]="PREFIX_DEC",e[e.POSTFIX_INC=29]="POSTFIX_INC",e[e.POSTFIX_DEC=30]="POSTFIX_DEC"}(m=n.OperatorKind||(n.OperatorKind={})),function(e){e.fromDecorator=function(n,t){switch(assert(t.length),n){case o.DecoratorKind.OPERATOR:case o.DecoratorKind.OPERATOR_BINARY:switch(t.charCodeAt(0)){case 91:if("[]"==t)return e.INDEXED_GET;if("[]="==t)return e.INDEXED_SET;break;case 123:if("{}"==t)return e.UNCHECKED_INDEXED_GET;if("{}="==t)return e.UNCHECKED_INDEXED_SET;break;case 43:if("+"==t)return e.ADD;break;case 45:if("-"==t)return e.SUB;break;case 42:if("*"==t)return e.MUL;if("**"==t)return e.POW;break;case 47:if("/"==t)return e.DIV;break;case 37:if("%"==t)return e.REM;break;case 38:if("&"==t)return e.BITWISE_AND;break;case 124:if("|"==t)return e.BITWISE_OR;break;case 94:if("^"==t)return e.BITWISE_XOR;break;case 61:if("=="==t)return e.EQ;break;case 33:if("!="==t)return e.NE;break;case 62:if(">"==t)return e.GT;if(">="==t)return e.GE;if(">>"==t)return e.BITWISE_SHR;if(">>>"==t)return e.BITWISE_SHR_U;break;case 60:if("<"==t)return e.LT;if("<="==t)return e.LE;if("<<"==t)return e.BITWISE_SHL}break;case o.DecoratorKind.OPERATOR_PREFIX:switch(t.charCodeAt(0)){case 43:if("+"==t)return e.PLUS;if("++"==t)return e.PREFIX_INC;break;case 45:if("-"==t)return e.MINUS;if("--"==t)return e.PREFIX_DEC;break;case 33:if("!"==t)return e.NOT;break;case 126:if("~"==t)return e.BITWISE_NOT}break;case o.DecoratorKind.OPERATOR_POSTFIX:switch(t.charCodeAt(0)){case 43:if("++"==t)return e.POSTFIX_INC;break;case 45:if("--"==t)return e.POSTFIX_DEC}}return e.INVALID},e.fromBinaryToken=function(n){switch(n){case s.Token.PLUS:case s.Token.PLUS_EQUALS:return e.ADD;case s.Token.MINUS:case s.Token.MINUS_EQUALS:return e.SUB;case s.Token.ASTERISK:case s.Token.ASTERISK_EQUALS:return e.MUL;case s.Token.SLASH:case s.Token.SLASH_EQUALS:return e.DIV;case s.Token.PERCENT:case s.Token.PERCENT_EQUALS:return e.REM;case s.Token.ASTERISK_ASTERISK:case s.Token.ASTERISK_ASTERISK_EQUALS:return e.POW;case s.Token.AMPERSAND:case s.Token.AMPERSAND_EQUALS:return e.BITWISE_AND;case s.Token.BAR:case s.Token.BAR_EQUALS:return e.BITWISE_OR;case s.Token.CARET:case s.Token.CARET_EQUALS:return e.BITWISE_XOR;case s.Token.LESSTHAN_LESSTHAN:case s.Token.LESSTHAN_LESSTHAN_EQUALS:return e.BITWISE_SHL;case s.Token.GREATERTHAN_GREATERTHAN:case s.Token.GREATERTHAN_GREATERTHAN_EQUALS:return e.BITWISE_SHR;case s.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:case s.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:return e.BITWISE_SHR_U;case s.Token.EQUALS_EQUALS:return e.EQ;case s.Token.EXCLAMATION_EQUALS:return e.NE;case s.Token.GREATERTHAN:return e.GT;case s.Token.GREATERTHAN_EQUALS:return e.GE;case s.Token.LESSTHAN:return e.LT;case s.Token.LESSTHAN_EQUALS:return e.LE}return e.INVALID},e.fromUnaryPrefixToken=function(n){switch(n){case s.Token.PLUS:return e.PLUS;case s.Token.MINUS:return e.MINUS;case s.Token.EXCLAMATION:return e.NOT;case s.Token.TILDE:return e.BITWISE_NOT;case s.Token.PLUS_PLUS:return e.PREFIX_INC;case s.Token.MINUS_MINUS:return e.PREFIX_DEC}return e.INVALID},e.fromUnaryPostfixToken=function(n){switch(n){case s.Token.PLUS_PLUS:return e.POSTFIX_INC;case s.Token.MINUS_MINUS:return e.POSTFIX_DEC}return e.INVALID}}(m=n.OperatorKind||(n.OperatorKind={}));class E extends i.DiagnosticEmitter{constructor(e,n=null){super(n),this.options=e,this.sources=[],this.diagnosticsOffset=0,this.nextClassId=0,this.nextSignatureId=0,this.initialized=!1,this.filesByName=new Map,this.elementsByName=new Map,this.elementsByDeclaration=new Map,this.instancesByName=new Map,this.wrapperClasses=new Map,this.managedClasses=new Map,this.uniqueSignatures=new Array(0),this._arrayBufferViewInstance=null,this._arrayBufferInstance=null,this._arrayPrototype=null,this._staticArrayPrototype=null,this._setPrototype=null,this._mapPrototype=null,this._functionPrototype=null,this._int8ArrayPrototype=null,this._int16ArrayPrototype=null,this._int32ArrayPrototype=null,this._int64ArrayPrototype=null,this._uint8ArrayPrototype=null,this._uint8ClampedArrayPrototype=null,this._uint16ArrayPrototype=null,this._uint32ArrayPrototype=null,this._uint64ArrayPrototype=null,this._float32ArrayPrototype=null,this._float64ArrayPrototype=null,this._stringInstance=null,this._allocInstance=null,this._reallocInstance=null,this._freeInstance=null,this._newInstance=null,this._renewInstance=null,this._linkInstance=null,this._collectInstance=null,this._visitInstance=null,this._typeinfoInstance=null,this._instanceofInstance=null,this._newBufferInstance=null,this._newArrayInstance=null,this._BLOCKInstance=null,this._OBJECTInstance=null,this.nativeDummySignature=null;var t=new o.Source(o.SourceKind.LIBRARY_ENTRY,r.LIBRARY_SUBST+".wasm","[native code]");this.nativeSource=t,this.parser=new p.Parser(this.diagnostics,this.sources),this.resolver=new u.Resolver(this);var i=new I(this,t);this.nativeFile=i,this.filesByName.set(i.internalName,i)}get arrayBufferViewInstance(){var e=this._arrayBufferViewInstance;return e||(this._arrayBufferViewInstance=e=this.requireClass(r.CommonNames.ArrayBufferView)),e}get arrayBufferInstance(){var e=this._arrayBufferInstance;return e||(this._arrayBufferInstance=e=this.requireClass(r.CommonNames.ArrayBuffer)),e}get arrayPrototype(){var e=this._arrayPrototype;return e||(this._arrayPrototype=e=this.require(r.CommonNames.Array,_.CLASS_PROTOTYPE)),e}get staticArrayPrototype(){var e=this._staticArrayPrototype;return e||(this._staticArrayPrototype=e=this.require(r.CommonNames.StaticArray,_.CLASS_PROTOTYPE)),e}get setPrototype(){var e=this._setPrototype;return e||(this._setPrototype=e=this.require(r.CommonNames.Set,_.CLASS_PROTOTYPE)),e}get mapPrototype(){var e=this._mapPrototype;return e||(this._mapPrototype=e=this.require(r.CommonNames.Map,_.CLASS_PROTOTYPE)),e}get functionPrototype(){var e=this._functionPrototype;return e||(this._functionPrototype=e=this.require(r.CommonNames.Function,_.CLASS_PROTOTYPE)),e}get int8ArrayPrototype(){var e=this._int8ArrayPrototype;return e||(this._int8ArrayPrototype=e=this.require(r.CommonNames.Int8Array,_.CLASS_PROTOTYPE)),e}get int16ArrayPrototype(){var e=this._int16ArrayPrototype;return e||(this._int16ArrayPrototype=e=this.require(r.CommonNames.Int16Array,_.CLASS_PROTOTYPE)),e}get int32ArrayPrototype(){var e=this._int32ArrayPrototype;return e||(this._int32ArrayPrototype=e=this.require(r.CommonNames.Int32Array,_.CLASS_PROTOTYPE)),e}get int64ArrayPrototype(){var e=this._int64ArrayPrototype;return e||(this._int64ArrayPrototype=e=this.require(r.CommonNames.Int64Array,_.CLASS_PROTOTYPE)),e}get uint8ArrayPrototype(){var e=this._uint8ArrayPrototype;return e||(this._uint8ArrayPrototype=e=this.require(r.CommonNames.Uint8Array,_.CLASS_PROTOTYPE)),e}get uint8ClampedArrayPrototype(){var e=this._uint8ClampedArrayPrototype;return e||(this._uint8ClampedArrayPrototype=e=this.require(r.CommonNames.Uint8ClampedArray,_.CLASS_PROTOTYPE)),e}get uint16ArrayPrototype(){var e=this._uint16ArrayPrototype;return e||(this._uint16ArrayPrototype=e=this.require(r.CommonNames.Uint16Array,_.CLASS_PROTOTYPE)),e}get uint32ArrayPrototype(){var e=this._uint32ArrayPrototype;return e||(this._uint32ArrayPrototype=e=this.require(r.CommonNames.Uint32Array,_.CLASS_PROTOTYPE)),e}get uint64ArrayPrototype(){var e=this._uint64ArrayPrototype;return e||(this._uint64ArrayPrototype=e=this.require(r.CommonNames.Uint64Array,_.CLASS_PROTOTYPE)),e}get float32ArrayPrototype(){var e=this._float32ArrayPrototype;return e||(this._float32ArrayPrototype=e=this.require(r.CommonNames.Float32Array,_.CLASS_PROTOTYPE)),e}get float64ArrayPrototype(){var e=this._float64ArrayPrototype;return e||(this._float64ArrayPrototype=e=this.require(r.CommonNames.Float64Array,_.CLASS_PROTOTYPE)),e}get stringInstance(){var e=this._stringInstance;return e||(this._stringInstance=e=this.requireClass(r.CommonNames.String)),e}get abortInstance(){var e=this.lookup(r.CommonNames.abort);return e&&e.kind==_.FUNCTION_PROTOTYPE?this.resolver.resolveFunction(e,null):null}get allocInstance(){var e=this._allocInstance;return e||(this._allocInstance=e=this.requireFunction(r.CommonNames.alloc)),e}get reallocInstance(){var e=this._reallocInstance;return e||(this._reallocInstance=e=this.requireFunction(r.CommonNames.realloc)),e}get freeInstance(){var e=this._freeInstance;return e||(this._freeInstance=e=this.requireFunction(r.CommonNames.free)),e}get newInstance(){var e=this._newInstance;return e||(this._newInstance=e=this.requireFunction(r.CommonNames.new_)),e}get renewInstance(){var e=this._renewInstance;return e||(this._renewInstance=e=this.requireFunction(r.CommonNames.renew)),e}get linkInstance(){var e=this._linkInstance;return e||(this._linkInstance=e=this.requireFunction(r.CommonNames.link)),e}get collectInstance(){var e=this._collectInstance;return e||(this._collectInstance=e=this.requireFunction(r.CommonNames.collect)),e}get visitInstance(){var e=this._visitInstance;return e||(this._visitInstance=e=this.requireFunction(r.CommonNames.visit)),e}get typeinfoInstance(){var e=this._typeinfoInstance;return e||(this._typeinfoInstance=e=this.requireFunction(r.CommonNames.typeinfo)),e}get instanceofInstance(){var e=this._instanceofInstance;return e||(this._instanceofInstance=e=this.requireFunction(r.CommonNames.instanceof_)),e}get newBufferInstance(){var e=this._newBufferInstance;return e||(this._newBufferInstance=e=this.requireFunction(r.CommonNames.newBuffer)),e}get newArrayInstance(){var e=this._newArrayInstance;return e||(this._newArrayInstance=e=this.requireFunction(r.CommonNames.newArray)),e}get BLOCKInstance(){var e=this._BLOCKInstance;return e||(this._BLOCKInstance=e=this.requireClass(r.CommonNames.BLOCK)),e}get OBJECTInstance(){var e=this._OBJECTInstance;return e||(this._OBJECTInstance=e=this.requireClass(r.CommonNames.OBJECT)),e}get isWasi(){return this.elementsByName.has(r.CommonNames.ASC_WASI)}getSource(e){var n=this.sources;for(let t=0;t<n.length;++t){let r=n[t];if(r.internalPath==e)return r.text}return null}get blockOverhead(){return this.BLOCKInstance.nextMemoryOffset}get objectOverhead(){return this.OBJECTInstance.nextMemoryOffset-this.blockOverhead+d&-16}get totalOverhead(){return this.blockOverhead+this.objectOverhead}computeBlockStart(e){var n=this.blockOverhead;return(e+n+d&-16)-n}computeBlockStart64(e){var n=i64_new(this.blockOverhead);return i64_sub(i64_align(i64_add(e,n),16),n)}computeBlockSize(e,n){n&&(e+=this.objectOverhead);var t=this.computeBlockStart(e),r=this.blockOverhead,i=(3*this.options.usizeType.byteSize+r+d&-16)-r;if(t<i&&(t=i),t>=1<<30||0!=(3&t))throw new Error("invalid block size");return t}makeNativeVariableDeclaration(e,n=r.CommonFlags.NONE){var t=this.nativeSource.range;return o.Node.createVariableDeclaration(o.Node.createIdentifierExpression(e,t),null,n,null,null,t)}makeNativeTypeDeclaration(e,n=r.CommonFlags.NONE){var t=this.nativeSource.range,i=o.Node.createIdentifierExpression(e,t);return o.Node.createTypeDeclaration(i,null,n,null,o.Node.createOmittedType(t),t)}makeNativeFunctionDeclaration(e,n=r.CommonFlags.NONE){var t=this.nativeSource.range,i=this.nativeDummySignature;return i||(this.nativeDummySignature=i=o.Node.createFunctionType([],o.Node.createNamedType(o.Node.createSimpleTypeName(r.CommonNames.void_,t),null,!1,t),null,!1,t)),o.Node.createFunctionDeclaration(o.Node.createIdentifierExpression(e,t),null,n,null,i,null,0,t)}makeNativeNamespaceDeclaration(e,n=r.CommonFlags.NONE){var t=this.nativeSource.range;return o.Node.createNamespaceDeclaration(o.Node.createIdentifierExpression(e,t),null,n,[],t)}makeNativeFunction(e,n,t=this.nativeFile,i=r.CommonFlags.NONE,a=y.NONE){return new w(e,new R(e,t,this.makeNativeFunctionDeclaration(e,i),a),null,n)}getElementByDeclaration(e){var n=this.elementsByDeclaration;return n.has(e)?assert(n.get(e)):null}initialize(){if(!this.initialized){this.initialized=!0;var e=this.options;this.registerNativeType(r.CommonNames.i8,a.Type.i8),this.registerNativeType(r.CommonNames.i16,a.Type.i16),this.registerNativeType(r.CommonNames.i32,a.Type.i32),this.registerNativeType(r.CommonNames.i64,a.Type.i64),this.registerNativeType(r.CommonNames.isize,e.isizeType),this.registerNativeType(r.CommonNames.u8,a.Type.u8),this.registerNativeType(r.CommonNames.u16,a.Type.u16),this.registerNativeType(r.CommonNames.u32,a.Type.u32),this.registerNativeType(r.CommonNames.u64,a.Type.u64),this.registerNativeType(r.CommonNames.usize,e.usizeType),this.registerNativeType(r.CommonNames.bool,a.Type.bool),this.registerNativeType(r.CommonNames.f32,a.Type.f32),this.registerNativeType(r.CommonNames.f64,a.Type.f64),this.registerNativeType(r.CommonNames.void_,a.Type.void),this.registerNativeType(r.CommonNames.number,a.Type.f64),this.registerNativeType(r.CommonNames.boolean,a.Type.bool),this.nativeFile.add(r.CommonNames.native,new S(r.CommonNames.native,this.nativeFile,this.makeNativeTypeDeclaration(r.CommonNames.native,r.CommonFlags.EXPORT|r.CommonFlags.GENERIC),y.BUILTIN)),this.nativeFile.add(r.CommonNames.indexof,new S(r.CommonNames.indexof,this.nativeFile,this.makeNativeTypeDeclaration(r.CommonNames.indexof,r.CommonFlags.EXPORT|r.CommonFlags.GENERIC),y.BUILTIN)),this.nativeFile.add(r.CommonNames.valueof,new S(r.CommonNames.valueof,this.nativeFile,this.makeNativeTypeDeclaration(r.CommonNames.valueof,r.CommonFlags.EXPORT|r.CommonFlags.GENERIC),y.BUILTIN)),this.nativeFile.add(r.CommonNames.returnof,new S(r.CommonNames.returnof,this.nativeFile,this.makeNativeTypeDeclaration(r.CommonNames.returnof,r.CommonFlags.EXPORT|r.CommonFlags.GENERIC),y.BUILTIN)),this.registerNativeType(r.CommonNames.v128,a.Type.v128),this.registerNativeType(r.CommonNames.funcref,a.Type.funcref),this.registerNativeType(r.CommonNames.externref,a.Type.externref),this.registerNativeType(r.CommonNames.exnref,a.Type.exnref),this.registerNativeType(r.CommonNames.anyref,a.Type.anyref),this.registerConstantInteger(r.CommonNames.ASC_TARGET,a.Type.i32,i64_new(e.isWasm64?r.Target.WASM64:r.Target.WASM32)),this.registerConstantInteger(r.CommonNames.ASC_NO_ASSERT,a.Type.bool,i64_new(e.noAssert?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_MEMORY_BASE,a.Type.i32,i64_new(e.memoryBase,0)),this.registerConstantInteger(r.CommonNames.ASC_TABLE_BASE,a.Type.i32,i64_new(e.tableBase,0)),this.registerConstantInteger(r.CommonNames.ASC_OPTIMIZE_LEVEL,a.Type.i32,i64_new(e.optimizeLevelHint,0)),this.registerConstantInteger(r.CommonNames.ASC_SHRINK_LEVEL,a.Type.i32,i64_new(e.shrinkLevelHint,0)),this.registerConstantInteger(r.CommonNames.ASC_LOW_MEMORY_LIMIT,a.Type.i32,i64_new(e.lowMemoryLimit,0)),this.registerConstantInteger(r.CommonNames.ASC_EXPORT_RUNTIME,a.Type.bool,i64_new(e.exportRuntime?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_SIGN_EXTENSION,a.Type.bool,i64_new(e.hasFeature(1)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_MUTABLE_GLOBALS,a.Type.bool,i64_new(e.hasFeature(2)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_NONTRAPPING_F2I,a.Type.bool,i64_new(e.hasFeature(4)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_BULK_MEMORY,a.Type.bool,i64_new(e.hasFeature(8)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_SIMD,a.Type.bool,i64_new(e.hasFeature(16)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_THREADS,a.Type.bool,i64_new(e.hasFeature(32)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_EXCEPTION_HANDLING,a.Type.bool,i64_new(e.hasFeature(64)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_TAIL_CALLS,a.Type.bool,i64_new(e.hasFeature(128)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_REFERENCE_TYPES,a.Type.bool,i64_new(e.hasFeature(256)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_MULTI_VALUE,a.Type.bool,i64_new(e.hasFeature(512)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_GC,a.Type.bool,i64_new(e.hasFeature(1024)?1:0,0)),this.registerConstantInteger(r.CommonNames.ASC_FEATURE_MEMORY64,a.Type.bool,i64_new(e.hasFeature(2048)?1:0,0));var n=new Array,t=new Map,l=new Map,u=new Array,c=new Array;for(let e=0,r=this.sources.length;e<r;++e){let r=this.sources[e],i=new I(this,r);this.filesByName.set(i.internalName,i);let a=r.statements;for(let e=0,r=a.length;e<r;++e){let r=a[e];switch(r.kind){case o.NodeKind.EXPORT:this.initializeExports(r,i,t,l);break;case o.NodeKind.EXPORTDEFAULT:this.initializeExportDefault(r,i,u,c);break;case o.NodeKind.IMPORT:this.initializeImports(r,i,n,t);break;case o.NodeKind.VARIABLE:this.initializeVariables(r,i);break;case o.NodeKind.CLASSDECLARATION:this.initializeClass(r,i,u,c);break;case o.NodeKind.ENUMDECLARATION:this.initializeEnum(r,i);break;case o.NodeKind.FUNCTIONDECLARATION:this.initializeFunction(r,i);break;case o.NodeKind.INTERFACEDECLARATION:this.initializeInterface(r,i,u);break;case o.NodeKind.NAMESPACEDECLARATION:this.initializeNamespace(r,i,u,c);break;case o.NodeKind.TYPEDECLARATION:this.initializeTypeDefinition(r,i)}}}for(let e=Map_keys(l),n=0,t=e.length;n<t;++n){let t=e[n],r=assert(l.get(t));for(let e=0,n=r.length;e<n;++e){let n=unchecked(r[e]),a=this.lookupForeignFile(n.foreignPath,n.foreignPathAlt);a?t.ensureExportStar(a):this.error(i.DiagnosticCode.File_0_not_found,n.pathLiteral.range,n.pathLiteral.value)}}for(;;){let e=0,r=!1;for(;e<n.length;){let i=n[e],a=i.localIdentifier,s=i.foreignIdentifier;if(s){let o=this.lookupForeign(s.text,i.foreignPath,i.foreignPathAlt,t);o?(i.localFile.add(a.text,o,a),n.splice(e,1),r=!0):++e}else{let t=this.lookupForeignFile(i.foreignPath,i.foreignPathAlt);if(t){let s=i.localFile,o=a.text;s.add(o,t.asAliasNamespace(o,s,a),a),n.splice(e,1),r=!0}else++e,assert(!1)}}if(!r){for(let e=0,t=n.length;e<t;++e){let t=n[e],r=t.foreignIdentifier;r&&this.error(i.DiagnosticCode.Module_0_has_no_exported_member_1,r.range,t.foreignPath,r.text)}break}}for(let e=Map_keys(t),n=0,r=e.length;n<r;++n){let r=unchecked(e[n]),a=assert(t.get(r));for(let e=Map_keys(a),n=0,s=e.length;n<s;++n){let s=unchecked(e[n]),o=assert(a.get(s)),l=o.localIdentifier.text,u=o.foreignPath;if(u){let e=this.lookupForeign(l,u,assert(o.foreignPathAlt),t);e?r.ensureExport(s,e):this.error(i.DiagnosticCode.Module_0_has_no_exported_member_1,o.localIdentifier.range,u,l)}else{let e=r.lookupInSelf(l);if(e)r.ensureExport(s,e);else{let e=this.lookup(l);null!==e&&v(e.kind)?r.ensureExport(s,e):this.error(i.DiagnosticCode.Module_0_has_no_exported_member_1,o.foreignIdentifier.range,r.internalName,o.foreignIdentifier.text)}}}}assert(0==this.arrayBufferInstance.id),assert(1==this.stringInstance.id),assert(2==this.arrayBufferViewInstance.id),this.registerWrapperClass(a.Type.i8,r.CommonNames.I8),this.registerWrapperClass(a.Type.i16,r.CommonNames.I16),this.registerWrapperClass(a.Type.i32,r.CommonNames.I32),this.registerWrapperClass(a.Type.i64,r.CommonNames.I64),this.registerWrapperClass(e.isizeType,r.CommonNames.Isize),this.registerWrapperClass(a.Type.u8,r.CommonNames.U8),this.registerWrapperClass(a.Type.u16,r.CommonNames.U16),this.registerWrapperClass(a.Type.u32,r.CommonNames.U32),this.registerWrapperClass(a.Type.u64,r.CommonNames.U64),this.registerWrapperClass(e.usizeType,r.CommonNames.Usize),this.registerWrapperClass(a.Type.bool,r.CommonNames.Bool),this.registerWrapperClass(a.Type.f32,r.CommonNames.F32),this.registerWrapperClass(a.Type.f64,r.CommonNames.F64),e.hasFeature(16)&&this.registerWrapperClass(a.Type.v128,r.CommonNames.V128),e.hasFeature(256)&&(this.registerWrapperClass(a.Type.funcref,r.CommonNames.Funcref),this.registerWrapperClass(a.Type.externref,r.CommonNames.Externref),e.hasFeature(64)&&this.registerWrapperClass(a.Type.exnref,r.CommonNames.Exnref),e.hasFeature(1024)&&this.registerWrapperClass(a.Type.anyref,r.CommonNames.Anyref));var p=this.resolver;for(let e=0,n=u.length;e<n;++e){let n=u[e],t=assert(n.extendsNode),r=p.resolveTypeName(t.name,n.parent);if(r)if(n.kind==_.CLASS_PROTOTYPE)if(r.kind==_.CLASS_PROTOTYPE){let e=r;e.hasDecorator(y.FINAL)&&this.error(i.DiagnosticCode.Class_0_is_final_and_cannot_be_extended,t.range,e.identifierNode.text),e.hasDecorator(y.UNMANAGED)!=n.hasDecorator(y.UNMANAGED)&&this.error(i.DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,s.Range.join(n.identifierNode.range,t.range)),n.basePrototype=e}else this.error(i.DiagnosticCode.A_class_may_only_extend_another_class,t.range);else n.kind==_.INTERFACE_PROTOTYPE&&(r.kind==_.INTERFACE_PROTOTYPE?n.basePrototype=r:this.error(i.DiagnosticCode.An_interface_can_only_extend_an_interface,t.range))}for(let e=0,n=c.length;e<n;++e){let n=c[e],t=assert(n.implementsNodes);for(let e=0,r=t.length;e<r;++e){let r=t[e],a=p.resolveTypeName(r.name,n.parent);if(a)if(a.kind==_.INTERFACE_PROTOTYPE){let e=a,t=n.interfacePrototypes;t||(n.interfacePrototypes=t=new Array),t.push(e)}else this.error(i.DiagnosticCode.A_class_can_only_implement_an_interface,r.range)}}for(let e=0,n=u.length;e<n;++e){let n=u[e],t=n.basePrototype;t&&this.markVirtuals(n,t)}for(let e=0,n=c.length;e<n;++e){let n=c[e],t=n.basePrototype,r=n.interfacePrototypes;if(t&&this.markVirtuals(n,t),r)for(let e=0,t=r.length;e<t;++e)this.markVirtuals(n,r[e])}{let n=e.globalAliases;n||(n=new Map);let t=this.isWasi;n.has(r.CommonNames.abort)||n.set(r.CommonNames.abort,t?f.BuiltinNames.wasiAbort:f.BuiltinNames.abort),n.has(r.CommonNames.trace)||n.set(r.CommonNames.trace,t?f.BuiltinNames.wasiTrace:f.BuiltinNames.trace),n.has(r.CommonNames.seed)||n.set(r.CommonNames.seed,t?f.BuiltinNames.wasiSeed:f.BuiltinNames.seed),n.has(r.CommonNames.Math)||n.set(r.CommonNames.Math,r.CommonNames.NativeMath),n.has(r.CommonNames.Mathf)||n.set(r.CommonNames.Mathf,r.CommonNames.NativeMathf);for(let e=Map_keys(n),t=0,r=e.length;t<r;++t){let r=unchecked(e[t]),i=changetype(n.get(r));if(assert(null!=i),!i.length){this.elementsByName.delete(r);continue}let s=i.charCodeAt(0);if(s>=48&&s<=57)this.registerConstantInteger(r,a.Type.i32,i64_new(parseInt(i,10)));else{let e=this.elementsByName;if(!e.has(i))throw new Error("no such global element: "+i);e.set(r,assert(e.get(i)))}}}for(let e=Map_values(this.filesByName),n=0,t=e.length;n<t;++n){let t=unchecked(e[n]);t.source.sourceKind==o.SourceKind.USER_ENTRY&&this.markModuleExports(t)}}}markVirtuals(e,n){var t=e.instanceMembers;if(t)for(;;){let e=n.instanceMembers;if(e)for(let n=Map_values(t),a=0,s=n.length;a<s;++a){let t=n[a];if(!t.isAny(r.CommonFlags.CONSTRUCTOR|r.CommonFlags.PRIVATE)&&e.has(t.name)){let n=assert(e.get(t.name));if(t.kind==_.FUNCTION_PROTOTYPE&&n.kind==_.FUNCTION_PROTOTYPE){let e=t,a=n;e.visibilityEquals(a)||this.errorRelated(i.DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,e.identifierNode.range,a.identifierNode.range),n.set(r.CommonFlags.VIRTUAL);let s=a.overloads;s||(a.overloads=s=new Set),s.add(t);let o=a.instances;if(o)for(let e=Map_values(o),n=0,t=e.length;n<t;++n)e[n].set(r.CommonFlags.VIRTUAL)}else if(t.kind==_.PROPERTY_PROTOTYPE&&n.kind==_.PROPERTY_PROTOTYPE){let e=t,a=n;e.visibilityEquals(a)||this.errorRelated(i.DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,e.identifierNode.range,a.identifierNode.range),a.set(r.CommonFlags.VIRTUAL);let s=a.getterPrototype;if(s){s.set(r.CommonFlags.VIRTUAL);let n=e.getterPrototype;if(n){let e=s.overloads;e||(s.overloads=e=new Set),e.add(n)}let t=s.instances;if(t)for(let e=Map_values(t),n=0,i=e.length;n<i;++n)e[n].set(r.CommonFlags.VIRTUAL)}let o=a.setterPrototype;if(null!==o&&null!==e.setterPrototype){o.set(r.CommonFlags.VIRTUAL);let n=e.setterPrototype;if(n){let e=o.overloads;e||(o.overloads=e=new Set),e.add(n)}let t=o.instances;if(t)for(let e=Map_values(t),n=0,i=e.length;n<i;++n)e[n].set(r.CommonFlags.VIRTUAL)}}else this.errorRelated(i.DiagnosticCode.Duplicate_identifier_0,t.identifierNode.range,n.identifierNode.range)}}let a=n.basePrototype;if(!a)break;n=a}}lookup(e){var n=this.elementsByName;return n.has(e)?assert(n.get(e)):null}require(e,n){var t=this.lookup(e);if(!t)throw new Error("Missing standard library component: "+e);if(t.kind!=n)throw Error("Invalid standard library component kind: "+e);return t}requireGlobal(e){return this.require(e,_.GLOBAL)}requireClass(e){var n=this.require(e,_.CLASS_PROTOTYPE),t=this.resolver.resolveClass(n,null);if(!t)throw new Error("Invalid standard library class: "+e);return t}requireFunction(e,n=null){var t=this.require(e,_.FUNCTION_PROTOTYPE),r=this.resolver.resolveFunction(t,n);if(!r)throw new Error("Invalid standard library function: "+e);return r}markModuleExports(e){var n=e.exports;if(n)for(let e=Map_values(n),t=0,r=e.length;t<r;++t){let n=unchecked(e[t]);this.markModuleExport(n)}var t=e.exportsStar;if(t)for(let e=0,n=t.length;e<n;++e)this.markModuleExports(t[e])}markModuleExport(e){switch(e.set(r.CommonFlags.MODULE_EXPORT),e.kind){case _.CLASS_PROTOTYPE:{let n=e.instanceMembers;if(n)for(let e=Map_values(n),t=0,r=e.length;t<r;++t){let n=unchecked(e[t]);this.markModuleExport(n)}break}case _.PROPERTY_PROTOTYPE:{let n=e,t=n.getterPrototype;t&&this.markModuleExport(t);let r=n.setterPrototype;r&&this.markModuleExport(r);break}case _.PROPERTY:case _.FUNCTION:case _.FIELD:case _.CLASS:assert(!1)}var n=e.members;if(n)for(let e=Map_values(n),t=0,r=e.length;t<r;++t){let n=unchecked(e[t]);this.markModuleExport(n)}}registerNativeType(e,n){var t=new S(e,this.nativeFile,this.makeNativeTypeDeclaration(e,r.CommonFlags.EXPORT),y.BUILTIN);t.setType(n),this.nativeFile.add(e,t)}registerWrapperClass(e,n){var t=this.wrapperClasses;assert(!e.isInternalReference&&!t.has(e));var r=assert(this.lookup(n));assert(r.kind==_.CLASS_PROTOTYPE);var i=assert(this.resolver.resolveClass(r,null));i.wrappedType=e,t.set(e,i)}registerConstantInteger(e,n,t){assert(n.isIntegerInclReference);var i=new B(e,this.nativeFile,y.NONE,this.makeNativeVariableDeclaration(e,r.CommonFlags.CONST|r.CommonFlags.EXPORT));i.setConstantIntegerValue(t,n),this.nativeFile.add(e,i)}registerConstantFloat(e,n,t){assert(n.isFloatValue);var i=new B(e,this.nativeFile,y.NONE,this.makeNativeVariableDeclaration(e,r.CommonFlags.CONST|r.CommonFlags.EXPORT));i.setConstantFloatValue(t,n),this.nativeFile.add(e,i)}ensureGlobal(e,n){var t=this.elementsByName;if(t.has(e)){let r=assert(t.get(e));if(r!==n){let t=K(r,n);if(!t)return v(r.kind)?this.errorRelated(i.DiagnosticCode.Duplicate_identifier_0,n.identifierNode.range,r.declaration.name.range,e):this.error(i.DiagnosticCode.Duplicate_identifier_0,n.identifierNode.range,e),n;n=t}}return t.set(e,n),n}lookupForeignFile(e,n){var t=this.filesByName;return t.has(e)?assert(t.get(e)):t.has(n)?assert(t.get(n)):null}lookupForeign(e,n,t,r){for(;;){let i=this.lookupForeignFile(n,t);if(!i)return null;let a=i.lookupExport(e);if(a)return a;if(r.has(i)){let s=assert(r.get(i));if(s.has(e)){let r=assert(s.get(e)),o=r.foreignPath;if(o){e=r.localIdentifier.text,n=o,t=assert(r.foreignPathAlt);continue}if(a=i.lookupInSelf(r.localIdentifier.text),a)return a}}break}return null}checkDecorators(e,n){var t=y.NONE;if(e)for(let r=0,a=e.length;r<a;++r){let a=e[r],s=o.DecoratorKind.fromNode(a.name),l=y.fromKind(s);l&&(l==y.BUILTIN?n&l||a.range.source.isLibrary?t|=l:this.error(i.DiagnosticCode.Decorator_0_is_not_valid_here,a.range,a.name.range.toString()):n&l?t&l?this.error(i.DiagnosticCode.Duplicate_decorator,a.range):t|=l:this.error(i.DiagnosticCode.Decorator_0_is_not_valid_here,a.range,a.name.range.toString()))}return t}initializeClass(e,n,t,a){var l=e.name.text,u=new U(l,n,e,this.checkDecorators(e.decorators,y.GLOBAL|y.FINAL|y.UNMANAGED));if(!n.add(l,u))return null;var c=e.implementsTypes;if(c){let n=c.length;n&&(u.hasDecorator(y.UNMANAGED)?this.error(i.DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,s.Range.join(e.name.range,c[n-1].range)):a.push(u))}e.extendsType&&t.push(u);var p=e.members;for(let e=0,n=p.length;e<n;++e){let n=p[e];switch(n.kind){case o.NodeKind.FIELDDECLARATION:this.initializeField(n,u);break;case o.NodeKind.METHODDECLARATION:{let e=n;if(n.isAny(r.CommonFlags.GET|r.CommonFlags.SET))this.initializeProperty(e,u);else{let n=this.initializeMethod(e,u);null!==n&&e.name.kind==o.NodeKind.CONSTRUCTOR&&(u.constructorPrototype=n)}break}case o.NodeKind.INDEXSIGNATURE:break;default:assert(!1)}}return u}initializeField(e,n){var t,i=e.name.text,a=e.decorators,s=y.UNSAFE;if(n.is(r.CommonFlags.AMBIENT)&&(s|=y.EXTERNAL),e.is(r.CommonFlags.STATIC)){if(assert(n.kind!=_.INTERFACE_PROTOTYPE),s|=y.LAZY,e.is(r.CommonFlags.READONLY)&&(s|=y.INLINE),t=new B(i,n,this.checkDecorators(a,s),e),!n.add(i,t))return}else if(assert(!e.isAny(r.CommonFlags.ABSTRACT|r.CommonFlags.GET|r.CommonFlags.SET)),t=new z(i,n,e,this.checkDecorators(a,s)),!n.addInstance(i,t))return}initializeMethod(e,n){var t=e.name.text,i=e.is(r.CommonFlags.STATIC),a=y.INLINE|y.UNSAFE;e.is(r.CommonFlags.GENERIC)||(a|=y.OPERATOR_BINARY|y.OPERATOR_PREFIX|y.OPERATOR_POSTFIX),n.is(r.CommonFlags.AMBIENT)&&(a|=y.EXTERNAL);var s=new R(t,n,e,this.checkDecorators(e.decorators,a));if(i){if(assert(e.name.kind!=o.NodeKind.CONSTRUCTOR),!n.add(t,s))return null}else if(!n.addInstance(t,s))return null;return this.checkOperatorOverloads(e.decorators,s,n),s}checkOperatorOverloads(e,n,t){if(e)for(let r=0,a=e.length;r<a;++r){let a=e[r];switch(a.decoratorKind){case o.DecoratorKind.OPERATOR:case o.DecoratorKind.OPERATOR_BINARY:case o.DecoratorKind.OPERATOR_PREFIX:case o.DecoratorKind.OPERATOR_POSTFIX:{let e=a.args,r=e?e.length:0;if(1==r){let e=a.args[0];if(e.isLiteralKind(o.LiteralKind.STRING)){let r=e.value,s=m.fromDecorator(a.decoratorKind,r);if(s==m.INVALID)this.error(i.DiagnosticCode._0_is_not_a_valid_operator,e.range,r);else{let r=t.overloadPrototypes;r.has(s)?this.error(i.DiagnosticCode.Duplicate_function_implementation,e.range):(n.operatorKind=s,r.set(s,n))}}else this.error(i.DiagnosticCode.String_literal_expected,e.range)}else this.error(i.DiagnosticCode.Expected_0_arguments_but_got_1,a.range,"1",r.toString())}}}}ensureProperty(e,n){var t=e.name.text;if(e.is(r.CommonFlags.STATIC)){let r=n.members;if(null===r||!r.has(t)){let r=new P(t,n,e);return n.add(t,r)?r:null}{let e=assert(r.get(t));if(e.kind==_.PROPERTY_PROTOTYPE)return e}}else{let r=n.instanceMembers;if(null===r||!r.has(t)){let r=new P(t,n,e);return n.addInstance(t,r)?r:null}{let e=assert(r.get(t));if(e.kind==_.PROPERTY_PROTOTYPE)return e}}return this.error(i.DiagnosticCode.Duplicate_property_0,e.name.range,t),null}initializeProperty(e,n){var t=this.ensureProperty(e,n);if(t){var a=e.name.text,s=e.is(r.CommonFlags.GET);if(s){if(t.getterPrototype)return void this.error(i.DiagnosticCode.Duplicate_property_0,e.name.range,a)}else if(t.setterPrototype)return void this.error(i.DiagnosticCode.Duplicate_property_0,e.name.range,a);var o=new R((s?r.GETTER_PREFIX:r.SETTER_PREFIX)+a,t,e,this.checkDecorators(e.decorators,y.INLINE|y.UNSAFE));s?t.getterPrototype=o:t.setterPrototype=o}}initializeEnum(e,n){var t=e.name.text,r=new O(t,n,e,this.checkDecorators(e.decorators,y.GLOBAL|y.INLINE|y.LAZY));if(!n.add(t,r))return null;var i=e.values;for(let e=0,n=i.length;e<n;++e)this.initializeEnumValue(i[e],r);return r}initializeEnumValue(e,n){var t=e.name.text,r=new L(t,n,e,this.checkDecorators(e.decorators,y.NONE));n.add(t,r)}initializeExports(e,n,t,i){var a=e.members;if(a)for(let r=0,i=a.length;r<i;++r)this.initializeExport(a[r],n,e.internalPath,t);else{let t;i.has(n)?t=assert(i.get(n)):i.set(n,t=[]);let a=e.internalPath;t.push(new x(a,a.endsWith(r.INDEX_SUFFIX)?a.substring(0,a.length-r.INDEX_SUFFIX.length):a+r.INDEX_SUFFIX,assert(e.path)))}}initializeExport(e,n,t,a){var s=e.localName.text,o=e.exportedName.text,l=n.lookupExport(o);if(l)this.error(i.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,e.exportedName.range,o);else if(null===t)if(l=n.lookupInSelf(s))n.ensureExport(o,l);else{let t;a.has(n)?t=assert(a.get(n)):a.set(n,t=new Map),t.set(o,new g(e.localName,e.exportedName,null,null))}else{let i;a.has(n)?i=assert(a.get(n)):a.set(n,i=new Map),i.set(o,new g(e.localName,e.exportedName,t,t.endsWith(r.INDEX_SUFFIX)?t.substring(0,t.length-r.INDEX_SUFFIX.length):t+r.INDEX_SUFFIX))}}initializeExportDefault(e,n,t,r){var a=e.declaration,s=null;switch(a.kind){case o.NodeKind.ENUMDECLARATION:s=this.initializeEnum(a,n);break;case o.NodeKind.FUNCTIONDECLARATION:s=this.initializeFunction(a,n);break;case o.NodeKind.CLASSDECLARATION:s=this.initializeClass(a,n,t,r);break;case o.NodeKind.INTERFACEDECLARATION:s=this.initializeInterface(a,n,t);break;case o.NodeKind.NAMESPACEDECLARATION:s=this.initializeNamespace(a,n,t,r);break;default:assert(!1)}if(s){let e=n.exports;if(e){if(e.has("default")){let n=assert(e.get("default"));return void this.errorRelated(i.DiagnosticCode.Duplicate_identifier_0,a.name.range,n.declaration.name.range,"default")}}else n.exports=e=new Map;e.set("default",s)}}initializeImports(e,n,t,i){var a=e.declarations;if(a)for(let r=0,s=a.length;r<s;++r)this.initializeImport(a[r],n,e.internalPath,t,i);else{let i=e.namespaceName;i&&t.push(new h(n,i,null,e.internalPath,e.internalPath+r.INDEX_SUFFIX))}}initializeImport(e,n,t,i,a){var s=t.endsWith(r.INDEX_SUFFIX)?t.substring(0,t.length-r.INDEX_SUFFIX.length):t+r.INDEX_SUFFIX,o=this.lookupForeign(e.foreignName.text,t,s,a);o?n.add(e.name.text,o,e.name):i.push(new h(n,e.name,e.foreignName,t,s))}initializeFunction(e,n){var t=e.name.text,i=y.UNSAFE|y.BUILTIN;e.is(r.CommonFlags.AMBIENT)?i|=y.EXTERNAL:(i|=y.INLINE,(e.range.source.isLibrary||e.is(r.CommonFlags.EXPORT))&&(i|=y.LAZY)),e.is(r.CommonFlags.INSTANCE)||n.kind!=_.CLASS_PROTOTYPE&&(i|=y.GLOBAL);var a=new R(t,n,e,this.checkDecorators(e.decorators,i));return n.add(t,a)?a:null}initializeInterface(e,n,t){var i=e.name.text,a=new G(i,n,e,this.checkDecorators(e.decorators,y.GLOBAL));if(!n.add(i,a))return null;e.extendsType&&t.push(a);var s=e.members;for(let e=0,n=s.length;e<n;++e){let n=s[e];switch(n.kind){case o.NodeKind.FIELDDECLARATION:this.initializeFieldAsProperty(n,a);break;case o.NodeKind.METHODDECLARATION:{let e=n;n.isAny(r.CommonFlags.GET|r.CommonFlags.SET)?this.initializeProperty(e,a):this.initializeMethod(e,a);break}default:assert(!1)}}return a}initializeFieldAsProperty(e,n){var t=e.type;t||(t=o.Node.createOmittedType(e.name.range.atEnd)),this.initializeProperty(o.Node.createMethodDeclaration(e.name,e.decorators,e.flags|r.CommonFlags.GET,null,o.Node.createFunctionType([],t,null,!1,e.range),null,e.range),n),e.is(r.CommonFlags.READONLY)||this.initializeProperty(o.Node.createMethodDeclaration(e.name,e.decorators,e.flags|r.CommonFlags.SET,null,o.Node.createFunctionType([o.Node.createParameter(o.ParameterKind.DEFAULT,e.name,t,null,e.name.range)],o.Node.createOmittedType(e.name.range.atEnd),null,!1,e.range),null,e.range),n)}initializeNamespace(e,n,t,r){var i=e.name.text,a=new N(i,n,e,this.checkDecorators(e.decorators,y.GLOBAL));if(!n.add(i,a))return null;var s=assert(n.lookupInSelf(i)),l=e.members;for(let e=0,n=l.length;e<n;++e){let n=l[e];switch(n.kind){case o.NodeKind.CLASSDECLARATION:this.initializeClass(n,a,t,r);break;case o.NodeKind.ENUMDECLARATION:this.initializeEnum(n,a);break;case o.NodeKind.FUNCTIONDECLARATION:this.initializeFunction(n,a);break;case o.NodeKind.INTERFACEDECLARATION:this.initializeInterface(n,a,t);break;case o.NodeKind.NAMESPACEDECLARATION:this.initializeNamespace(n,a,t,r);break;case o.NodeKind.TYPEDECLARATION:this.initializeTypeDefinition(n,a);break;case o.NodeKind.VARIABLE:this.initializeVariables(n,a);break;default:assert(!1)}}return a!=s&&H(a,s),s}initializeTypeDefinition(e,n){var t=e.name.text,r=new S(t,n,e,this.checkDecorators(e.decorators,y.NONE));n.add(t,r)}initializeVariables(e,n){var t=e.declarations;for(let e=0,i=t.length;e<i;++e){let i=t[e],a=i.name.text,s=y.GLOBAL|y.LAZY;i.is(r.CommonFlags.DECLARE)&&(s|=y.EXTERNAL),i.is(r.CommonFlags.CONST)&&(s|=y.INLINE);let o=new B(a,n,this.checkDecorators(i.decorators,s),i);n.add(a,o)}}}n.Program=E,function(e){e[e.GLOBAL=0]="GLOBAL",e[e.LOCAL=1]="LOCAL",e[e.ENUM=2]="ENUM",e[e.ENUMVALUE=3]="ENUMVALUE",e[e.FUNCTION_PROTOTYPE=4]="FUNCTION_PROTOTYPE",e[e.FUNCTION=5]="FUNCTION",e[e.FUNCTION_TARGET=6]="FUNCTION_TARGET",e[e.CLASS_PROTOTYPE=7]="CLASS_PROTOTYPE",e[e.CLASS=8]="CLASS",e[e.INTERFACE_PROTOTYPE=9]="INTERFACE_PROTOTYPE",e[e.INTERFACE=10]="INTERFACE",e[e.FIELD_PROTOTYPE=11]="FIELD_PROTOTYPE",e[e.FIELD=12]="FIELD",e[e.PROPERTY_PROTOTYPE=13]="PROPERTY_PROTOTYPE",e[e.PROPERTY=14]="PROPERTY",e[e.NAMESPACE=15]="NAMESPACE",e[e.FILE=16]="FILE",e[e.TYPEDEFINITION=17]="TYPEDEFINITION",e[e.INDEXSIGNATURE=18]="INDEXSIGNATURE"}(_=n.ElementKind||(n.ElementKind={})),function(e){e[e.NONE=0]="NONE",e[e.GLOBAL=1]="GLOBAL",e[e.OPERATOR_BINARY=2]="OPERATOR_BINARY",e[e.OPERATOR_PREFIX=4]="OPERATOR_PREFIX",e[e.OPERATOR_POSTFIX=8]="OPERATOR_POSTFIX",e[e.UNMANAGED=16]="UNMANAGED",e[e.FINAL=32]="FINAL",e[e.INLINE=64]="INLINE",e[e.EXTERNAL=128]="EXTERNAL",e[e.BUILTIN=256]="BUILTIN",e[e.LAZY=512]="LAZY",e[e.UNSAFE=1024]="UNSAFE"}(y=n.DecoratorFlags||(n.DecoratorFlags={})),function(e){e.fromKind=function(n){switch(n){case o.DecoratorKind.GLOBAL:return e.GLOBAL;case o.DecoratorKind.OPERATOR:case o.DecoratorKind.OPERATOR_BINARY:return e.OPERATOR_BINARY;case o.DecoratorKind.OPERATOR_PREFIX:return e.OPERATOR_PREFIX;case o.DecoratorKind.OPERATOR_POSTFIX:return e.OPERATOR_POSTFIX;case o.DecoratorKind.UNMANAGED:return e.UNMANAGED;case o.DecoratorKind.FINAL:return e.FINAL;case o.DecoratorKind.INLINE:return e.INLINE;case o.DecoratorKind.EXTERNAL:return e.EXTERNAL;case o.DecoratorKind.BUILTIN:return e.BUILTIN;case o.DecoratorKind.LAZY:return e.LAZY;case o.DecoratorKind.UNSAFE:return e.UNSAFE;default:return e.NONE}}}(y=n.DecoratorFlags||(n.DecoratorFlags={}));class T{constructor(e,n,t,i,a){this.kind=e,this.name=n,this.internalName=t,this.program=i,this.flags=r.CommonFlags.NONE,this.decoratorFlags=y.NONE,this.members=null,this.shadowType=null,this.program=i,this.name=n,this.internalName=t,a?this.parent=a:(assert(this.kind==_.FILE),this.parent=this)}get file(){for(var e=this;;)if((e=e.parent).kind==_.FILE)return e}is(e){return(this.flags&e)==e}isAny(e){return 0!=(this.flags&e)}set(e){this.flags|=e}unset(e){this.flags&=~e}hasDecorator(e){return(this.decoratorFlags&e)==e}lookupInSelf(e){var n=this.members;return null!==n&&n.has(e)?assert(n.get(e)):null}add(e,n,t=null){var r=n.declaration,a=this.members;if(a){if(a.has(e)){let r=assert(a.get(e));if(r.parent!==this);else{let e=K(r,n);if(!e){let e=t||n.identifierNode;return v(r.kind)?this.program.errorRelated(i.DiagnosticCode.Duplicate_identifier_0,e.range,r.identifierNode.range,e.text):this.program.error(i.DiagnosticCode.Duplicate_identifier_0,e.range,e.text),!1}n=e}}}else this.members=a=new Map;a.set(e,n);var s=this.program;return n.kind==_.FUNCTION_PROTOTYPE&&n.isBound||(s.elementsByName.set(n.internalName,n),s.elementsByDeclaration.set(r,n)),!0}get isPublic(){return!this.isAny(r.CommonFlags.PRIVATE|r.CommonFlags.PROTECTED)}get isImplicitlyPublic(){return this.isPublic&&!this.is(r.CommonFlags.PUBLIC)}visibilityEquals(e){if(this.isPublic==e.isPublic)return!0;const n=r.CommonFlags.PRIVATE|r.CommonFlags.PROTECTED;return(this.flags&n)==(e.flags&n)}toString(){return this.internalName+", kind="+this.kind.toString()}}n.Element=T;var b=new Set;function v(e){return b.has(e)}n.isDeclaredElement=v;class A extends T{constructor(e,n,t,r,i,a){super(e,n,t,r,i),this.declaration=a,b.add(e),this.declaration=a,this.flags=a.flags}get isDeclaredInLibrary(){return this.declaration.range.source.isLibrary}get identifierNode(){return this.declaration.name}get identifierAndSignatureRange(){var e=this.declaration,n=e.name;if(e.kind==o.NodeKind.FUNCTIONDECLARATION||e.kind==o.NodeKind.METHODDECLARATION){let t=e.signature;return s.Range.join(n.range,t.range)}return n.range}get decoratorNodes(){return this.declaration.decorators}isCompatibleOverride(e){var n=this,t=n.kind;if(t==e.kind)switch(t){case _.FUNCTION:return n.signature.isAssignableTo(e.signature,!0);case _.PROPERTY:{let t=n,r=e,i=t.getterInstance,a=r.getterInstance;if(i){if(!a||!i.signature.isAssignableTo(a.signature,!0))return!1}else if(a)return!1;let s=t.setterInstance,o=r.setterInstance;if(s){if(!o||!s.signature.isAssignableTo(o.signature,!0))return!1}else if(o)return!1;return!0}}return!1}}n.DeclaredElement=A;var F=new Set;n.isTypedElement=function(e){return F.has(e)};class C extends A{constructor(e,n,t,r,i,s){super(e,n,t,r,i,s),this.type=a.Type.void,F.add(e)}setType(e){assert(!this.is(r.CommonFlags.RESOLVED)),this.type=e,this.set(r.CommonFlags.RESOLVED)}}n.TypedElement=C;class I extends T{constructor(e,n){super(_.FILE,n.normalizedPath,n.internalPath,e,null),this.source=n,this.exports=null,this.exportsStar=null,this.aliasNamespaces=new Array,this.source=n,assert(!e.filesByName.has(this.internalName)),e.filesByName.set(this.internalName,this);var t=this.program.makeNativeFunction("start:"+this.internalName,new a.Signature(e,null,a.Type.void),this);t.internalName=t.name,this.startFunction=t}add(e,n,t=null){return n.hasDecorator(y.GLOBAL)&&(n=this.program.ensureGlobal(e,n)),!!super.add(e,n,t)&&((n=assert(this.lookupInSelf(e))).is(r.CommonFlags.EXPORT)&&!t&&this.ensureExport(n.name,n),!0)}lookupInSelf(e){var n=super.lookupInSelf(e);if(n)return n;var t=this.exportsStar;if(t)for(let r=0,i=t.length;r<i;++r)if(n=t[r].lookupInSelf(e))return n;return null}lookup(e){var n=this.lookupInSelf(e);return n||this.program.lookup(e)}ensureExport(e,n){var t=this.exports;t||(this.exports=t=new Map),t.set(e,n),this.source.sourceKind==o.SourceKind.LIBRARY_ENTRY&&this.program.ensureGlobal(e,n);for(let t=0;t<this.aliasNamespaces.length;t++)this.aliasNamespaces[t].add(e,n)}ensureExportStar(e){var n=this.exportsStar;if(n){if(n.includes(e))return}else this.exportsStar=n=[];n.push(e)}lookupExport(e){var n=this.exports;if(null!==n&&n.has(e))return assert(n.get(e));var t=this.exportsStar;if(t)for(let n=0,r=t.length;n<r;++n){let r=t[n].lookupExport(e);if(r)return r}return null}asAliasNamespace(e,n,t){var i=this.program.makeNativeNamespaceDeclaration(e);i.name=t;var a=new N(e,n,i);return a.set(r.CommonFlags.SCOPED),this.copyExportsToNamespace(a),this.aliasNamespaces.push(a),a}copyExportsToNamespace(e){var n=this.exports;if(n)for(let t=Map_keys(n),r=0,i=t.length;r<i;++r){let i=unchecked(t[r]),a=assert(n.get(i));e.add(i,a)}var t=this.exportsStar;if(t)for(let n=0,r=t.length;n<r;++n)t[n].copyExportsToNamespace(e)}}n.File=I;class S extends C{constructor(e,n,t,r=y.NONE){super(_.TYPEDEFINITION,e,W(e,n,!1),n.program,n,t),this.decoratorFlags=r}get typeParameterNodes(){return this.declaration.typeParameters}get typeNode(){return this.declaration.type}lookup(e){return this.parent.lookup(e)}}n.TypeDefinition=S;class N extends A{constructor(e,n,t,r=y.NONE){super(_.NAMESPACE,e,W(e,n,!1),n.program,n,t),this.decoratorFlags=r}lookup(e){var n=this.lookupInSelf(e);return n||this.parent.lookup(e)}}n.Namespace=N;class O extends C{constructor(e,n,t,r=y.NONE){super(_.ENUM,e,W(e,n,!1),n.program,n,t),this.decoratorFlags=r,this.setType(a.Type.i32)}lookup(e){var n=this.lookupInSelf(e);return n||this.parent.lookup(e)}}n.Enum=O,function(e){e[e.NONE=0]="NONE",e[e.INTEGER=1]="INTEGER",e[e.FLOAT=2]="FLOAT"}(n.ConstantValueKind||(n.ConstantValueKind={}));class k extends C{constructor(e,n,t,r=t.program.makeNativeVariableDeclaration(n)){super(e,n,W(n,t,!1),t.program,t,r),this.constantValueKind=0,this.constantIntegerValue=i64_zero,this.constantFloatValue=0,this.flags=r.flags}get typeNode(){return this.declaration.type}get initializerNode(){return this.declaration.initializer}setConstantIntegerValue(e,n){assert(n.isIntegerInclReference),this.type=n,this.constantValueKind=1,this.constantIntegerValue=e,this.set(r.CommonFlags.CONST|r.CommonFlags.INLINED|r.CommonFlags.RESOLVED)}setConstantFloatValue(e,n){assert(n.isFloatValue),this.type=n,this.constantValueKind=2,this.constantFloatValue=e,this.set(r.CommonFlags.CONST|r.CommonFlags.INLINED|r.CommonFlags.RESOLVED)}lookup(e){return this.parent.lookup(e)}}n.VariableLikeElement=k;class L extends k{constructor(e,n,t,r=y.NONE){super(_.ENUMVALUE,e,n,t),this.isImmutable=!1,this.decoratorFlags=r,this.setType(a.Type.i32)}get valueNode(){return this.declaration.initializer}lookup(e){return this.parent.lookup(e)}}n.EnumValue=L;class B extends k{constructor(e,n,t,r=n.program.makeNativeVariableDeclaration(e)){super(_.GLOBAL,e,n,r),this.decoratorFlags=t}}n.Global=B,n.Parameter=class{constructor(e,n,t=null){this.name=e,this.type=n,this.initializer=t}};class D extends k{constructor(e,n,t,r,i=r.program.makeNativeVariableDeclaration(e)){super(_.LOCAL,e,r,i),this.index=n,this.originalName=e,this.index=n,assert(t!=a.Type.void),this.setType(t)}setTemporaryName(e){this.name=e,this.internalName=W(e,this.parent,!1)}resetTemporaryName(){var e=this.originalName;this.name=e,this.internalName=W(e,this.parent,!1)}}n.Local=D;class R extends A{constructor(e,n,t,i=y.NONE){super(_.FUNCTION_PROTOTYPE,e,W(e,n,t.is(r.CommonFlags.INSTANCE)),n.program,n,t),this.operatorKind=m.INVALID,this.instances=null,this.overloads=null,this.boundPrototypes=null,this.decoratorFlags=i}get typeParameterNodes(){return this.declaration.typeParameters}get functionTypeNode(){return this.declaration.signature}get bodyNode(){return this.declaration.body}get arrowKind(){return this.declaration.arrowKind}get isBound(){var e=this.parent;return e.kind==_.CLASS||e.kind==_.PROPERTY_PROTOTYPE&&(e.parent.kind==_.CLASS||e.parent.kind==_.INTERFACE)}toBound(e){assert(this.is(r.CommonFlags.INSTANCE)),assert(!this.isBound);var n=this.boundPrototypes;if(n){if(n.has(e))return assert(n.get(e))}else this.boundPrototypes=n=new Map;var t=this.declaration;assert(t.kind==o.NodeKind.METHODDECLARATION);var i=new R(this.name,e,t,this.decoratorFlags);return i.flags=this.flags,i.operatorKind=this.operatorKind,i.overloads=this.overloads,n.set(e,i),i}getResolvedInstance(e){var n=this.instances;return null!==n&&n.has(e)?assert(n.get(e)):null}setResolvedInstance(e,n){var t=this.instances;t?assert(!t.has(e)):this.instances=t=new Map,t.set(e,n)}lookup(e){return this.parent.lookup(e)}}n.FunctionPrototype=R;class w extends C{constructor(e,n,t,i,a=null){super(_.FUNCTION,e,W(e,n.parent,n.is(r.CommonFlags.INSTANCE)),n.program,n.parent,n.declaration),this.localsByName=new Map,this.localsByIndex=[],this.additionalLocals=[],this.debugLocations=[],this.ref=0,this.varargsStub=null,this.virtualStub=null,this.memorySegment=null,this.nextInlineId=0,this.nextAnonymousId=0,this.tempI32s=null,this.tempI64s=null,this.tempF32s=null,this.tempF64s=null,this.tempV128s=null,this.tempFuncrefs=null,this.tempExternrefs=null,this.tempExnrefs=null,this.tempAnyrefs=null,this.nextBreakId=0,this.breakStack=null,this.breakLabel=null,this.prototype=n,this.typeArguments=t,this.signature=i,this.flags=n.flags|r.CommonFlags.RESOLVED,this.decoratorFlags=n.decoratorFlags,this.contextualTypeArguments=a,this.original=this;var s=n.program;if(this.type=i.type,!n.is(r.CommonFlags.AMBIENT)){let e=0,n=i.thisType;if(n){let t=new D(r.CommonNames.this_,e++,n,this);this.localsByName.set(r.CommonNames.this_,t),this.localsByIndex[t.index]=t}let t=i.parameterTypes;for(let n=0,r=t.length;n<r;++n){let r=t[n],i=this.getParameterName(n),a=new D(i,e++,r,this);this.localsByName.set(i,a),this.localsByIndex[a.index]=a}}this.flow=c.Flow.createParent(this),V(s,this)}getParameterName(e){var n=this.declaration.signature.parameters;return n.length>e?n[e].name.text:Y(e)}newStub(e){var n=new w(this.original.name+r.STUB_DELIMITER+e,this.prototype,this.typeArguments,this.signature.clone(),this.contextualTypeArguments);return n.original=this.original,n.set(this.flags&~r.CommonFlags.COMPILED|r.CommonFlags.STUB),n}addLocal(e,n=null,t=null){var i=this.signature.parameterTypes.length+this.additionalLocals.length;this.is(r.CommonFlags.INSTANCE)&&++i;var a=null!==n?n:"var$"+i.toString();t||(t=this.program.makeNativeVariableDeclaration(a));var s=new D(a,i,e,this,t);if(n){if(this.localsByName.has(n))throw new Error("duplicate local name");this.localsByName.set(n,s)}return this.localsByIndex[s.index]=s,this.additionalLocals.push(e),s}lookup(e){var n=this.localsByName;return n.has(e)?assert(n.get(e)):this.parent.lookup(e)}finalize(e,n){this.ref=n;var t=this.breakStack;if(assert(!t||!t.length),this.breakStack=t=null,this.breakLabel=null,this.tempI32s=this.tempI64s=this.tempF32s=this.tempF64s=null,this.program.options.sourceMap){let t=this.debugLocations;for(let r=0,i=t.length;r<i;++r){let i=t[r],a=i.source;e.setDebugLocation(n,i.debugInfoRef,a.debugInfoIndex,a.lineAt(i.start),a.columnAt()-1)}}}}n.Function=w;class z extends A{constructor(e,n,t,i=y.NONE){super(_.FIELD_PROTOTYPE,e,W(e,n,assert(t.is(r.CommonFlags.INSTANCE))),n.program,n,t),this.decoratorFlags=i}get typeNode(){return this.declaration.type}get initializerNode(){return this.declaration.initializer}get parameterIndex(){return this.declaration.parameterIndex}lookup(e){return this.parent.lookup(e)}}n.FieldPrototype=z,n.Field=class extends k{constructor(e,n,t){super(_.FIELD,e.name,n,e.declaration),this.memoryOffset=-1,this.getterRef=0,this.setterRef=0,this._internalGetterName=null,this._internalSetterName=null,this._internalGetterSignature=null,this._internalSetterSignature=null,this.prototype=e,this.flags=e.flags,this.decoratorFlags=e.decoratorFlags,assert(t!=a.Type.void),this.setType(t),V(this.program,this)}get thisType(){var e=this.parent;return assert(e.kind==_.CLASS),e.type}get internalGetterName(){var e=this._internalGetterName;return null===e&&(this._internalGetterName=e=this.parent.internalName+r.INSTANCE_DELIMITER+r.GETTER_PREFIX+this.name),e}get internalSetterName(){var e=this._internalSetterName;return null===e&&(this._internalSetterName=e=this.parent.internalName+r.INSTANCE_DELIMITER+r.SETTER_PREFIX+this.name),e}get internalGetterSignature(){var e=this._internalGetterSignature;return e||(this._internalGetterSignature=e=new a.Signature(this.program,null,this.type,this.thisType)),e}get internalSetterSignature(){var e=this._internalSetterSignature;return e||(this._internalGetterSignature=e=new a.Signature(this.program,[this.type],a.Type.void,this.thisType)),e}};class P extends A{constructor(e,n,t){super(_.PROPERTY_PROTOTYPE,e,W(e,n,t.is(r.CommonFlags.INSTANCE)),n.program,n,t),this.getterPrototype=null,this.setterPrototype=null,this.instance=null,this.boundPrototypes=null,this.flags&=~(r.CommonFlags.GET|r.CommonFlags.SET)}lookup(e){return this.parent.lookup(e)}get isBound(){switch(this.parent.kind){case _.CLASS:case _.INTERFACE:return!0}return!1}toBound(e){assert(this.is(r.CommonFlags.INSTANCE)),assert(!this.isBound);var n=this.boundPrototypes;if(n){if(n.has(e))return assert(n.get(e))}else this.boundPrototypes=n=new Map;var t=this.declaration;assert(t.kind==o.NodeKind.METHODDECLARATION);var i=new P(this.name,e,t);i.flags=this.flags;var a=this.getterPrototype;a&&(i.getterPrototype=a.toBound(e));var s=this.setterPrototype;return s&&(i.setterPrototype=s.toBound(e)),n.set(e,i),i}}n.PropertyPrototype=P,n.Property=class extends k{constructor(e,n){super(_.PROPERTY,e.name,n,o.Node.createVariableDeclaration(e.identifierNode,null,e.is(r.CommonFlags.INSTANCE)?r.CommonFlags.INSTANCE:r.CommonFlags.NONE,null,null,e.identifierNode.range)),this.getterInstance=null,this.setterInstance=null,this.prototype=e,this.flags=e.flags,this.decoratorFlags=e.decoratorFlags,this.is(r.CommonFlags.INSTANCE)&&V(this.program,this)}lookup(e){return this.parent.lookup(e)}},n.IndexSignature=class extends C{constructor(e){super(_.INDEXSIGNATURE,"[]",e.internalName+"[]",e.program,e,e.program.makeNativeVariableDeclaration("[]"))}getGetterInstance(e){return this.parent.lookupOverload(m.INDEXED_GET,e)}getSetterInstance(e){return this.parent.lookupOverload(m.INDEXED_SET,e)}lookup(e){return this.parent.lookup(e)}};class U extends A{constructor(e,n,t,i=y.NONE,a=!1){super(a?_.INTERFACE_PROTOTYPE:_.CLASS_PROTOTYPE,e,W(e,n,t.is(r.CommonFlags.INSTANCE)),n.program,n,t),this.instanceMembers=null,this.basePrototype=null,this.interfacePrototypes=null,this.constructorPrototype=null,this.overloadPrototypes=new Map,this.instances=null,this.extendees=new Set,this.decoratorFlags=i}get typeParameterNodes(){return this.declaration.typeParameters}get extendsNode(){return this.declaration.extendsType}get implementsNodes(){return this.declaration.implementsTypes}get isBuiltinArray(){var e=this.program.arrayBufferViewInstance;return null!==e&&this.extends(e.prototype)}extends(e){var n=this,t=new Set;do{if(t.has(n))break;if(t.add(n),n===e)return!0;n=n.basePrototype}while(n);return!1}addInstance(e,n){var t=n.declaration,a=this.instanceMembers;if(a){if(a.has(e)){let t=assert(a.get(e)),r=K(t,n);if(!r)return v(t.kind)?this.program.errorRelated(i.DiagnosticCode.Duplicate_identifier_0,n.identifierNode.range,t.declaration.name.range,n.identifierNode.text):this.program.error(i.DiagnosticCode.Duplicate_identifier_0,n.identifierNode.range,n.identifierNode.text),!1;n=r}}else this.instanceMembers=a=new Map;return a.set(e,n),n.is(r.CommonFlags.EXPORT)&&this.is(r.CommonFlags.MODULE_EXPORT)&&n.set(r.CommonFlags.MODULE_EXPORT),this.program.elementsByDeclaration.set(t,n),!0}getResolvedInstance(e){var n=this.instances;return null!==n&&n.has(e)?n.get(e):null}setResolvedInstance(e,n){var t=this.instances;t?assert(!t.has(e)):this.instances=t=new Map,t.set(e,n)}lookup(e){return this.parent.lookup(e)}}n.ClassPrototype=U;class M extends C{constructor(e,n,t=null,i=!1){super(i?_.INTERFACE:_.CLASS,e,W(e,n.parent,n.is(r.CommonFlags.INSTANCE)),n.program,n.parent,n.declaration),this.base=null,this.interfaces=null,this.contextualTypeArguments=null,this.nextMemoryOffset=0,this.constructorInstance=null,this.overloads=null,this.indexSignature=null,this._id=0,this.rttiFlags=0,this.wrappedType=null,this.extendees=null,this.implementers=null,this.didCheckFieldInitialization=!1,this.visitRef=0;var s=this.program;this.prototype=n,this.flags=n.flags,this.decoratorFlags=n.decoratorFlags,this.typeArguments=t;var o=s.options.usizeType,l=new a.Type(o.kind,-129&o.flags|256,o.size);if(l.classReference=this,this.setType(l),!this.hasDecorator(y.UNMANAGED)){let e=s.nextClassId++;this._id=e,s.managedClasses.set(e,this)}var u=n.typeParameterNodes;if(t){let e=t.length;if(!u||e!=u.length)throw new Error("type argument count mismatch");if(e){let n=this.contextualTypeArguments;n||(this.contextualTypeArguments=n=new Map);for(let r=0;r<e;++r)n.set(u[r].name.text,t[r])}}else if(null!==u&&u.length>0)throw new Error("type argument count mismatch");V(s,this)}get id(){return this._id}get isBuiltinArray(){return this.prototype.isBuiltinArray}get isArrayLike(){if(this.isBuiltinArray)return!0;var e=this.lookupInSelf("length");return null!==e&&(e.kind==_.FIELD||e.kind==_.PROPERTY_PROTOTYPE&&null!==e.getterPrototype)&&(null!==this.lookupOverload(m.INDEXED_GET)||null!==this.lookupOverload(m.UNCHECKED_INDEXED_GET))}setBase(e){assert(!this.base),this.base=e;var n=e.extendees;n||(e.extendees=n=new Set),n.add(this);var t=e.contextualTypeArguments;if(t){let e=this.contextualTypeArguments;for(let n=Map_keys(t),r=0,i=n.length;r<i;++r){let i=unchecked(n[r]),a=assert(t.get(i));e?e.has(i)||e.set(i,a):(this.contextualTypeArguments=e=new Map,e.set(i,a))}}}addInterface(e){var n=this.interfaces;n||(this.interfaces=n=new Set),n.add(e);var t=e.implementers;t||(e.implementers=t=new Set),t.add(this)}isAssignableTo(e){var n=this;do{if(n==e)return!0;if(e.kind==_.INTERFACE){let t=n.interfaces;if(t)for(let n=Set_values(t),r=0,i=n.length;r<i;++r)if(n[r].isAssignableTo(e))return!0}n=n.base}while(n);return!1}lookupOverload(e,n=!1){if(n)switch(e){case m.INDEXED_GET:{let e=this.lookupOverload(m.UNCHECKED_INDEXED_GET);if(e)return e;break}case m.INDEXED_SET:{let e=this.lookupOverload(m.UNCHECKED_INDEXED_SET);if(e)return e;break}default:assert(!1)}var t=this;do{let n=t.overloads;if(null!=n&&n.has(e))return assert(n.get(e));t=t.base}while(t);return null}lookup(e){return this.parent.lookup(e)}offsetof(e){var n=assert(this.members);assert(n.has(e));var t=n.get(e);return assert(t.kind==_.FIELD),t.memoryOffset}createBuffer(e=0){var n=this.program,t=this.nextMemoryOffset+e,r=n.computeBlockSize(t,!0),i=new Uint8Array(n.blockOverhead+r),a=n.OBJECTInstance;return a.writeField("mmInfo",r,i,0),a.writeField("gcInfo",0,i,0),a.writeField("gcInfo2",0,i,0),a.writeField("rtId",this.id,i,0),a.writeField("rtSize",t,i,0),i}writeField(e,n,t,r=this.program.totalOverhead){var i=this.lookupInSelf(e);if(null!==i&&i.kind==_.FIELD){let e=i,a=r+e.memoryOffset,s=e.type.kind;switch(s){case 0:case 5:return assert(!i64_is(n)),l.writeI8(i32(n),t,a),1;case 1:case 6:return assert(!i64_is(n)),l.writeI16(i32(n),t,a),2;case 2:case 7:return assert(!i64_is(n)),l.writeI32(i32(n),t,a),4;case 4:case 9:return this.program.options.isWasm64?(i64_is(n)?l.writeI64(n,t,a):l.writeI32AsI64(i32(n),t,a,9==s),8):(i64_is(n)?l.writeI64AsI32(n,t,a,9==s):l.writeI32(i32(n),t,a),4);case 3:case 8:return i64_is(n)?l.writeI64(n,t,a):l.writeI32AsI64(i32(n),t,a,8==s),8;case 11:return assert(!i64_is(n)),l.writeF32(f32(n),t,a),4;case 12:return assert(!i64_is(n)),l.writeF64(f64(n),t,a),8}}return assert(!1),0}extends(e){return this.prototype.extends(e)}getTypeArgumentsTo(e){var n=this;do{if(n.prototype===e)return n.typeArguments;n=n.base}while(n);return null}getArrayValueType(){var e=this,n=this.program,t=n.arrayPrototype;if(this.extends(t))return this.getTypeArgumentsTo(t)[0];var r=n.staticArrayPrototype;if(this.extends(r))return this.getTypeArgumentsTo(r)[0];for(var i=n.arrayBufferViewInstance;e.base!==i;)e=assert(e.base);var s=e.prototype;switch(s.name.charCodeAt(0)){case 70:if(s==n.float32ArrayPrototype)return a.Type.f32;if(s==n.float64ArrayPrototype)return a.Type.f64;break;case 73:if(s==n.int8ArrayPrototype)return a.Type.i8;if(s==n.int16ArrayPrototype)return a.Type.i16;if(s==n.int32ArrayPrototype)return a.Type.i32;if(s==n.int64ArrayPrototype)return a.Type.i64;break;case 85:if(s==n.uint8ArrayPrototype)return a.Type.u8;if(s==n.uint8ClampedArrayPrototype)return a.Type.u8;if(s==n.uint16ArrayPrototype)return a.Type.u16;if(s==n.uint32ArrayPrototype)return a.Type.u32;if(s==n.uint64ArrayPrototype)return a.Type.u64}return assert(!1),a.Type.void}get isPointerfree(){var e=this.program,n=this.members;if(n){for(let e=Map_values(n),t=0,r=e.length;t<r;++t){let n=unchecked(e[t]);if(n.kind==_.FIELD&&n.type.isManaged)return!1}if(n.has(r.CommonNames.visit)){let n=this.prototype;if(n==e.arrayPrototype||n==e.staticArrayPrototype||n==e.setPrototype||n==e.mapPrototype){let e=assert(this.getTypeArgumentsTo(n));for(let n=0,t=e.length;n<t;++n)if(e[n].isManaged)return!1;return!0}return!1}}return!0}getAllExtendees(e=null,n=new Set){var t=this.extendees;if(t)for(let r=Set_values(t),i=0,a=r.length;i<a;++i){let t=r[i];if(e){let n=t.prototype.instanceMembers;if(null!==n&&n.has(e))continue}n.add(t),t.getAllExtendees(e,n)}return n}}n.Class=M;class G extends U{constructor(e,n,t,r){super(e,n,t,r,!0)}}function V(e,n){assert(!e.instancesByName.has(n.internalName)),e.instancesByName.set(n.internalName,n)}function K(e,n){if(assert(e.program===n.program),n.members)return null;var t=null;switch(e.kind){case _.FUNCTION_PROTOTYPE:switch(n.kind){case _.NAMESPACE:H(n,e),t=e;break;case _.TYPEDEFINITION:e.shadowType||(e.shadowType=n,H(n,e),t=e)}break;case _.CLASS_PROTOTYPE:case _.ENUM:if(n.kind==_.NAMESPACE){H(n,e),t=e;break}break;case _.NAMESPACE:switch(n.kind){case _.ENUM:case _.CLASS_PROTOTYPE:case _.FUNCTION_PROTOTYPE:H(e,n),t=n;break;case _.NAMESPACE:H(n,e),t=e;break;case _.TYPEDEFINITION:e.shadowType||(e.shadowType=n,H(n,e),t=e)}break;case _.GLOBAL:n.kind==_.TYPEDEFINITION&&(e.shadowType||(e.shadowType=n,H(n,e),t=e));break;case _.TYPEDEFINITION:switch(n.kind){case _.GLOBAL:case _.FUNCTION_PROTOTYPE:case _.NAMESPACE:n.shadowType||(n.shadowType=e,H(e,n),t=n)}}return t&&(e.is(r.CommonFlags.EXPORT)||e.hasDecorator(y.GLOBAL))!=(n.is(r.CommonFlags.EXPORT)||n.hasDecorator(y.GLOBAL))&&e.program.error(i.DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,t.identifierNode.range,t.identifierNode.text),t}function H(e,n){var t=e.members;if(t){let e=n.members;e||(n.members=e=new Map);for(let n=Map_keys(t),r=0,i=n.length;r<i;++r){let i=unchecked(n[r]),a=assert(t.get(i));e.set(i,a)}}}function W(e,n,t,i=!1){switch(n.kind){case _.FILE:return i?e:n.internalName+r.PATH_DELIMITER+e;case _.FUNCTION:return i?e:(assert(!t),n.internalName+r.INNER_DELIMITER+e);case _.PROPERTY_PROTOTYPE:case _.PROPERTY:n=n.parent;default:return W(n.name,n.parent,n.is(r.CommonFlags.INSTANCE),i)+(t?r.INSTANCE_DELIMITER:r.STATIC_DELIMITER)+e}}n.InterfacePrototype=G,n.Interface=class extends M{constructor(e,n,t=null){super(e,n,t,!0)}},n.mangleInternalName=W;var X=[];function Y(e){for(let n=X.length;n<=e;++n)X.push("$"+n.toString());return X[e]}n.getDefaultParameterName=Y},742:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Resolver=n.ReportMode=void 0;const r=t(256),i=t(974),a=t(411),s=t(60),o=t(699),l=t(200),u=t(910),c=t(411),p=t(346);var f;!function(e){e[e.REPORT=0]="REPORT",e[e.SWALLOW=1]="SWALLOW"}(f=n.ReportMode||(n.ReportMode={}));class d extends r.DiagnosticEmitter{constructor(e){super(e.diagnostics),this.currentThisExpression=null,this.currentElementExpression=null,this.resolveClassPending=new Set,this.program=e}resolveType(e,n,t=null,r=f.REPORT){switch(e.kind){case s.NodeKind.NAMEDTYPE:return this.resolveNamedType(e,n,t,r);case s.NodeKind.FUNCTIONTYPE:return this.resolveFunctionType(e,n,t,r);default:assert(!1)}return null}resolveNamedType(e,n,t=null,a=f.REPORT){var s=e.name,c=e.typeArguments,p=!s.next;if(p){let n=s.identifier.text;if(null!==t&&t.has(n)){let i=assert(t.get(n));if(null!==c&&c.length>0&&a==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_not_generic,e.range,i.toString()),e.isNullable){if(i.isInternalReference)return i.asNullable();a==f.REPORT&&this.error(r.DiagnosticCode.Type_0_cannot_be_nullable,e.range,i.toString())}return i}}var d=this.resolveTypeName(s,n,a);if(!d)return null;var h=d.shadowType;if(h)d=h;else{if(d.kind==i.ElementKind.ENUM)return null!==c&&c.length>0&&a==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_not_generic,e.range,d.internalName),e.isNullable&&a==f.REPORT&&this.error(r.DiagnosticCode.Type_0_cannot_be_nullable,e.range,d.name+"/i32"),o.Type.i32;if(d.kind==i.ElementKind.CLASS_PROTOTYPE||d.kind==i.ElementKind.INTERFACE_PROTOTYPE){let r=this.resolveClassInclTypeArguments(d,c,n,u.uniqueMap(t),e,a);return r?e.isNullable?r.type.asNullable():r.type:null}}if(d.kind==i.ElementKind.TYPEDEFINITION){let i=d;if(d.is(l.CommonFlags.RESOLVED)){null!==c&&c.length>0&&a==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_not_generic,e.range,d.internalName);let n=i.type;if(e.isNullable){if(n.isInternalReference)return n.asNullable();a==f.REPORT&&this.error(r.DiagnosticCode.Type_0_cannot_be_nullable,s.range,s.identifier.text)}return n}if(p){let r=s.identifier.text;if(r==l.CommonNames.native)return this.resolveBuiltinNativeType(e,n,t,a);if(r==l.CommonNames.indexof)return this.resolveBuiltinIndexofType(e,n,t,a);if(r==l.CommonNames.valueof)return this.resolveBuiltinValueofType(e,n,t,a);if(r==l.CommonNames.returnof)return this.resolveBuiltinReturnTypeType(e,n,t,a)}let o=i.typeParameterNodes,h=null;if(o){if(h=this.resolveTypeArguments(o,c,n,t=u.uniqueMap(t),e,a),!h)return null}else null!==c&&c.length>0&&this.error(r.DiagnosticCode.Type_0_is_not_generic,e.range,s.identifier.text);let g=this.resolveType(i.typeNode,d,t,a);if(!g)return null;if(e.isNullable){if(g.isInternalReference)return g.asNullable();a==f.REPORT&&this.error(r.DiagnosticCode.Type_0_cannot_be_nullable,s.range,s.identifier.text)}return g}return a==f.REPORT&&this.error(r.DiagnosticCode.Cannot_find_name_0,s.range,s.identifier.text),null}resolveFunctionType(e,n,t=null,i=f.REPORT){var a=e.explicitThisType,l=null;if(a&&!(l=this.resolveType(a,n,t,i)))return null;var u=e.parameters,c=u.length,p=new Array(c),d=0,h=!1;for(let e=0;e<c;++e){let a=u[e];switch(a.parameterKind){case s.ParameterKind.DEFAULT:d=e+1;break;case s.ParameterKind.REST:assert(e==c),h=!0}let o=a.type;if(s.isTypeOmitted(o))return i==f.REPORT&&this.error(r.DiagnosticCode.Type_expected,o.range),null;let l=this.resolveType(o,n,t,i);if(!l)return null;p[e]=l}var g,x=e.returnType;if(s.isTypeOmitted(x))i==f.REPORT&&this.error(r.DiagnosticCode.Type_expected,x.range),g=o.Type.void;else if(!(g=this.resolveType(x,n,t,i)))return null;var m=new o.Signature(this.program,p,g,l);return m.requiredParameters=d,m.hasRest=h,e.isNullable?m.type.asNullable():m.type}resolveBuiltinNativeType(e,n,t=null,i=f.REPORT){var a=e.typeArguments;if(!a||1!=a.length){if(i==f.REPORT){let n=0;a&&(n=a.length),this.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.range,"1",n.toString())}return null}var s=this.resolveType(a[0],n,t,i);if(!s)return null;switch(s.kind){case 0:case 1:case 2:return o.Type.i32;case 4:if(!this.program.options.isWasm64)return o.Type.i32;case 3:return o.Type.i64;case 5:case 6:case 7:case 10:return o.Type.u32;case 9:if(!this.program.options.isWasm64)return o.Type.u32;case 8:return o.Type.u64;case 11:return o.Type.f32;case 12:return o.Type.f64;case 13:return o.Type.v128;case 18:return o.Type.void;default:assert(!1)}return null}resolveBuiltinIndexofType(e,n,t=null,a=f.REPORT){var s=e.typeArguments;if(!s||1!=s.length){if(a==f.REPORT){let n=0;s&&(n=s.length),this.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.range,"1",n.toString())}return null}var o=this.resolveType(s[0],n,t,a);if(!o)return null;var u=o.classReference;if(!u)return a==f.REPORT&&this.error(r.DiagnosticCode.Index_signature_is_missing_in_type_0,s[0].range,o.toString()),null;var c=u.lookupOverload(i.OperatorKind.INDEXED_GET);return c?c.is(l.CommonFlags.STATIC)?(assert(2==c.signature.parameterTypes.length),c.signature.parameterTypes[1]):(assert(1==c.signature.parameterTypes.length),c.signature.parameterTypes[0]):(a==f.REPORT&&this.error(r.DiagnosticCode.Index_signature_is_missing_in_type_0,s[0].range,o.toString()),null)}resolveBuiltinValueofType(e,n,t=null,a=f.REPORT){var s=e.typeArguments;if(!s||1!=s.length){let n=0;return s&&(n=s.length),a==f.REPORT&&this.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.range,"1",n.toString()),null}var o=this.resolveType(s[0],n,t,a);if(!o)return null;var l=o.getClassOrWrapper(this.program);if(l){let e=l.lookupOverload(i.OperatorKind.INDEXED_GET);if(e)return e.signature.returnType}return a==f.REPORT&&this.error(r.DiagnosticCode.Index_signature_is_missing_in_type_0,s[0].range,o.toString()),null}resolveBuiltinReturnTypeType(e,n,t=null,i=f.REPORT){var a=e.typeArguments;if(!a||1!=a.length){if(i==f.REPORT){let n=0;a&&(n=a.length),this.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,e.range,"1",n.toString())}return null}var s=this.resolveType(a[0],n,t,i);if(!s)return null;var o=s.getSignature();return o?o.returnType:(i==f.REPORT&&this.error(r.DiagnosticCode.Type_0_has_no_call_signatures,a[0].range,s.toString()),null)}resolveTypeName(e,n,t=f.REPORT){var i=n.lookup(e.identifier.text);if(!i)return t==f.REPORT&&this.error(r.DiagnosticCode.Cannot_find_name_0,e.range,e.identifier.text),null;for(var a=e,s=e.next;s;){if(!(i=i.lookupInSelf(s.identifier.text)))return t==f.REPORT&&this.error(r.DiagnosticCode.Property_0_does_not_exist_on_type_1,s.range,s.identifier.text,a.identifier.text),null;a=s,s=s.next}return i}resolveTypeArguments(e,n,t,i=u.uniqueMap(),s=null,o=f.REPORT){var l=0,c=0;for(let n=0,t=e.length;n<t;++n)e[n].defaultType||++l,++c;var p=n?n.length:0;if(p<l||p>c)return o==f.REPORT&&this.error(r.DiagnosticCode.Expected_0_type_arguments_but_got_1,p?a.Range.join(n[0].range,n[p-1].range):s.range,(p<l?l:c).toString(),p.toString()),null;var d=new Array(c);for(let r=0;r<c;++r){let a=r<p?this.resolveType(n[r],t,i,o):this.resolveType(assert(e[r].defaultType),t,i,o);if(!a)return null;i.set(e[r].name.text,a),d[r]=a}return d}maybeInferCall(e,n,t,i=f.REPORT){var a=e.typeArguments;if(a)return n.is(l.CommonFlags.GENERIC)?this.resolveFunctionInclTypeArguments(n,a,t.actualFunction,u.uniqueMap(t.contextualTypeArguments),e,i):(i==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_not_generic,e.expression.range,n.internalName),null);if(n.is(l.CommonFlags.GENERIC)){let a=u.uniqueMap(t.contextualTypeArguments),s=assert(n.typeParameterNodes),l=s.length,c=new Set;for(let e=0;e<l;++e){let n=s[e].name.text;a.set(n,o.Type.auto),c.add(n)}let p=n.functionTypeNode.parameters,d=p.length,h=e.args,g=h.length;for(let n=0;n<d;++n){let l=n<g?h[n]:p[n].initializer;if(!l)return i==f.REPORT&&this.error(r.DiagnosticCode.Expected_0_arguments_but_got_1,e.range,d.toString(),g.toString()),null;let u=p[n].type;if(u.hasGenericComponent(s)){let e=this.resolveExpression(l,t,o.Type.auto,f.SWALLOW);e&&this.propagateInferredGenericTypes(u,e,t,a,c)}}let x=new Array(l);for(let n=0;n<l;++n){let t=s[n].name.text;if(a.has(t)){let e=assert(a.get(t));if(e!=o.Type.auto){x[n]=e;continue}}return i==f.REPORT&&this.error(r.DiagnosticCode.Type_argument_expected,e.expression.range.atEnd),null}return this.resolveFunction(n,x,u.uniqueMap(t.contextualTypeArguments),i)}return this.resolveFunction(n,null,u.uniqueMap(),i)}propagateInferredGenericTypes(e,n,t,r,a){if(e.kind==s.NodeKind.NAMEDTYPE){let s=e,l=s.typeArguments;if(null!==l&&l.length>0){let e=n.classReference;if(e){let n=this.resolveTypeName(s.name,t.actualFunction);if(!n||n.kind!=i.ElementKind.CLASS_PROTOTYPE)return;if(e.prototype==n){let n=e.typeArguments;if(null!==n&&n.length==l.length){for(let e=0,i=n.length;e<i;++e)this.propagateInferredGenericTypes(l[e],n[e],t,r,a);return}}}}else{let e=s.name.identifier.text;if(r.has(e)){let t=assert(r.get(e));(t==o.Type.auto||a.has(e)&&t.isAssignableTo(n))&&r.set(e,n)}}}else if(e.kind==s.NodeKind.FUNCTIONTYPE){let i=e,s=i.parameters;if(null!==s&&s.length>0){let e=n.signatureReference;if(e){let n=e.parameterTypes,o=e.thisType;if(n.length==s.length&&!o==!i.explicitThisType){for(let e=0,i=n.length;e<i;++e)this.propagateInferredGenericTypes(s[e].type,n[e],t,r,a);return this.propagateInferredGenericTypes(i.returnType,e.returnType,t,r,a),void(o&&this.propagateInferredGenericTypes(i.explicitThisType,o,t,r,a))}}}}}getTypeOfElement(e){var n=e.kind;if(n==i.ElementKind.GLOBAL&&!this.ensureResolvedLazyGlobal(e,f.SWALLOW))return null;if(i.isTypedElement(n)){let n=e.type;assert(n!=o.Type.void);let t=n.getClassOrWrapper(this.program);if(t){let e=t.wrappedType;e&&(n=e)}return n}return null}getElementOfType(e){let n=e.getClassOrWrapper(this.program);return n||null}lookupExpression(e,n,t=o.Type.auto,r=f.REPORT){for(;e.kind==s.NodeKind.PARENTHESIZED;)e=e.expression;switch(e.kind){case s.NodeKind.ASSERTION:return this.lookupAssertionExpression(e,n,t,r);case s.NodeKind.BINARY:return this.lookupBinaryExpression(e,n,t,r);case s.NodeKind.CALL:return this.lookupCallExpression(e,n,t,r);case s.NodeKind.COMMA:return this.lookupCommaExpression(e,n,t,r);case s.NodeKind.ELEMENTACCESS:return this.lookupElementAccessExpression(e,n,t,r);case s.NodeKind.FUNCTION:return this.lookupFunctionExpression(e,n,t,r);case s.NodeKind.IDENTIFIER:case s.NodeKind.FALSE:case s.NodeKind.NULL:case s.NodeKind.TRUE:return this.lookupIdentifierExpression(e,n,n.actualFunction,r);case s.NodeKind.THIS:return this.lookupThisExpression(e,n,t,r);case s.NodeKind.SUPER:return this.lookupSuperExpression(e,n,t,r);case s.NodeKind.INSTANCEOF:return this.lookupInstanceOfExpression(e,n,t,r);case s.NodeKind.LITERAL:return this.lookupLiteralExpression(e,n,t,r);case s.NodeKind.NEW:return this.lookupNewExpression(e,n,t,r);case s.NodeKind.PROPERTYACCESS:return this.lookupPropertyAccessExpression(e,n,t,r);case s.NodeKind.TERNARY:return this.lookupTernaryExpression(e,n,t,r);case s.NodeKind.UNARYPOSTFIX:return this.lookupUnaryPostfixExpression(e,n,t,r);case s.NodeKind.UNARYPREFIX:return this.lookupUnaryPrefixExpression(e,n,t,r)}return assert(!1),null}resolveExpression(e,n,t=o.Type.auto,r=f.REPORT){for(;e.kind==s.NodeKind.PARENTHESIZED;)e=e.expression;switch(e.kind){case s.NodeKind.ASSERTION:return this.resolveAssertionExpression(e,n,t,r);case s.NodeKind.BINARY:return this.resolveBinaryExpression(e,n,t,r);case s.NodeKind.CALL:return this.resolveCallExpression(e,n,t,r);case s.NodeKind.COMMA:return this.resolveCommaExpression(e,n,t,r);case s.NodeKind.ELEMENTACCESS:return this.resolveElementAccessExpression(e,n,t,r);case s.NodeKind.FUNCTION:return this.resolveFunctionExpression(e,n,t,r);case s.NodeKind.IDENTIFIER:case s.NodeKind.FALSE:case s.NodeKind.NULL:case s.NodeKind.TRUE:return this.resolveIdentifierExpression(e,n,t,n.actualFunction,r);case s.NodeKind.THIS:return this.resolveThisExpression(e,n,t,r);case s.NodeKind.SUPER:return this.resolveSuperExpression(e,n,t,r);case s.NodeKind.INSTANCEOF:return this.resolveInstanceOfExpression(e,n,t,r);case s.NodeKind.LITERAL:return this.resolveLiteralExpression(e,n,t,r);case s.NodeKind.NEW:return this.resolveNewExpression(e,n,t,r);case s.NodeKind.PROPERTYACCESS:return this.resolvePropertyAccessExpression(e,n,t,r);case s.NodeKind.TERNARY:return this.resolveTernaryExpression(e,n,t,r);case s.NodeKind.UNARYPOSTFIX:return this.resolveUnaryPostfixExpression(e,n,t,r);case s.NodeKind.UNARYPREFIX:return this.resolveUnaryPrefixExpression(e,n,t,r)}return assert(!1),null}lookupIdentifierExpression(e,n,t=n.actualFunction,i=f.REPORT){switch(e.kind){case s.NodeKind.TRUE:case s.NodeKind.FALSE:case s.NodeKind.NULL:{let r=this.resolveIdentifierExpression(e,n,o.Type.auto,t,i);return r?this.getElementOfType(r):null}}var a,l=e.text;if(a=n.lookup(l))return this.currentThisExpression=null,this.currentElementExpression=null,a;var u=n.outer;return u&&(a=u.lookup(l))||(a=t.lookup(l))||(a=this.program.lookup(l))?(this.currentThisExpression=null,this.currentElementExpression=null,a):(i==f.REPORT&&this.error(r.DiagnosticCode.Cannot_find_name_0,e.range,l),null)}resolveIdentifierExpression(e,n,t=o.Type.auto,a=n.actualFunction,l=f.REPORT){switch(e.kind){case s.NodeKind.TRUE:case s.NodeKind.FALSE:return o.Type.bool;case s.NodeKind.NULL:{let e=t.getClass();if(e)return e.type.asNullable();{let e=t.getSignature();if(e)return e.type.asNullable();if(t.isExternalReference)return t}return this.program.options.usizeType}}var c=this.lookupIdentifierExpression(e,n,a,l);if(!c)return null;if(c.kind==i.ElementKind.FUNCTION_PROTOTYPE){let e=this.resolveFunction(c,null,u.uniqueMap(),l);if(!e)return null;c=e}var p=this.getTypeOfElement(c);return p||l==f.REPORT&&this.error(r.DiagnosticCode.Expression_cannot_be_represented_by_a_type,e.range),p}ensureResolvedLazyGlobal(e,n=f.REPORT){if(e.is(l.CommonFlags.RESOLVED))return!0;var t,r=e.typeNode;return!!(t=r?this.resolveType(r,e.parent,null,n):this.resolveExpression(assert(e.initializerNode),e.file.startFunction.flow,o.Type.auto,n))&&(e.setType(t),!0)}lookupPropertyAccessExpression(e,n,t,a=f.REPORT){var s=e.expression,c=this.lookupExpression(s,n,t,a);if(!c)return null;var p=e.property.text;switch(c.kind){case i.ElementKind.GLOBAL:if(!this.ensureResolvedLazyGlobal(c,a))return null;case i.ElementKind.ENUMVALUE:case i.ElementKind.LOCAL:case i.ElementKind.FIELD:{let n=c,t=n.type;assert(t!=o.Type.void);let i=t.getClassOrWrapper(this.program);if(!i)return a==f.REPORT&&this.error(r.DiagnosticCode.Property_0_does_not_exist_on_type_1,e.property.range,p,n.type.toString()),null;c=i;break}case i.ElementKind.PROPERTY_PROTOTYPE:{let e=this.resolveProperty(c,a);if(!e)return null;c=e}case i.ElementKind.PROPERTY:{let n=assert(c.getterInstance).signature.returnType,t=n.getClassOrWrapper(this.program);if(!t)return a==f.REPORT&&this.error(r.DiagnosticCode.Property_0_does_not_exist_on_type_1,e.property.range,p,n.toString()),null;c=t;break}case i.ElementKind.INDEXSIGNATURE:{let n=c.parent;assert(n.kind==i.ElementKind.CLASS);let t=n,s=assert(this.currentElementExpression),o=t.lookupOverload(i.OperatorKind.INDEXED_GET);if(!o)return a==f.REPORT&&this.error(r.DiagnosticCode.Index_signature_is_missing_in_type_0,s.range,n.internalName),null;let l=o.signature.returnType,u=l.getClassOrWrapper(this.program);if(!u)return a==f.REPORT&&this.error(r.DiagnosticCode.Property_0_does_not_exist_on_type_1,e.property.range,p,l.toString()),null;c=u;break}case i.ElementKind.FUNCTION_PROTOTYPE:{let e=c.shadowType;if(e){if(!e.is(l.CommonFlags.RESOLVED)){let n=this.resolveType(e.typeNode,e.parent,null,a);n&&e.setType(n)}let n=e.type.classReference;n&&(c=n.prototype);break}if(!c.is(l.CommonFlags.GENERIC)){let e=c.members;if(!e||!e.has(p)){let e=this.resolveFunction(c,null,u.uniqueMap(),f.SWALLOW);if(e){let n=e.type.getClassOrWrapper(this.program);n&&(c=n)}}}break}}switch(c.kind){case i.ElementKind.CLASS_PROTOTYPE:case i.ElementKind.INTERFACE_PROTOTYPE:case i.ElementKind.CLASS:case i.ElementKind.INTERFACE:for(;;){let e=c.members;if(null!==e&&e.has(p)){let n=assert(e.get(p));if(n.kind==i.ElementKind.PROPERTY_PROTOTYPE){let e=this.resolveProperty(n,a);if(!e)return null;n=e,e.is(l.CommonFlags.STATIC)?this.currentThisExpression=null:this.currentThisExpression=s}else this.currentThisExpression=s;return this.currentElementExpression=null,n}if(c.kind==i.ElementKind.CLASS_PROTOTYPE||c.kind==i.ElementKind.INTERFACE_PROTOTYPE){let e=c.basePrototype;if(!e)break;c=e}else{if(c.kind!=i.ElementKind.CLASS&&c.kind!=i.ElementKind.INTERFACE)break;{let e=c.base;if(!e)break;c=e}}}break;default:{let e=c.members;if(null!==e&&e.has(p))return this.currentThisExpression=s,this.currentElementExpression=null,assert(e.get(p));break}}return a==f.REPORT&&this.error(r.DiagnosticCode.Property_0_does_not_exist_on_type_1,e.property.range,p,c.internalName),null}resolvePropertyAccessExpression(e,n,t,i=f.REPORT){var a=this.lookupPropertyAccessExpression(e,n,t,i);if(!a)return null;var s=this.getTypeOfElement(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Expression_cannot_be_represented_by_a_type,e.range),s}lookupElementAccessExpression(e,n,t,i=f.REPORT){var a=e.expression,s=this.resolveExpression(a,n,t,i);if(!s)return null;let o=s.getClassOrWrapper(this.program);if(o)do{let n=o.indexSignature;if(n)return this.currentThisExpression=a,this.currentElementExpression=e.elementExpression,n;o=o.base}while(o);return i==f.REPORT&&this.error(r.DiagnosticCode.Index_signature_is_missing_in_type_0,a.range,s.toString()),null}resolveElementAccessExpression(e,n,t,i=f.REPORT){var a=this.lookupElementAccessExpression(e,n,t,i);if(!a)return null;var s=this.getTypeOfElement(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Expression_cannot_be_represented_by_a_type,e.range),s}determineIntegerLiteralType(e,n){if(n.isValue)switch(n.kind){case 0:if(i64_is_i8(e))return o.Type.i8;break;case 5:if(i64_is_u8(e))return o.Type.u8;break;case 1:if(i64_is_i16(e))return o.Type.i16;break;case 6:if(i64_is_u16(e))return o.Type.u16;break;case 2:if(i64_is_i32(e))return o.Type.i32;break;case 7:if(i64_is_u32(e))return o.Type.u32;break;case 10:if(i64_is_bool(e))return o.Type.bool;break;case 4:if(!this.program.options.isWasm64){if(i64_is_i32(e))return o.Type.isize32;break}return o.Type.isize64;case 9:if(!this.program.options.isWasm64){if(i64_is_u32(e))return o.Type.usize32;break}return o.Type.usize64;case 3:return o.Type.i64;case 8:return o.Type.u64;case 11:return o.Type.f32;case 12:return o.Type.f64}return i64_is_i32(e)?o.Type.i32:i64_is_u32(e)?o.Type.u32:o.Type.i64}lookupAssertionExpression(e,n,t=o.Type.auto,i=f.REPORT){switch(e.assertionKind){case s.AssertionKind.AS:case s.AssertionKind.PREFIX:{let t=this.resolveType(assert(e.toType),n.actualFunction,n.contextualTypeArguments,i);if(!t)return null;let a=this.getElementOfType(t);return a||(i==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_illegal_in_this_context,e.range,t.toString()),this.currentThisExpression=null,this.currentElementExpression=null,null)}case s.AssertionKind.NONNULL:return this.lookupExpression(e.expression,n,t,i);case s.AssertionKind.CONST:return this.error(r.DiagnosticCode.Not_implemented_0,e.range,"Const assertion"),null}return assert(!1),null}resolveAssertionExpression(e,n,t=o.Type.auto,i=f.REPORT){switch(e.assertionKind){case s.AssertionKind.AS:case s.AssertionKind.PREFIX:return this.resolveType(assert(e.toType),n.actualFunction,n.contextualTypeArguments,i);case s.AssertionKind.NONNULL:{let r=this.resolveExpression(e.expression,n,t,i);return r?r.nonNullableType:null}case s.AssertionKind.CONST:{let a=this.lookupExpression(e,n,t,i);if(!a)return null;let s=this.getTypeOfElement(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Expression_cannot_be_represented_by_a_type,e.range),s}default:assert(!1)}return null}lookupUnaryPrefixExpression(e,n,t=o.Type.auto,i=f.REPORT){var a=this.resolveUnaryPrefixExpression(e,n,t,i);if(!a)return null;var s=this.getElementOfType(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,c.operatorTokenToString(e.operator),a.toString()),s}resolveUnaryPrefixExpression(e,n,t=o.Type.auto,a=f.REPORT){var l=e.operand,u=e.operator;switch(u){case c.Token.MINUS:if(l.isLiteralKind(s.LiteralKind.INTEGER))return this.determineIntegerLiteralType(i64_sub(i64_zero,l.value),t);case c.Token.PLUS:case c.Token.PLUS_PLUS:case c.Token.MINUS_MINUS:{let s=this.resolveExpression(l,n,t,a);if(!s)return null;let o=s.getClassOrWrapper(this.program);if(o){let e=o.lookupOverload(i.OperatorKind.fromUnaryPrefixToken(u));if(e)return e.signature.returnType}return s.isNumericValue?s:(a==f.REPORT&&this.error(r.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,c.operatorTokenToString(u),s.toString()),null)}case c.Token.EXCLAMATION:{let e=this.resolveExpression(l,n,t,a);if(!e)return null;let r=e.getClassOrWrapper(this.program);if(r){let e=r.lookupOverload(i.OperatorKind.NOT);if(e)return e.signature.returnType}return o.Type.bool}case c.Token.TILDE:{let s=this.resolveExpression(l,n,t,a);if(!s)return null;let o=s.getClassOrWrapper(this.program);if(o){let e=o.lookupOverload(i.OperatorKind.BITWISE_NOT);if(e)return e.signature.returnType}return s.isNumericValue?s.intType:(a==f.REPORT&&this.error(r.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,"~",s.toString()),null)}default:assert(!1)}return null}lookupUnaryPostfixExpression(e,n,t=o.Type.auto,i=f.REPORT){var a=this.resolveUnaryPostfixExpression(e,n,t,i);if(!a)return null;var s=this.getElementOfType(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,c.operatorTokenToString(e.operator),a.toString()),s}resolveUnaryPostfixExpression(e,n,t=o.Type.auto,a=f.REPORT){var s=e.operator;switch(s){case c.Token.PLUS_PLUS:case c.Token.MINUS_MINUS:{let o=this.resolveExpression(e.operand,n,t,a);if(!o)return null;let l=o.getClassOrWrapper(this.program);if(l){let e=l.lookupOverload(i.OperatorKind.fromUnaryPostfixToken(s));if(e)return e.signature.returnType}return o.isNumericValue?o:(a==f.REPORT&&this.error(r.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,c.operatorTokenToString(s),o.toString()),null)}}return assert(!1),null}lookupBinaryExpression(e,n,t=o.Type.auto,i=f.REPORT){var a=this.resolveBinaryExpression(e,n,t,i);if(!a)return null;var s=this.getElementOfType(a);return s||(i==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_illegal_in_this_context,e.range,a.toString()),null)}resolveBinaryExpression(e,n,t=o.Type.auto,a=f.REPORT){var s=e.left,l=e.right,u=e.operator;switch(u){case c.Token.EQUALS:case c.Token.PLUS_EQUALS:case c.Token.MINUS_EQUALS:case c.Token.ASTERISK_EQUALS:case c.Token.ASTERISK_ASTERISK_EQUALS:case c.Token.SLASH_EQUALS:case c.Token.PERCENT_EQUALS:case c.Token.LESSTHAN_LESSTHAN_EQUALS:case c.Token.GREATERTHAN_GREATERTHAN_EQUALS:case c.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:case c.Token.AMPERSAND_EQUALS:case c.Token.BAR_EQUALS:case c.Token.CARET_EQUALS:return this.resolveExpression(s,n,t,a);case c.Token.LESSTHAN:case c.Token.GREATERTHAN:case c.Token.LESSTHAN_EQUALS:case c.Token.GREATERTHAN_EQUALS:{let l=this.resolveExpression(s,n,t,a);if(!l)return null;let p=l.getClassOrWrapper(this.program);if(p){let e=p.lookupOverload(i.OperatorKind.fromBinaryToken(u));if(e)return e.signature.returnType}return l.isNumericValue?o.Type.bool:(a==f.REPORT&&this.error(r.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,c.operatorTokenToString(u),l.toString()),null)}case c.Token.EQUALS_EQUALS:case c.Token.EXCLAMATION_EQUALS:{let e=this.resolveExpression(s,n,t,a);if(!e)return null;let r=e.getClassOrWrapper(this.program);if(r){let e=r.lookupOverload(i.OperatorKind.fromBinaryToken(u));if(e)return e.signature.returnType}return o.Type.bool}case c.Token.EQUALS_EQUALS_EQUALS:case c.Token.EXCLAMATION_EQUALS_EQUALS:return o.Type.bool;case c.Token.PLUS:case c.Token.MINUS:case c.Token.ASTERISK:case c.Token.SLASH:case c.Token.PERCENT:{let c=this.resolveExpression(s,n,t,a);if(!c)return null;let p=c.getClassOrWrapper(this.program);if(p){let e=p.lookupOverload(i.OperatorKind.fromBinaryToken(u));if(e)return e.signature.returnType}let d=this.resolveExpression(l,n,c,a);if(!d)return null;let h=o.Type.commonDenominator(c,d,!1);return h||a==f.REPORT&&this.error(r.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,c.toString(),d.toString()),h}case c.Token.ASTERISK_ASTERISK:{let c=this.resolveExpression(s,n,t,a);if(!c)return null;let p=c.getClassOrWrapper(this.program);if(p){let e=p.lookupOverload(i.OperatorKind.fromBinaryToken(u));if(e)return e.signature.returnType}let d=this.resolveExpression(l,n,c,a);if(!d)return null;let h=o.Type.commonDenominator(c,d,!1);return h||a==f.REPORT&&this.error(r.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,c.toString(),d.toString()),h}case c.Token.LESSTHAN_LESSTHAN:case c.Token.GREATERTHAN_GREATERTHAN:case c.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:{let o=this.resolveExpression(s,n,t,a);if(!o)return null;let l=o.getClassOrWrapper(this.program);if(l){let e=l.lookupOverload(i.OperatorKind.fromBinaryToken(u));if(e)return e.signature.returnType}return o.isIntegerValue?o:(a==f.REPORT&&this.error(r.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,e.range,c.operatorTokenToString(u),o.toString()),null)}case c.Token.AMPERSAND:case c.Token.BAR:case c.Token.CARET:{let p=this.resolveExpression(s,n,t,a);if(!p)return null;let d=p.getClassOrWrapper(this.program);if(d){let e=d.lookupOverload(i.OperatorKind.fromBinaryToken(u));if(e)return e.signature.returnType}let h=this.resolveExpression(l,n,t,a);if(!h)return null;let g=o.Type.commonDenominator(p,h,!1);return g&&g.isIntegerValue||a==f.REPORT&&this.error(r.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,c.operatorTokenToString(u),p.toString(),h.toString()),g}case c.Token.AMPERSAND_AMPERSAND:case c.Token.BAR_BAR:return this.resolveExpression(s,n,t,a)}return assert(!1),null}lookupThisExpression(e,n,t=o.Type.auto,i=f.REPORT){if(n.isInline){let e=n.lookupLocal(l.CommonNames.this_);if(e)return this.currentThisExpression=null,this.currentElementExpression=null,e}var a=n.actualFunction.parent;return a?(this.currentThisExpression=null,this.currentElementExpression=null,a):(i==f.REPORT&&this.error(r.DiagnosticCode._this_cannot_be_referenced_in_current_location,e.range),null)}resolveThisExpression(e,n,t=o.Type.auto,i=f.REPORT){var a=this.lookupThisExpression(e,n,t,i);if(!a)return null;var s=this.getTypeOfElement(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Expression_cannot_be_represented_by_a_type,e.range),s}lookupSuperExpression(e,n,t=o.Type.auto,a=f.REPORT){if(n.isInline){let e=n.lookupLocal(l.CommonNames.super_);if(e)return this.currentThisExpression=null,this.currentElementExpression=null,e}var s=n.actualFunction.parent;if(null!==s&&s.kind==i.ElementKind.CLASS){let e=s.base;if(e)return this.currentThisExpression=null,this.currentElementExpression=null,e}return a==f.REPORT&&this.error(r.DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,e.range),null}resolveSuperExpression(e,n,t=o.Type.auto,i=f.REPORT){var a=this.lookupSuperExpression(e,n,t,i);if(!a)return null;var s=this.getTypeOfElement(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Expression_cannot_be_represented_by_a_type,e.range),s}lookupLiteralExpression(e,n,t=o.Type.auto,i=f.REPORT){switch(this.currentThisExpression=e,this.currentElementExpression=null,e.literalKind){case s.LiteralKind.INTEGER:{let n=this.determineIntegerLiteralType(e.value,t);return assert(n.getClassOrWrapper(this.program))}case s.LiteralKind.FLOAT:{let e=t==o.Type.f32?o.Type.f32:o.Type.f64;return assert(e.getClassOrWrapper(this.program))}case s.LiteralKind.STRING:return this.program.stringInstance;case s.LiteralKind.ARRAY:{let i=t.getClass();if(null!==i&&i.prototype==this.program.arrayPrototype)return this.getElementOfType(t);let a=e.elementExpressions,l=a.length,u=o.Type.auto,c=0;for(let e=0,t=l;e<t;++e){let t=a[e];if(t)if(t.kind==s.NodeKind.NULL&&l>1)++c;else{let e=this.resolveExpression(t,n,u);if(!e)return null;if(u==o.Type.auto)u=e;else if(e!=u){let n=o.Type.commonDenominator(u,e,!1);n&&(u=n)}}}if(u==o.Type.auto){if(c!=l)return this.error(r.DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,e.range,"T"),null;u=this.program.options.usizeType}return c>0&&u.isInternalReference&&(u=u.asNullable()),assert(this.resolveClass(this.program.arrayPrototype,[u]))}}return assert(!1),null}resolveLiteralExpression(e,n,t=o.Type.auto,i=f.REPORT){var a=this.lookupLiteralExpression(e,n,t,i);if(!a)return null;var s=this.getTypeOfElement(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Expression_cannot_be_represented_by_a_type,e.range),s}lookupCallExpression(e,n,t=o.Type.void,i=f.REPORT){var a=this.resolveCallExpression(e,n,t,i);if(!a)return null;var s=this.getElementOfType(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_illegal_in_this_context,e.range,a.toString()),s}resolveCallExpression(e,n,t=o.Type.void,a=f.REPORT){var s=e.expression,l=this.lookupExpression(s,n,t,a);if(!l)return null;switch(l.kind){case i.ElementKind.FUNCTION_PROTOTYPE:{let r=l;if(r.internalName==p.BuiltinNames.unchecked&&e.args.length>0)return this.resolveExpression(e.args[0],n,t,a);let i=this.maybeInferCall(e,r,n,a);return i?i.signature.returnType:null}case i.ElementKind.GLOBAL:case i.ElementKind.LOCAL:case i.ElementKind.FIELD:{let e=l.type,n=this.getElementOfType(e);if(!n||n.kind!=i.ElementKind.CLASS)break;l=n}case i.ElementKind.CLASS:{let e=l.getTypeArgumentsTo(this.program.functionPrototype);if(null!==e&&e.length>0){let n=e[0];return assert(n.signatureReference).returnType}break}}return a==f.REPORT&&this.error(r.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,s.range,l.internalName),null}lookupCommaExpression(e,n,t=o.Type.auto,r=f.REPORT){var i=e.expressions;return this.lookupExpression(i[assert(i.length)-1],n,t,r)}resolveCommaExpression(e,n,t=o.Type.auto,r=f.REPORT){var i=e.expressions;return this.resolveExpression(i[assert(i.length)-1],n,t,r)}lookupInstanceOfExpression(e,n,t=o.Type.auto,r=f.REPORT){return assert(o.Type.bool.getClassOrWrapper(this.program))}resolveInstanceOfExpression(e,n,t=o.Type.auto,r=f.REPORT){return o.Type.bool}lookupTernaryExpression(e,n,t,i=f.REPORT){var a=this.resolveTernaryExpression(e,n,t,i);if(!a)return null;var s=this.getElementOfType(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_illegal_in_this_context,e.range,a.toString()),s}resolveTernaryExpression(e,n,t,i=f.REPORT){var a=this.resolveExpression(e.ifThen,n,t,i);if(!a)return null;var s=this.resolveExpression(e.ifElse,n,a,i);if(!s)return null;var l=o.Type.commonDenominator(a,s,!1);return l||i==f.REPORT&&this.error(r.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,e.range,"?:",a.toString(),s.toString()),l}lookupNewExpression(e,n,t,a=f.REPORT){var s=this.resolveTypeName(e.typeName,n.actualFunction,a);return s?s.kind==i.ElementKind.CLASS_PROTOTYPE?this.resolveClassInclTypeArguments(s,e.typeArguments,n.actualFunction,u.uniqueMap(n.contextualTypeArguments),e,a):(a==f.REPORT&&this.error(r.DiagnosticCode.This_expression_is_not_constructable,e.range),null):null}resolveNewExpression(e,n,t,i=f.REPORT){var a=this.lookupNewExpression(e,n,t,i);if(!a)return null;var s=this.getTypeOfElement(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Expression_cannot_be_represented_by_a_type,e.range),s}lookupFunctionExpression(e,n,t,i=f.REPORT){var a=this.resolveFunctionExpression(e,n,t,i);if(!a)return null;var s=this.getElementOfType(a);return s||i==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_illegal_in_this_context,e.range,a.toString()),s}resolveFunctionExpression(e,n,t,r=f.REPORT){return this.resolveFunctionType(e.declaration.signature,n.actualFunction,n.contextualTypeArguments,r)}resolveFunction(e,n,t=u.uniqueMap(),a=f.REPORT){var c=e.parent.kind==i.ElementKind.PROPERTY_PROTOTYPE?e.parent.parent:e.parent,p=null,d=n?o.typesToString(n):"";if(e.is(l.CommonFlags.INSTANCE)){assert(c.kind==i.ElementKind.CLASS||c.kind==i.ElementKind.INTERFACE),p=c;let n=e.getResolvedInstance(d);if(n)return n;let r=p.typeArguments;if(r){let e=assert(p.prototype.typeParameterNodes),n=e.length;assert(n==e.length);for(let i=0;i<n;++i){let n=e[i].name.text;t.has(n)||t.set(n,r[i])}}}else{assert(c.kind!=i.ElementKind.CLASS);let n=e.getResolvedInstance(d);if(n)return n}var h,g=e.functionTypeNode,x=e.typeParameterNodes;if(null!==n&&(h=n.length)>0){assert(null!==x&&h==x.length);for(let e=0;e<h;++e)t.set(x[e].name.text,n[e])}else assert(!x||0==x.length);var m=null,_=g.explicitThisType;if(_){if(!(m=this.resolveType(_,e.parent,t,a)))return null;t.set(l.CommonNames.this_,m)}else p&&(m=p.type,t.set(l.CommonNames.this_,m));var y,E=g.parameters,T=E.length,b=new Array(T),v=0;for(let n=0;n<T;++n){let i=E[n];i.parameterKind==s.ParameterKind.DEFAULT&&(v=n+1);let l=i.type;if(s.isTypeOmitted(l))return a==f.REPORT&&this.error(r.DiagnosticCode.Type_expected,l.range),null;let u=this.resolveType(l,e.parent,t,a);if(!u)return null;if(u==o.Type.void)return a==f.REPORT&&this.error(r.DiagnosticCode.Type_expected,l.range),null;b[n]=u}if(e.is(l.CommonFlags.SET))y=o.Type.void;else if(e.is(l.CommonFlags.CONSTRUCTOR))y=p.type;else{let n=g.returnType;if(s.isTypeOmitted(n))return a==f.REPORT&&this.error(r.DiagnosticCode.Type_expected,n.range),null;let i=this.resolveType(n,e.parent,t,a);if(!i)return null;y=i}var A=new o.Signature(this.program,b,y,m);A.requiredParameters=v;var F=e.name;d.length&&(F+="<"+d+">");var C=new i.Function(F,e,n,A,t);return e.setResolvedInstance(d,C),C}resolveFunctionInclTypeArguments(e,n,t,a,s,o=f.REPORT){var u=e.parent.kind==i.ElementKind.PROPERTY_PROTOTYPE?e.parent.parent:e.parent,c=null;if(e.is(l.CommonFlags.GENERIC)){if(e.is(l.CommonFlags.INSTANCE)){assert(u.kind==i.ElementKind.CLASS);let e=u,n=e.typeArguments;if(n){let t=assert(e.prototype.typeParameterNodes),r=n.length;assert(r==t.length);for(let e=0;e<r;++e)a.set(t[e].name.text,n[e])}}if(!(c=this.resolveTypeArguments(assert(e.typeParameterNodes),n,t,a,s,o)))return null}else if(null!==n&&n.length>0)return o==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_not_generic,s.range,e.internalName),null;return this.resolveFunction(e,c,a,o)}resolveClass(e,n,t=u.uniqueMap(),a=f.REPORT){var s=n?o.typesToString(n):"",l=e.getResolvedInstance(s);if(l)return l;var c=e.name;s.length&&(c+="<"+s+">"),l=e.kind==i.ElementKind.INTERFACE_PROTOTYPE?new i.Interface(c,e,n):new i.Class(c,e,n),e.setResolvedInstance(s,l);var p=this.resolveClassPending;if(p.add(l),n){let r=assert(e.typeParameterNodes),i=r.length,a=n.length;assert(a==i);for(let e=0;e<a;++e)t.set(r[e].name.text,n[e])}else{let n=e.typeParameterNodes;assert(!(null!==n&&n.length>0))}l.contextualTypeArguments=t;var d=!1,h=e.basePrototype;if(h){let n=h;do{if(n==e)return this.error(r.DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,e.identifierNode.range,e.internalName),null;n=n.basePrototype}while(n);let i=assert(e.extendsNode),s=this.resolveClassInclTypeArguments(h,i.typeArguments,e.parent,u.uniqueMap(t),i,a);if(!s)return null;l.setBase(s),p.has(s)&&(d=!0)}var g=e.interfacePrototypes;if(g)for(let n=0,s=g.length;n<s;++n){let s=g[n],o=s;do{if(o==e)return this.error(r.DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,e.identifierNode.range,e.internalName),null;o=o.basePrototype}while(o);let c=assert(e.implementsNodes[n]),f=this.resolveClassInclTypeArguments(s,c.typeArguments,e.parent,u.uniqueMap(t),c,a);if(!f)return null;assert(f.kind==i.ElementKind.INTERFACE),l.addInterface(f),p.has(f)&&(d=!0)}return d||this.finishResolveClass(l,a),l}finishResolveClass(e,n){var t=e.members;t||(e.members=t=new Map);var a=this.resolveClassPending,s=new Map,c=e.interfaces;if(c)for(let e=Set_values(c),n=0,i=e.length;n<i;++n){let i=e[n];assert(!a.has(i));let o=i.members;if(o)for(let e=Map_keys(o),n=0,i=e.length;n<i;++n){let i=unchecked(e[n]),a=assert(o.get(i));if(t.has(i)){let e=assert(t.get(i));if(!a.isCompatibleOverride(e)){this.errorRelated(r.DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,a.identifierAndSignatureRange,e.identifierAndSignatureRange);continue}}t.set(i,a),s.set(i,a)}}var p=0,d=e.base;if(d){assert(!a.has(d));let e=d.members;if(e)for(let n=Map_keys(e),i=0,a=n.length;i<a;++i){let a=unchecked(n[i]),o=assert(e.get(a));if(t.has(a)){let e=assert(t.get(a));if(!o.isCompatibleOverride(e)){this.errorRelated(r.DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,o.identifierAndSignatureRange,e.identifierAndSignatureRange);continue}}t.set(a,o),o.is(l.CommonFlags.ABSTRACT)?s.set(a,o):s.delete(a)}p=d.nextMemoryOffset}var h=e.prototype,g=h.instanceMembers,x=new Array;if(g)for(let t=Map_values(g),a=0,c=t.length;a<c;++a){let c=unchecked(t[a]),g=c.name;switch(c.kind){case i.ElementKind.FIELD_PROTOTYPE:{let t=c,a=t.typeNode,s=null;if(a){if(s=this.resolveType(a,h.parent,e.contextualTypeArguments,n),s==o.Type.void){n==f.REPORT&&this.error(r.DiagnosticCode.Type_expected,a.range);break}}else{if(d){let e=d.members;if(null!==e&&e.has(t.name)){let n=assert(e.get(t.name));n.is(l.CommonFlags.PRIVATE)||(assert(n.kind==i.ElementKind.FIELD),s=n.type)}}s||n==f.REPORT&&this.error(r.DiagnosticCode.Type_expected,t.identifierNode.range.atEnd)}if(!s)break;let x=new i.Field(t,e,s);assert(u.isPowerOf2(s.byteSize));let m=s.byteSize-1;p&m&&(p=1+(p|m)),x.memoryOffset=p,p+=s.byteSize,e.add(g,x);break}case i.ElementKind.FUNCTION_PROTOTYPE:{let n=c.toBound(e);e.add(n.name,n);break}case i.ElementKind.PROPERTY_PROTOTYPE:{let n=c.toBound(e);e.add(n.name,n);break}default:assert(!1)}c.is(l.CommonFlags.ABSTRACT)||s.delete(g)}for(let e=0,n=x.length;e<n;++e){let n=x[e],t=n.getterInstance;if(t){let e=n.setterInstance;null===e||t.visibilityEquals(e)||this.errorRelated(r.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,t.identifierNode.range,e.identifierNode.range)}else this.error(r.DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,n.identifierNode.range,n.name)}if(e.kind!=i.ElementKind.INTERFACE){if(!e.is(l.CommonFlags.ABSTRACT)&&s.size>0)for(let n=Map_keys(s),t=0,i=n.length;t<i;++t){let i=n[t],a=assert(s.get(i));this.errorRelated(r.DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,e.identifierNode.range,a.identifierNode.range,e.internalName,i,a.parent.internalName)}e.nextMemoryOffset=p;{let t=e.lookupInSelf(l.CommonNames.constructor);if(null!==t&&t.parent===e){assert(t.kind==i.ElementKind.FUNCTION_PROTOTYPE);let r=this.resolveFunction(t,null,assert(e.contextualTypeArguments),n);r&&(e.constructorInstance=r)}}}var m=h.overloadPrototypes;for(let t=Map_keys(m),a=0,s=t.length;a<s;++a){let s,o=unchecked(t[a]),c=assert(m.get(o));if(assert(o!=i.OperatorKind.INVALID),c.is(l.CommonFlags.INSTANCE)){let t=c.toBound(e);s=this.resolveFunction(t,null,u.uniqueMap(),n)}else s=this.resolveFunction(c,null,u.uniqueMap(),n);if(!s)continue;let p=e.overloads;if(p||(e.overloads=p=new Map),s.is(l.CommonFlags.INSTANCE))switch(o){case i.OperatorKind.PREFIX_INC:case i.OperatorKind.PREFIX_DEC:case i.OperatorKind.POSTFIX_INC:case i.OperatorKind.POSTFIX_DEC:{let t=s.signature.returnType;t.isAssignableTo(e.type)||n==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_not_assignable_to_type_1,c.functionTypeNode.returnType.range,t.toString(),e.type.toString())}}if(p.has(o))n==f.REPORT&&this.error(r.DiagnosticCode.Duplicate_decorator,s.declaration.range);else if(p.set(o,s),o==i.OperatorKind.INDEXED_GET||o==i.OperatorKind.INDEXED_SET){let n=e.indexSignature;n||(e.indexSignature=n=new i.IndexSignature(e)),o==i.OperatorKind.INDEXED_GET&&n.setType(s.signature.returnType)}}assert(a.has(e)),a.delete(e);for(let t=Set_values(a),r=0,i=t.length;r<i;++r){let i=t[r],s=i.base===e,o=i.interfaces;if(o){let n=!1;for(let t=Set_values(o),r=0,i=t.length;r<i;++r){let i=t[r];i===e?s=!0:a.has(i)&&(n=!0)}if(n)continue}s&&this.finishResolveClass(i,n)}}resolveClassInclTypeArguments(e,n,t,i,a,s=f.REPORT){var o=null;if(e.is(l.CommonFlags.GENERIC)){if(!(o=this.resolveTypeArguments(assert(e.typeParameterNodes),n,t,i,a,s)))return null}else if(null!==n&&n.length>0)return s==f.REPORT&&this.error(r.DiagnosticCode.Type_0_is_not_generic,a.range,e.internalName),null;return this.resolveClass(e,o,i,s)}resolveProperty(e,n=f.REPORT){var t=e.instance;if(t)return t;e.instance=t=new i.Property(e,e);var r=e.getterPrototype;if(r){let e=this.resolveFunction(r,null,u.uniqueMap(),n);e&&(t.getterInstance=e,t.setType(e.signature.returnType))}var a=e.setterPrototype;if(a){let e=this.resolveFunction(a,null,u.uniqueMap(),n);e&&(t.setterInstance=e,t.is(l.CommonFlags.RESOLVED)||(assert(1==e.signature.parameterTypes.length),t.setType(e.signature.parameterTypes[0])))}return t}}n.Resolver=d},411:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.State=n.Tokenizer=n.Range=n.operatorTokenToString=n.isIllegalVariableIdentifier=n.tokenIsAlsoIdentifier=n.tokenFromKeyword=n.IdentifierHandling=n.Token=void 0;const r=t(256),i=t(60),a=t(910);var s,o;function l(e){switch(assert(e.length),e.charCodeAt(0)){case 97:if("abstract"==e)return s.ABSTRACT;if("as"==e)return s.AS;if("async"==e)return s.ASYNC;if("await"==e)return s.AWAIT;break;case 98:if("break"==e)return s.BREAK;break;case 99:if("case"==e)return s.CASE;if("catch"==e)return s.CATCH;if("class"==e)return s.CLASS;if("continue"==e)return s.CONTINUE;if("const"==e)return s.CONST;if("constructor"==e)return s.CONSTRUCTOR;break;case 100:if("debugger"==e)return s.DEBUGGER;if("declare"==e)return s.DECLARE;if("default"==e)return s.DEFAULT;if("delete"==e)return s.DELETE;if("do"==e)return s.DO;break;case 101:if("else"==e)return s.ELSE;if("enum"==e)return s.ENUM;if("export"==e)return s.EXPORT;if("extends"==e)return s.EXTENDS;break;case 102:if("false"==e)return s.FALSE;if("finally"==e)return s.FINALLY;if("for"==e)return s.FOR;if("from"==e)return s.FROM;if("function"==e)return s.FUNCTION;break;case 103:if("get"==e)return s.GET;break;case 105:if("if"==e)return s.IF;if("implements"==e)return s.IMPLEMENTS;if("import"==e)return s.IMPORT;if("in"==e)return s.IN;if("instanceof"==e)return s.INSTANCEOF;if("interface"==e)return s.INTERFACE;if("is"==e)return s.IS;break;case 107:if("keyof"==e)return s.KEYOF;break;case 108:if("let"==e)return s.LET;break;case 109:if("module"==e)return s.MODULE;break;case 110:if("namespace"==e)return s.NAMESPACE;if("new"==e)return s.NEW;if("null"==e)return s.NULL;break;case 111:if("of"==e)return s.OF;break;case 112:if("package"==e)return s.PACKAGE;if("private"==e)return s.PRIVATE;if("protected"==e)return s.PROTECTED;if("public"==e)return s.PUBLIC;break;case 114:if("readonly"==e)return s.READONLY;if("return"==e)return s.RETURN;break;case 115:if("set"==e)return s.SET;if("static"==e)return s.STATIC;if("super"==e)return s.SUPER;if("switch"==e)return s.SWITCH;break;case 116:if("this"==e)return s.THIS;if("throw"==e)return s.THROW;if("true"==e)return s.TRUE;if("try"==e)return s.TRY;if("type"==e)return s.TYPE;if("typeof"==e)return s.TYPEOF;break;case 118:if("var"==e)return s.VAR;if("void"==e)return s.VOID;break;case 119:if("while"==e)return s.WHILE;if("with"==e)return s.WITH;break;case 121:if("yield"==e)return s.YIELD}return s.INVALID}function u(e){switch(e){case s.ABSTRACT:case s.AS:case s.CONSTRUCTOR:case s.DECLARE:case s.DELETE:case s.FROM:case s.FOR:case s.GET:case s.INSTANCEOF:case s.IS:case s.KEYOF:case s.MODULE:case s.NAMESPACE:case s.NULL:case s.READONLY:case s.SET:case s.TYPE:case s.VOID:return!0;default:return!1}}!function(e){e[e.ABSTRACT=0]="ABSTRACT",e[e.AS=1]="AS",e[e.ASYNC=2]="ASYNC",e[e.AWAIT=3]="AWAIT",e[e.BREAK=4]="BREAK",e[e.CASE=5]="CASE",e[e.CATCH=6]="CATCH",e[e.CLASS=7]="CLASS",e[e.CONST=8]="CONST",e[e.CONTINUE=9]="CONTINUE",e[e.CONSTRUCTOR=10]="CONSTRUCTOR",e[e.DEBUGGER=11]="DEBUGGER",e[e.DECLARE=12]="DECLARE",e[e.DEFAULT=13]="DEFAULT",e[e.DELETE=14]="DELETE",e[e.DO=15]="DO",e[e.ELSE=16]="ELSE",e[e.ENUM=17]="ENUM",e[e.EXPORT=18]="EXPORT",e[e.EXTENDS=19]="EXTENDS",e[e.FALSE=20]="FALSE",e[e.FINALLY=21]="FINALLY",e[e.FOR=22]="FOR",e[e.FROM=23]="FROM",e[e.FUNCTION=24]="FUNCTION",e[e.GET=25]="GET",e[e.IF=26]="IF",e[e.IMPLEMENTS=27]="IMPLEMENTS",e[e.IMPORT=28]="IMPORT",e[e.IN=29]="IN",e[e.INSTANCEOF=30]="INSTANCEOF",e[e.INTERFACE=31]="INTERFACE",e[e.IS=32]="IS",e[e.KEYOF=33]="KEYOF",e[e.LET=34]="LET",e[e.MODULE=35]="MODULE",e[e.NAMESPACE=36]="NAMESPACE",e[e.NEW=37]="NEW",e[e.NULL=38]="NULL",e[e.OF=39]="OF",e[e.PACKAGE=40]="PACKAGE",e[e.PRIVATE=41]="PRIVATE",e[e.PROTECTED=42]="PROTECTED",e[e.PUBLIC=43]="PUBLIC",e[e.READONLY=44]="READONLY",e[e.RETURN=45]="RETURN",e[e.SET=46]="SET",e[e.STATIC=47]="STATIC",e[e.SUPER=48]="SUPER",e[e.SWITCH=49]="SWITCH",e[e.THIS=50]="THIS",e[e.THROW=51]="THROW",e[e.TRUE=52]="TRUE",e[e.TRY=53]="TRY",e[e.TYPE=54]="TYPE",e[e.TYPEOF=55]="TYPEOF",e[e.VAR=56]="VAR",e[e.VOID=57]="VOID",e[e.WHILE=58]="WHILE",e[e.WITH=59]="WITH",e[e.YIELD=60]="YIELD",e[e.OPENBRACE=61]="OPENBRACE",e[e.CLOSEBRACE=62]="CLOSEBRACE",e[e.OPENPAREN=63]="OPENPAREN",e[e.CLOSEPAREN=64]="CLOSEPAREN",e[e.OPENBRACKET=65]="OPENBRACKET",e[e.CLOSEBRACKET=66]="CLOSEBRACKET",e[e.DOT=67]="DOT",e[e.DOT_DOT_DOT=68]="DOT_DOT_DOT",e[e.SEMICOLON=69]="SEMICOLON",e[e.COMMA=70]="COMMA",e[e.LESSTHAN=71]="LESSTHAN",e[e.GREATERTHAN=72]="GREATERTHAN",e[e.LESSTHAN_EQUALS=73]="LESSTHAN_EQUALS",e[e.GREATERTHAN_EQUALS=74]="GREATERTHAN_EQUALS",e[e.EQUALS_EQUALS=75]="EQUALS_EQUALS",e[e.EXCLAMATION_EQUALS=76]="EXCLAMATION_EQUALS",e[e.EQUALS_EQUALS_EQUALS=77]="EQUALS_EQUALS_EQUALS",e[e.EXCLAMATION_EQUALS_EQUALS=78]="EXCLAMATION_EQUALS_EQUALS",e[e.EQUALS_GREATERTHAN=79]="EQUALS_GREATERTHAN",e[e.PLUS=80]="PLUS",e[e.MINUS=81]="MINUS",e[e.ASTERISK_ASTERISK=82]="ASTERISK_ASTERISK",e[e.ASTERISK=83]="ASTERISK",e[e.SLASH=84]="SLASH",e[e.PERCENT=85]="PERCENT",e[e.PLUS_PLUS=86]="PLUS_PLUS",e[e.MINUS_MINUS=87]="MINUS_MINUS",e[e.LESSTHAN_LESSTHAN=88]="LESSTHAN_LESSTHAN",e[e.GREATERTHAN_GREATERTHAN=89]="GREATERTHAN_GREATERTHAN",e[e.GREATERTHAN_GREATERTHAN_GREATERTHAN=90]="GREATERTHAN_GREATERTHAN_GREATERTHAN",e[e.AMPERSAND=91]="AMPERSAND",e[e.BAR=92]="BAR",e[e.CARET=93]="CARET",e[e.EXCLAMATION=94]="EXCLAMATION",e[e.TILDE=95]="TILDE",e[e.AMPERSAND_AMPERSAND=96]="AMPERSAND_AMPERSAND",e[e.BAR_BAR=97]="BAR_BAR",e[e.QUESTION=98]="QUESTION",e[e.COLON=99]="COLON",e[e.EQUALS=100]="EQUALS",e[e.PLUS_EQUALS=101]="PLUS_EQUALS",e[e.MINUS_EQUALS=102]="MINUS_EQUALS",e[e.ASTERISK_EQUALS=103]="ASTERISK_EQUALS",e[e.ASTERISK_ASTERISK_EQUALS=104]="ASTERISK_ASTERISK_EQUALS",e[e.SLASH_EQUALS=105]="SLASH_EQUALS",e[e.PERCENT_EQUALS=106]="PERCENT_EQUALS",e[e.LESSTHAN_LESSTHAN_EQUALS=107]="LESSTHAN_LESSTHAN_EQUALS",e[e.GREATERTHAN_GREATERTHAN_EQUALS=108]="GREATERTHAN_GREATERTHAN_EQUALS",e[e.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS=109]="GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS",e[e.AMPERSAND_EQUALS=110]="AMPERSAND_EQUALS",e[e.BAR_EQUALS=111]="BAR_EQUALS",e[e.CARET_EQUALS=112]="CARET_EQUALS",e[e.AT=113]="AT",e[e.IDENTIFIER=114]="IDENTIFIER",e[e.STRINGLITERAL=115]="STRINGLITERAL",e[e.INTEGERLITERAL=116]="INTEGERLITERAL",e[e.FLOATLITERAL=117]="FLOATLITERAL",e[e.INVALID=118]="INVALID",e[e.ENDOFFILE=119]="ENDOFFILE"}(s=n.Token||(n.Token={})),function(e){e[e.DEFAULT=0]="DEFAULT",e[e.PREFER=1]="PREFER",e[e.ALWAYS=2]="ALWAYS"}(o=n.IdentifierHandling||(n.IdentifierHandling={})),n.tokenFromKeyword=l,n.tokenIsAlsoIdentifier=u,n.isIllegalVariableIdentifier=function(e){switch(assert(e.length),e.charCodeAt(0)){case 100:return"delete"==e;case 102:return"for"==e;case 105:return"instanceof"==e;case 110:return"null"==e;case 118:return"void"==e}return!1},n.operatorTokenToString=function(e){switch(e){case s.DELETE:return"delete";case s.IN:return"in";case s.INSTANCEOF:return"instanceof";case s.NEW:return"new";case s.TYPEOF:return"typeof";case s.VOID:return"void";case s.YIELD:return"yield";case s.DOT_DOT_DOT:return"...";case s.COMMA:return",";case s.LESSTHAN:return"<";case s.GREATERTHAN:return">";case s.LESSTHAN_EQUALS:return"<=";case s.GREATERTHAN_EQUALS:return">=";case s.EQUALS_EQUALS:return"==";case s.EXCLAMATION_EQUALS:return"!=";case s.EQUALS_EQUALS_EQUALS:return"===";case s.EXCLAMATION_EQUALS_EQUALS:return"!==";case s.PLUS:return"+";case s.MINUS:return"-";case s.ASTERISK_ASTERISK:return"**";case s.ASTERISK:return"*";case s.SLASH:return"/";case s.PERCENT:return"%";case s.PLUS_PLUS:return"++";case s.MINUS_MINUS:return"--";case s.LESSTHAN_LESSTHAN:return"<<";case s.GREATERTHAN_GREATERTHAN:return">>";case s.GREATERTHAN_GREATERTHAN_GREATERTHAN:return">>>";case s.AMPERSAND:return"&";case s.BAR:return"|";case s.CARET:return"^";case s.EXCLAMATION:return"!";case s.TILDE:return"~";case s.AMPERSAND_AMPERSAND:return"&&";case s.BAR_BAR:return"||";case s.EQUALS:return"=";case s.PLUS_EQUALS:return"+=";case s.MINUS_EQUALS:return"-=";case s.ASTERISK_EQUALS:return"*=";case s.ASTERISK_ASTERISK_EQUALS:return"**=";case s.SLASH_EQUALS:return"/=";case s.PERCENT_EQUALS:return"%=";case s.LESSTHAN_LESSTHAN_EQUALS:return"<<=";case s.GREATERTHAN_GREATERTHAN_EQUALS:return">>=";case s.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:return">>>=";case s.AMPERSAND_EQUALS:return"&=";case s.BAR_EQUALS:return"|=";case s.CARET_EQUALS:return"^=";default:return assert(!1),""}};class c{constructor(e,n){this.debugInfoRef=0,this.start=e,this.end=n}static join(e,n){if(e.source!=n.source)throw new Error("source mismatch");let t=new c(e.start<n.start?e.start:n.start,e.end>n.end?e.end:n.end);return t.source=e.source,t}equals(e){return this.source==e.source&&this.start==e.start&&this.end==e.end}get atStart(){let e=new c(this.start,this.start);return e.source=this.source,e}get atEnd(){let e=new c(this.end,this.end);return e.source=this.source,e}toString(){return this.source.text.substring(this.start,this.end)}}n.Range=c;class p extends r.DiagnosticEmitter{constructor(e,n=null){super(n),this.end=0,this.pos=0,this.token=-1,this.tokenPos=0,this.nextToken=-1,this.nextTokenPos=0,this.nextTokenOnNewLine=!1,this.onComment=null,n||(n=[]),this.diagnostics=n,this.source=e;var t=e.text,r=t.length,i=0;if(i<r&&65279==t.charCodeAt(i)&&++i,i+1<r&&35==t.charCodeAt(i)&&33==t.charCodeAt(i+1))for(i+=2;i<r&&10!=t.charCodeAt(i);)++i;this.pos=i,this.end=r}next(e=o.DEFAULT){var n;this.nextToken=-1;do{n=this.unsafeNext(e)}while(n==s.INVALID);return this.token=n,n}unsafeNext(e=o.DEFAULT,n=i32.MAX_VALUE){for(var t=this.source.text,c=this.end,p=this.pos;p<c;){this.tokenPos=p;let f=t.charCodeAt(p);switch(f){case 13:if(!(++p<c&&10==t.charCodeAt(p)))break;case 10:case 9:case 11:case 12:case 32:++p;break;case 33:return++p,n>1&&p<c&&61==t.charCodeAt(p)?(++p,n>2&&p<c&&61==t.charCodeAt(p)?(this.pos=p+1,s.EXCLAMATION_EQUALS_EQUALS):(this.pos=p,s.EXCLAMATION_EQUALS)):(this.pos=p,s.EXCLAMATION);case 34:case 39:case 96:return this.pos=p,s.STRINGLITERAL;case 37:return++p,n>1&&p<c&&61==t.charCodeAt(p)?(this.pos=p+1,s.PERCENT_EQUALS):(this.pos=p,s.PERCENT);case 38:if(++p,n>1&&p<c){let e=t.charCodeAt(p);if(38==e)return this.pos=p+1,s.AMPERSAND_AMPERSAND;if(61==e)return this.pos=p+1,s.AMPERSAND_EQUALS}return this.pos=p,s.AMPERSAND;case 40:return this.pos=p+1,s.OPENPAREN;case 41:return this.pos=p+1,s.CLOSEPAREN;case 42:if(++p,n>1&&p<c){let e=t.charCodeAt(p);if(61==e)return this.pos=p+1,s.ASTERISK_EQUALS;if(42==e)return++p,n>2&&p<c&&61==t.charCodeAt(p)?(this.pos=p+1,s.ASTERISK_ASTERISK_EQUALS):(this.pos=p,s.ASTERISK_ASTERISK)}return this.pos=p,s.ASTERISK;case 43:if(++p,n>1&&p<c){let e=t.charCodeAt(p);if(43==e)return this.pos=p+1,s.PLUS_PLUS;if(61==e)return this.pos=p+1,s.PLUS_EQUALS}return this.pos=p,s.PLUS;case 44:return this.pos=p+1,s.COMMA;case 45:if(++p,n>1&&p<c){let e=t.charCodeAt(p);if(45==e)return this.pos=p+1,s.MINUS_MINUS;if(61==e)return this.pos=p+1,s.MINUS_EQUALS}return this.pos=p,s.MINUS;case 46:if(++p,n>1&&p<c){let e=t.charCodeAt(p);if(a.isDecimalDigit(e))return this.pos=p-1,s.FLOATLITERAL;if(n>2&&p+1<c&&46==e&&46==t.charCodeAt(p+1))return this.pos=p+2,s.DOT_DOT_DOT}return this.pos=p,s.DOT;case 47:{let e=p;if(++p,n>1&&p<c){let n=t.charCodeAt(p);if(47==n){let n=i.CommentKind.LINE;for(p+1<c&&47==t.charCodeAt(p+1)&&(++p,n=i.CommentKind.TRIPLE);++p<c;)if(10==t.charCodeAt(p)){++p;break}this.onComment&&this.onComment(n,t.substring(e,p),this.range(e,p));break}if(42==n){let n=!1;for(;++p<c;)if(f=t.charCodeAt(p),42==f&&p+1<c&&47==t.charCodeAt(p+1)){p+=2,n=!0;break}n?this.onComment&&this.onComment(i.CommentKind.BLOCK,t.substring(e,p),this.range(e,p)):this.error(r.DiagnosticCode._0_expected,this.range(p),"*/");break}if(61==n)return this.pos=p+1,s.SLASH_EQUALS}return this.pos=p,s.SLASH}case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.pos=p,this.testInteger()?s.INTEGERLITERAL:s.FLOATLITERAL;case 58:return this.pos=p+1,s.COLON;case 59:return this.pos=p+1,s.SEMICOLON;case 60:if(++p,n>1&&p<c){let e=t.charCodeAt(p);if(60==e)return++p,n>2&&p<c&&61==t.charCodeAt(p)?(this.pos=p+1,s.LESSTHAN_LESSTHAN_EQUALS):(this.pos=p,s.LESSTHAN_LESSTHAN);if(61==e)return this.pos=p+1,s.LESSTHAN_EQUALS}return this.pos=p,s.LESSTHAN;case 61:if(++p,n>1&&p<c){let e=t.charCodeAt(p);if(61==e)return++p,n>2&&p<c&&61==t.charCodeAt(p)?(this.pos=p+1,s.EQUALS_EQUALS_EQUALS):(this.pos=p,s.EQUALS_EQUALS);if(62==e)return this.pos=p+1,s.EQUALS_GREATERTHAN}return this.pos=p,s.EQUALS;case 62:if(++p,n>1&&p<c){let e=t.charCodeAt(p);if(62==e){if(++p,n>2&&p<c){if(e=t.charCodeAt(p),62==e)return++p,n>3&&p<c&&61==t.charCodeAt(p)?(this.pos=p+1,s.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS):(this.pos=p,s.GREATERTHAN_GREATERTHAN_GREATERTHAN);if(61==e)return this.pos=p+1,s.GREATERTHAN_GREATERTHAN_EQUALS}return this.pos=p,s.GREATERTHAN_GREATERTHAN}if(61==e)return this.pos=p+1,s.GREATERTHAN_EQUALS}return this.pos=p,s.GREATERTHAN;case 63:return this.pos=p+1,s.QUESTION;case 91:return this.pos=p+1,s.OPENBRACKET;case 93:return this.pos=p+1,s.CLOSEBRACKET;case 94:return++p,n>1&&p<c&&61==t.charCodeAt(p)?(this.pos=p+1,s.CARET_EQUALS):(this.pos=p,s.CARET);case 123:return this.pos=p+1,s.OPENBRACE;case 124:if(++p,n>1&&p<c){let e=t.charCodeAt(p);if(124==e)return this.pos=p+1,s.BAR_BAR;if(61==e)return this.pos=p+1,s.BAR_EQUALS}return this.pos=p,s.BAR;case 125:return this.pos=p+1,s.CLOSEBRACE;case 126:return this.pos=p+1,s.TILDE;case 64:return this.pos=p+1,s.AT;default:{if(a.isIdentifierStart(f)){if(a.isKeywordCharacter(f)){let n=p;for(;++p<c&&a.isIdentifierPart(f=t.charCodeAt(p));)if(!a.isKeywordCharacter(f))return this.pos=n,s.IDENTIFIER;let r=l(t.substring(n,p));if(r!==s.INVALID&&e!==o.ALWAYS&&(e!==o.PREFER||!u(r)))return this.pos=p,r;this.pos=p=n}return this.pos=p,s.IDENTIFIER}if(a.isWhiteSpace(f)){++p;break}let n=p++;return 55296==(64512&f)&&p<c&&56320==(64512&t.charCodeAt(p))&&++p,this.error(r.DiagnosticCode.Invalid_character,this.range(n,p)),this.pos=p,s.INVALID}}}return this.pos=p,s.ENDOFFILE}peek(e=!1,n=o.DEFAULT,t=i32.MAX_VALUE){var r=this.source.text;if(this.nextToken<0){let i,o=this.pos,l=this.token,u=this.tokenPos;do{i=this.unsafeNext(n,t)}while(i==s.INVALID);if(this.nextToken=i,this.nextTokenPos=this.tokenPos,e){this.nextTokenOnNewLine=!1;for(let e=o,n=this.nextTokenPos;e<n;++e)if(a.isLineBreak(r.charCodeAt(e))){this.nextTokenOnNewLine=!0;break}}this.pos=o,this.token=l,this.tokenPos=u}return this.nextToken}skipIdentifier(e=o.PREFER){return this.skip(s.IDENTIFIER,e)}skip(e,n=o.DEFAULT){var t,r=this.pos,i=this.token,a=this.tokenPos,l=i32.MAX_VALUE;e==s.GREATERTHAN&&(l=1);do{t=this.unsafeNext(n,l)}while(t==s.INVALID);return t==e?(this.token=e,this.nextToken=-1,!0):(this.pos=r,this.token=i,this.tokenPos=a,!1)}mark(){var e=d;return e?(d=null,e.pos=this.pos,e.token=this.token,e.tokenPos=this.tokenPos):e=new f(this.pos,this.token,this.tokenPos),e}discard(e){d=e}reset(e){this.pos=e.pos,this.token=e.token,this.tokenPos=e.tokenPos,this.nextToken=-1}range(e=-1,n=-1){e<0?(e=this.tokenPos,n=this.pos):n<0&&(n=e);let t=new c(e,n);return t.source=this.source,t}readIdentifier(){for(var e=this.source.text,n=this.end,t=this.pos,r=t;++t<n&&a.isIdentifierPart(e.charCodeAt(t)););return this.pos=t,e.substring(r,t)}readString(){for(var e=this.source.text,n=this.end,t=this.pos,i=e.charCodeAt(t++),s=t,o="";;){if(t>=n){o+=e.substring(s,t),this.error(r.DiagnosticCode.Unterminated_string_literal,this.range(s-1,n));break}let l=e.charCodeAt(t);if(l==i){o+=e.substring(s,t++);break}if(92!=l){if(a.isLineBreak(l)&&96!=i){o+=e.substring(s,t),this.error(r.DiagnosticCode.Unterminated_string_literal,this.range(s-1,t));break}++t}else o+=e.substring(s,t),this.pos=t,o+=this.readEscapeSequence(),s=t=this.pos}return this.pos=t,o}readEscapeSequence(){var e=this.end;if(++this.pos>=e)return this.error(r.DiagnosticCode.Unexpected_end_of_text,this.range(e)),"";var n=this.source.text,t=n.charCodeAt(this.pos++);switch(t){case 48:return"\0";case 98:return"\b";case 116:return"\t";case 110:return"\n";case 118:return"\v";case 102:return"\f";case 114:return"\r";case 39:return"'";case 34:return'"';case 117:return this.pos<e&&123==n.charCodeAt(this.pos)?(++this.pos,this.readExtendedUnicodeEscape()):this.readUnicodeEscape();case 120:return this.readHexadecimalEscape();case 13:this.pos<e&&10==n.charCodeAt(this.pos)&&++this.pos;case 10:case 8232:case 8233:return"";default:return String.fromCharCode(t)}}readRegexpPattern(){for(var e=this.source.text,n=this.pos,t=this.end,i=!1;;){if(this.pos>=t){this.error(r.DiagnosticCode.Unterminated_regular_expression_literal,this.range(n,t));break}if(92==e.charCodeAt(this.pos)){++this.pos,i=!0;continue}let s=e.charCodeAt(this.pos);if(!i&&47==s)break;if(a.isLineBreak(s)){this.error(r.DiagnosticCode.Unterminated_regular_expression_literal,this.range(n,this.pos));break}++this.pos,i=!1}return e.substring(n,this.pos)}readRegexpFlags(){for(var e=this.source.text,n=this.pos,t=this.end,i=0;this.pos<t;){let n=e.charCodeAt(this.pos);if(!a.isIdentifierPart(n))break;switch(++this.pos,n){case 103:i|=1&i?-1:1;break;case 105:i|=2&i?-1:2;break;case 109:i|=4&i?-1:4;break;default:i=-1}}return-1==i&&this.error(r.DiagnosticCode.Invalid_regular_expression_flags,this.range(n,this.pos)),e.substring(n,this.pos)}testInteger(){var e=this.source.text,n=this.pos,t=this.end;if(n+1<t&&48==e.charCodeAt(n))switch(32|e.charCodeAt(n+2)){case 120:case 98:case 111:return!0}for(;n<t;){let t=e.charCodeAt(n);if(46==t||101==(32|t))return!1;if(95!=t&&(t<48||t>57))break;n++}return!0}readInteger(){var e=this.source.text,n=this.pos;if(n+2<this.end&&48==e.charCodeAt(n)){switch(32|e.charCodeAt(n+1)){case 120:return this.pos=n+2,this.readHexInteger();case 98:return this.pos=n+2,this.readBinaryInteger();case 111:return this.pos=n+2,this.readOctalInteger()}if(a.isOctalDigit(e.charCodeAt(n+1))){let e=n;this.pos=n+1;let t=this.readOctalInteger();return this.error(r.DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,this.range(e,this.pos)),t}}return this.readDecimalInteger()}readHexInteger(){var e=this.source.text;let n=this.pos;for(var t=this.end,i=n,a=i,s=i64_new(0),o=i64_new(4);n<t;){let t=e.charCodeAt(n);if(t>=48&&t<=57)s=i64_add(i64_shl(s,o),i64_new(t-48));else if(t>=65&&t<=70)s=i64_add(i64_shl(s,o),i64_new(10+t-65));else if(t>=97&&t<=102)s=i64_add(i64_shl(s,o),i64_new(10+t-97));else{if(95!=t)break;a==n&&this.error(a==i?r.DiagnosticCode.Numeric_separators_are_not_allowed_here:r.DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,this.range(n)),a=n+1}++n}return n==i?this.error(r.DiagnosticCode.Hexadecimal_digit_expected,this.range(i)):a==n&&this.error(r.DiagnosticCode.Numeric_separators_are_not_allowed_here,this.range(a-1)),this.pos=n,s}readDecimalInteger(){for(var e=this.source.text,n=this.pos,t=this.end,i=n,a=i,s=i64_new(0),o=i64_new(10);n<t;){let t=e.charCodeAt(n);if(t>=48&&t<=57)s=i64_add(i64_mul(s,o),i64_new(t-48));else{if(95!=t)break;a==n?this.error(a==i?r.DiagnosticCode.Numeric_separators_are_not_allowed_here:r.DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,this.range(n)):n-1==i&&48==e.charCodeAt(n-1)&&this.error(r.DiagnosticCode.Numeric_separators_are_not_allowed_here,this.range(n)),a=n+1}++n}return n==i?this.error(r.DiagnosticCode.Digit_expected,this.range(i)):a==n&&this.error(r.DiagnosticCode.Numeric_separators_are_not_allowed_here,this.range(a-1)),this.pos=n,s}readOctalInteger(){for(var e=this.source.text,n=this.pos,t=this.end,i=n,a=i,s=i64_new(0),o=i64_new(3);n<t;){let t=e.charCodeAt(n);if(t>=48&&t<=55)s=i64_add(i64_shl(s,o),i64_new(t-48));else{if(95!=t)break;a==n&&this.error(a==i?r.DiagnosticCode.Numeric_separators_are_not_allowed_here:r.DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,this.range(n)),a=n+1}++n}return n==i?this.error(r.DiagnosticCode.Octal_digit_expected,this.range(i)):a==n&&this.error(r.DiagnosticCode.Numeric_separators_are_not_allowed_here,this.range(a-1)),this.pos=n,s}readBinaryInteger(){for(var e=this.source.text,n=this.pos,t=this.end,i=n,a=i,s=i64_new(0),o=i64_new(1);n<t;){let t=e.charCodeAt(n);if(48==t)s=i64_shl(s,o);else if(49==t)s=i64_add(i64_shl(s,o),o);else{if(95!=t)break;a==n&&this.error(a==i?r.DiagnosticCode.Numeric_separators_are_not_allowed_here:r.DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,this.range(n)),a=n+1}++n}return n==i?this.error(r.DiagnosticCode.Binary_digit_expected,this.range(i)):a==n&&this.error(r.DiagnosticCode.Numeric_separators_are_not_allowed_here,this.range(a-1)),this.pos=n,s}readFloat(){return this.readDecimalFloat()}readDecimalFloat(){var e=this.source.text,n=this.end,t=this.pos,r=this.readDecimalFloatPartial(!1);if(this.pos<n&&46==e.charCodeAt(this.pos)&&(++this.pos,r+=this.readDecimalFloatPartial()),this.pos<n){let t=e.charCodeAt(this.pos);101==(32|t)&&((++this.pos<n&&45==(t=e.charCodeAt(this.pos))||43==t&&a.isDecimalDigit(e.charCodeAt(this.pos+1)))&&++this.pos,r+=this.readDecimalFloatPartial())}let i=e.substring(t,this.pos);return r&&(i=i.replaceAll("_","")),parseFloat(i)}readDecimalFloatPartial(e=!0){for(var n=this.source.text,t=this.pos,i=t,s=this.end,o=i,l=0;t<s;){let s=n.charCodeAt(t);if(95==s)o==t?this.error(o==i?r.DiagnosticCode.Numeric_separators_are_not_allowed_here:r.DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,this.range(t)):e||t-1!=i||48!=n.charCodeAt(t-1)||this.error(r.DiagnosticCode.Numeric_separators_are_not_allowed_here,this.range(t)),o=t+1,++l;else if(!a.isDecimalDigit(s))break;++t}return t!=i&&o==t&&this.error(r.DiagnosticCode.Numeric_separators_are_not_allowed_here,this.range(o-1)),this.pos=t,l}readHexFloat(){throw new Error("not implemented")}readHexadecimalEscape(e=2){for(var n=0,t=this.source.text,i=this.pos,a=this.end;i<a;){let a=t.charCodeAt(i++);if(a>=48&&a<=57)n=(n<<4)+a-48;else if(a>=65&&a<=70)n=(n<<4)+a+-55;else{if(!(a>=97&&a<=102))return this.error(r.DiagnosticCode.Hexadecimal_digit_expected,this.range(i-1,i)),this.pos=i,"";n=(n<<4)+a+-87}if(0==--e)break}return e?(this.error(r.DiagnosticCode.Unexpected_end_of_text,this.range(i)),this.pos=i,""):(this.pos=i,String.fromCharCode(n))}checkForIdentifierStartAfterNumericLiteral(){var e=this.pos;e<this.end&&a.isIdentifierStart(this.source.text.charCodeAt(e))&&this.error(r.DiagnosticCode.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal,this.range(e))}readUnicodeEscape(){return this.readHexadecimalEscape(4)}readExtendedUnicodeEscape(){var e=this.pos,n=this.readHexInteger(),t=i64_low(n),i=!1;assert(!i64_high(n)),t>1114111&&(this.error(r.DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,this.range(e,this.pos)),i=!0);var a=this.end,s=this.source.text;return this.pos>=a?(this.error(r.DiagnosticCode.Unexpected_end_of_text,this.range(e,a)),i=!0):125==s.charCodeAt(this.pos)?++this.pos:(this.error(r.DiagnosticCode.Unterminated_Unicode_escape_sequence,this.range(e,this.pos)),i=!0),i?"":t<65536?String.fromCharCode(t):String.fromCharCode(t-65536>>>10|55296,t-65536&1023|56320)}}n.Tokenizer=p;class f{constructor(e,n,t){this.pos=e,this.token=n,this.tokenPos=t}}n.State=f;var d=null},699:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Signature=n.typesToString=n.typesToNativeTypes=n.Type=n.TypeFlags=n.TypeKind=void 0;const r=t(974),i=t(656);!function(e){e[e.I8=0]="I8",e[e.I16=1]="I16",e[e.I32=2]="I32",e[e.I64=3]="I64",e[e.ISIZE=4]="ISIZE",e[e.U8=5]="U8",e[e.U16=6]="U16",e[e.U32=7]="U32",e[e.U64=8]="U64",e[e.USIZE=9]="USIZE",e[e.BOOL=10]="BOOL",e[e.F32=11]="F32",e[e.F64=12]="F64",e[e.V128=13]="V128",e[e.FUNCREF=14]="FUNCREF",e[e.EXTERNREF=15]="EXTERNREF",e[e.EXNREF=16]="EXNREF",e[e.ANYREF=17]="ANYREF",e[e.VOID=18]="VOID"}(n.TypeKind||(n.TypeKind={})),function(e){e[e.NONE=0]="NONE",e[e.SIGNED=1]="SIGNED",e[e.UNSIGNED=2]="UNSIGNED",e[e.INTEGER=4]="INTEGER",e[e.FLOAT=8]="FLOAT",e[e.VARYING=16]="VARYING",e[e.SHORT=32]="SHORT",e[e.LONG=64]="LONG",e[e.VALUE=128]="VALUE",e[e.REFERENCE=256]="REFERENCE",e[e.NULLABLE=512]="NULLABLE",e[e.VECTOR=1024]="VECTOR",e[e.EXTERNAL=2048]="EXTERNAL",e[e.CLASS=4096]="CLASS",e[e.FUNCTION=8192]="FUNCTION"}(n.TypeFlags||(n.TypeFlags={}));class a{constructor(e,n,t){this._nonNullableType=null,this._nullableType=null,this.kind=e,this.flags=n,this.size=t,this.byteSize=ceil(t/8),this.classReference=null,this.signatureReference=null,512&n?this._nullableType=this:this._nonNullableType=this}get intType(){if(this==a.auto)return this;switch(this.kind){case 0:return a.i8;case 1:return a.i16;case 11:case 2:return a.i32;case 12:case 3:return a.i64;case 4:return 64==this.size?a.isize64:a.isize32;case 5:return a.u8;case 6:return a.u16;case 7:return a.u32;case 8:return a.u64;case 9:return 64==this.size?a.usize64:a.usize32;case 10:default:return a.i32}}get exceptVoid(){return 18==this.kind?a.auto:this}get alignLog2(){return 31-clz(this.byteSize)}get isValue(){return this.is(128)}get isIntegerValue(){return this.is(132)}get isShortIntegerValue(){return this.is(164)}get isLongIntegerValue(){return this.is(196)}get isSignedIntegerValue(){return this.is(133)}get isUnsignedIntegerValue(){return this.is(134)}get isVaryingIntegerValue(){return this.is(148)}get isIntegerInclReference(){return this.is(4)}get isFloatValue(){return this.is(136)}get isNumericValue(){return this.isIntegerValue||this.isFloatValue}get isBooleanValue(){return this==a.bool}get isVectorValue(){return this.is(1152)}get isReference(){return this.is(256)}get isNullableReference(){return this.is(768)}get isInternalReference(){return this.is(260)}get isExternalReference(){return this.is(2304)}get isClass(){return!!this.isInternalReference&&null!==this.classReference}getClass(){return this.isInternalReference?this.classReference:null}getClassOrWrapper(e){let n=this.getClass();if(n)return n;{let n=this.getSignature();if(n){let t=n.type,r=assert(e.resolver.resolveClass(e.functionPrototype,[t]));return r.wrappedType=t,r}{let n=e.wrapperClasses;if(n.has(this))return assert(n.get(this))}}return null}get isFunction(){return!!this.isInternalReference&&null!==this.signatureReference}getSignature(){return this.isInternalReference?this.signatureReference:null}get isManaged(){if(this.isInternalReference){let e=this.classReference;return e?!e.hasDecorator(r.DecoratorFlags.UNMANAGED):null!==this.signatureReference}return!1}get isUnmanaged(){var e=this.classReference;return null!==e&&e.hasDecorator(r.DecoratorFlags.UNMANAGED)}get nonNullableType(){return this.isExternalReference?this:assert(this._nonNullableType)}get nullableType(){return this._nullableType}computeSmallIntegerShift(e){return e.size-this.size}computeSmallIntegerMask(e){var n=this.is(2)?this.size:this.size-1;return-1>>>e.size-n}is(e){return(this.flags&e)==e}isAny(e){return 0!=(this.flags&e)}asNullable(){assert(this.isInternalReference);var e=this._nullableType;return e||(assert(!this.isNullableReference),this._nullableType=e=new a(this.kind,512|this.flags,this.size),e.classReference=this.classReference,e.signatureReference=this.signatureReference,e._nonNullableType=this),e}equals(e){return this.kind==e.kind&&(!this.isReference||this.classReference==e.classReference&&this.signatureReference==e.signatureReference&&this.isNullableReference==e.isNullableReference)}isAssignableTo(e,n=!1){var t,r,i,a;if(this.isReference){if(e.isReference&&(!this.isNullableReference||e.isNullableReference))if(t=this.getClass()){if(r=e.getClass())return t.isAssignableTo(r)}else if(i=this.getSignature()){if(a=e.getSignature())return i.isAssignableTo(a)}else if(this.isExternalReference&&(this.kind==e.kind||17==e.kind))return!0}else if(!e.isReference)if(this.isIntegerValue)if(e.isIntegerValue){if(!n||this.isBooleanValue||this.isSignedIntegerValue==e.isSignedIntegerValue)return this.size<=e.size}else{if(11==e.kind)return this.size<=23;if(12==e.kind)return this.size<=52}else if(this.isFloatValue){if(e.isFloatValue)return this.size<=e.size}else if(this.isVectorValue&&e.isVectorValue)return this.size==e.size;return!1}isStrictlyAssignableTo(e,n=!1){return this.isReference?this.isAssignableTo(e):!e.isReference&&(this.isIntegerValue?e.isIntegerValue&&e.size==this.size&&(!n||this.isSignedIntegerValue==e.isSignedIntegerValue):this.kind==e.kind)}isChangeableTo(e){if(this.is(4)&&e.is(4)){let n=this.size;return n==e.size&&(n>=32||this.is(1)==e.is(1))}return this.kind==e.kind}static commonDenominator(e,n,t){return n.isAssignableTo(e,t)?e:e.isAssignableTo(n,t)?n:null}toString(e=!1){const n=e?"|null":" | null";if(this.isReference){let t=this.getClass();if(t)return this.isNullableReference?t.internalName+n:t.internalName;{let t=this.getSignature();if(t)return this.isNullableReference?"("+t.toString(e)+")"+n:t.toString(e)}}switch(this.kind){case 0:return"i8";case 1:return"i16";case 2:return"i32";case 3:return"i64";case 4:return"isize";case 5:return"u8";case 6:return"u16";case 7:return"u32";case 8:return"u64";case 9:return"usize";case 10:return"bool";case 11:return"f32";case 12:return"f64";case 13:return"v128";case 14:return"funcref";case 15:return"externref";case 16:return"exnref";case 17:return"anyref";default:assert(!1);case 18:return"void"}}toNativeType(){switch(this.kind){default:assert(!1);case 0:case 1:case 2:case 5:case 6:case 7:case 10:return i.NativeType.I32;case 4:case 9:if(64!=this.size)return i.NativeType.I32;case 3:case 8:return i.NativeType.I64;case 11:return i.NativeType.F32;case 12:return i.NativeType.F64;case 13:return i.NativeType.V128;case 14:return i.NativeType.Funcref;case 15:return i.NativeType.Externref;case 16:return i.NativeType.Exnref;case 17:return i.NativeType.Anyref;case 18:return i.NativeType.None}}}function s(e){var n=e.length,t=new Array(n);for(let r=0;r<n;++r)t[r]=e[r].toNativeType();return t}n.Type=a,a.i8=new a(0,165,8),a.i16=new a(1,165,16),a.i32=new a(2,133,32),a.i64=new a(3,197,64),a.isize32=new a(4,149,32),a.isize64=new a(4,213,64),a.u8=new a(5,166,8),a.u16=new a(6,166,16),a.u32=new a(7,134,32),a.u64=new a(8,198,64),a.usize32=new a(9,150,32),a.usize64=new a(9,214,64),a.bool=new a(10,166,1),a.f32=new a(11,137,32),a.f64=new a(12,201,64),a.v128=new a(13,1152,128),a.funcref=new a(14,2816,0),a.externref=new a(15,2816,0),a.exnref=new a(16,2816,0),a.anyref=new a(17,2816,0),a.void=new a(18,0,0),a.auto=new a(a.i32.kind,a.i32.flags,a.i32.size),n.typesToNativeTypes=s,n.typesToString=function(e){var n=e.length;if(!n)return"";var t=new Array(n);for(let r=0;r<n;++r)t[r]=e[r].toString(!0);return t.join(",")};class o{constructor(e,n=null,t=null,r=null){this.id=0,this.parameterTypes=n||[],this.requiredParameters=0,this.returnType=t||a.void,this.thisType=r,this.program=e,this.hasRest=!1;var i=e.options.usizeType,s=new a(i.kind,-129&i.flags|256,i.size);this.type=s,s.signatureReference=this;var o=e.uniqueSignatures,l=o.length;for(let e=0;e<l;e++){let n=o[e];if(this.equals(n))return this.id=n.id,this}this.id=e.nextSignatureId++,e.uniqueSignatures.push(this)}get nativeParams(){var e=this.thisType,n=this.parameterTypes,t=n.length;if(!t)return e?e.toNativeType():i.NativeType.None;if(e){let r=new Array(1+t);r[0]=e.toNativeType();for(let e=0;e<t;++e)r[e+1]=n[e].toNativeType();return i.createType(r)}return i.createType(s(n))}get nativeResults(){return this.returnType.toNativeType()}equals(e){var n=this.thisType,t=e.thisType;if(null!==n){if(null===t||!n.equals(t))return!1}else if(t)return!1;if(this.hasRest!=e.hasRest)return!1;var r=this.parameterTypes,i=e.parameterTypes,a=r.length;if(a!=i.length)return!1;for(let e=0;e<a;++e)if(!r[e].equals(i[e]))return!1;return this.returnType.equals(e.returnType)}isAssignableTo(e,n=!1){var t=this.thisType,r=e.thisType;if(null!==t){if(null===r||!t.isAssignableTo(r))return!1}else if(r)return!1;if(this.hasRest!=e.hasRest)return!1;var i=this.parameterTypes,a=e.parameterTypes,s=i.length;if(s!=a.length)return!1;for(let e=0;e<s;++e){let n=i[e],t=a[e];if(!n.isAssignableTo(t))return!1}var o=this.returnType,l=e.returnType;return o==l||o.isAssignableTo(l)}get hasManagedOperands(){var e=this.thisType;if(e&&e.isManaged)return!0;var n=this.parameterTypes;for(let e=0,t=n.length;e<t;++e)if(n[e].isManaged)return!0;return!1}getManagedOperandIndices(){var e=new Array,n=0,t=this.thisType;t&&(t.isManaged&&e.push(n),++n);var r=this.parameterTypes;for(let t=0,i=r.length;t<i;++t)r[t].isManaged&&e.push(n),++n;return e}toString(e=!1){var n=new Array;n.push(e?"%28":"(");var t=0,r=this.thisType;r&&(n.push(e?"this:":"this: "),assert(!r.signatureReference),n.push(r.toString(e)),t=1);var i=this.parameterTypes,a=i.length;if(a){let r=this.requiredParameters,s=this.hasRest?a-1:-1;for(let o=0;o<a;++o,++t)t&&n.push(e?"%2C":", "),o==s&&n.push("..."),n.push(i[o].toString(e)),o>=r&&o!=s&&n.push("?")}return n.push(e?"%29=>":") => "),n.push(this.returnType.toString(e)),n.join("")}clone(){var e=this.parameterTypes,n=e.length,t=new Array(n);for(let r=0;r<n;++r)t[r]=e[r];return new o(this.program,t,this.returnType,this.thisType)}}n.Signature=o},540:(e,n)=>{"use strict";function t(e,n){return i32(e[n])|i32(e[n+1])<<8|i32(e[n+2])<<16|i32(e[n+3])<<24}function r(e,n,t){n[t]=e,n[t+1]=e>>>8,n[t+2]=e>>>16,n[t+3]=e>>>24}function i(e,n){var r=t(e,n),i=t(e,n+4);return i64_new(r,i)}Object.defineProperty(n,"__esModule",{value:!0}),n.writeF64=n.readF64=n.writeF32=n.readF32=n.writeI64AsI32=n.writeI64=n.readI64=n.writeI32AsI64=n.writeI32=n.readI32=n.writeI16=n.readI16=n.writeI8=n.readI8=void 0,n.readI8=function(e,n){return e[n]},n.writeI8=function(e,n,t){n[t]=e},n.readI16=function(e,n){return i32(e[n])|i32(e[n+1])<<8},n.writeI16=function(e,n,t){n[t]=e,n[t+1]=e>>>8},n.readI32=t,n.writeI32=r,n.writeI32AsI64=function(e,n,t,i=!1){r(e,n,t),r(i||e>=0?0:-1,n,t+4)},n.readI64=i,n.writeI64=function(e,n,t){r(i64_low(e),n,t),r(i64_high(e),n,t+4)},n.writeI64AsI32=function(e,n,t,i=!1){assert(i?i64_is_u32(e):i64_is_i32(e)),r(i64_low(e),n,t)},n.readF32=function(e,n){return i32_as_f32(t(e,n))},n.writeF32=function(e,n,t){r(f32_as_i32(e),n,t)},n.readF64=function(e,n){return i64_as_f64(i(e,n))},n.writeF64=function(e,n,t){var i=f64_as_i64(e);r(i64_low(i),n,t),r(i64_high(i),n,t+4)}},189:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.uniqueMap=void 0,n.uniqueMap=function(e=null,n=null){var t=new Map;if(e)for(let n=Map_keys(e),r=0,i=n.length;r<i;++r){let i=unchecked(n[r]),a=assert(e.get(i));t.set(i,a)}if(n)for(let e=Map_keys(n),r=0,i=e.length;r<i;++r){let i=unchecked(e[r]),a=assert(n.get(i));t.set(i,a)}return t}},910:function(e,n,t){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){void 0===r&&(r=t),Object.defineProperty(e,r,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,r){void 0===r&&(r=t),e[r]=n[t]}),i=this&&this.__exportStar||function(e,n){for(var t in e)"default"===t||Object.prototype.hasOwnProperty.call(n,t)||r(n,e,t)};Object.defineProperty(n,"__esModule",{value:!0}),i(t(540),n),i(t(189),n),i(t(96),n),i(t(841),n),i(t(95),n),i(t(311),n),i(t(560),n)},96:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isPowerOf2=void 0,n.isPowerOf2=function(e){return 0!=e&&0==(e&e-1)}},841:(e,n,t)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.dirname=n.resolvePath=n.normalizePath=void 0;const r=t(200),i=47;function a(e){for(var n,t=0,r=e.length;t+1<r&&46==e.charCodeAt(t)&&e.charCodeAt(t+1)==i;)t+=2;for((t>0||r<e.length)&&(e=e.substring(t,r),r-=t,t=0);t+1<r;){if(n=!1,e.charCodeAt(t)==i&&46==e.charCodeAt(t+1)){if((n=t+2==r)||t+2<r&&e.charCodeAt(t+2)==i){e=n?e.substring(0,t):e.substring(0,t)+e.substring(t+2),r-=2;continue}if((n=t+3==r)&&46==e.charCodeAt(t+2)||t+3<r&&46==e.charCodeAt(t+2)&&e.charCodeAt(t+3)==i){let a=t;for(;--a>=0;)if(e.charCodeAt(a)==i){t-a==3&&46==e.charCodeAt(a+1)&&46==e.charCodeAt(a+2)||(e=n?e.substring(0,a):e.substring(0,a)+e.substring(t+3),r-=t+3-a,t=a-1);break}if(a<0&&t>0&&(2!=t||46!=e.charCodeAt(0)||46!=e.charCodeAt(1))){r=(e=e.substring(t+4)).length;continue}}}t++}return r>0?e:"."}function s(e){var n=e.length;if(n<=1){if(0==n)return".";if(e.charCodeAt(0)==i)return e}for(;--n>0;)if(e.charCodeAt(n)==i)return e.substring(0,n);return"."}n.normalizePath=a,n.resolvePath=function(e,n){return e.startsWith("std/")?e:a(s(n)+r.PATH_DELIMITER+e)},n.dirname=s},95:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.colorize=n.setColorsEnabled=n.isColorsEnabled=n.COLOR_RESET=n.COLOR_WHITE=n.COLOR_CYAN=n.COLOR_MAGENTA=n.COLOR_BLUE=n.COLOR_YELLOW=n.COLOR_GREEN=n.COLOR_RED=n.COLOR_GRAY=void 0,n.COLOR_GRAY="[90m",n.COLOR_RED="[91m",n.COLOR_GREEN="[92m",n.COLOR_YELLOW="[93m",n.COLOR_BLUE="[94m",n.COLOR_MAGENTA="[95m",n.COLOR_CYAN="[96m",n.COLOR_WHITE="[97m",n.COLOR_RESET="[0m";var t=!0;n.isColorsEnabled=function(){return t},n.setColorsEnabled=function(e){return t=e,e},n.colorize=function(e,r){return t?r+e+n.COLOR_RESET:e}},311:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.indent=n.isIdentifierPart=n.isKeywordCharacter=n.isIdentifierStart=n.isTrivialAlphanum=n.isOctalDigit=n.isDecimalDigit=n.isWhiteSpace=n.isLineBreak=n.CharCode=void 0,function(e){e[e.NULL=0]="NULL",e[e.LINEFEED=10]="LINEFEED",e[e.CARRIAGERETURN=13]="CARRIAGERETURN",e[e.LINESEPARATOR=8232]="LINESEPARATOR",e[e.PARAGRAPHSEPARATOR=8233]="PARAGRAPHSEPARATOR",e[e.NEXTLINE=133]="NEXTLINE",e[e.SPACE=32]="SPACE",e[e.NONBREAKINGSPACE=160]="NONBREAKINGSPACE",e[e.ENQUAD=8192]="ENQUAD",e[e.EMQUAD=8193]="EMQUAD",e[e.ENSPACE=8194]="ENSPACE",e[e.EMSPACE=8195]="EMSPACE",e[e.THREEPEREMSPACE=8196]="THREEPEREMSPACE",e[e.FOURPEREMSPACE=8197]="FOURPEREMSPACE",e[e.SIXPEREMSPACE=8198]="SIXPEREMSPACE",e[e.FIGURESPACE=8199]="FIGURESPACE",e[e.PUNCTUATIONSPACE=8200]="PUNCTUATIONSPACE",e[e.THINSPACE=8201]="THINSPACE",e[e.HAIRSPACE=8202]="HAIRSPACE",e[e.ZEROWIDTHSPACE=8203]="ZEROWIDTHSPACE",e[e.NARROWNOBREAKSPACE=8239]="NARROWNOBREAKSPACE",e[e.IDEOGRAPHICSPACE=12288]="IDEOGRAPHICSPACE",e[e.MATHEMATICALSPACE=8287]="MATHEMATICALSPACE",e[e.OGHAM=5760]="OGHAM",e[e._=95]="_",e[e._0=48]="_0",e[e._1=49]="_1",e[e._2=50]="_2",e[e._3=51]="_3",e[e._4=52]="_4",e[e._5=53]="_5",e[e._6=54]="_6",e[e._7=55]="_7",e[e._8=56]="_8",e[e._9=57]="_9",e[e.a=97]="a",e[e.b=98]="b",e[e.c=99]="c",e[e.d=100]="d",e[e.e=101]="e",e[e.f=102]="f",e[e.g=103]="g",e[e.h=104]="h",e[e.i=105]="i",e[e.j=106]="j",e[e.k=107]="k",e[e.l=108]="l",e[e.m=109]="m",e[e.n=110]="n",e[e.o=111]="o",e[e.p=112]="p",e[e.q=113]="q",e[e.r=114]="r",e[e.s=115]="s",e[e.t=116]="t",e[e.u=117]="u",e[e.v=118]="v",e[e.w=119]="w",e[e.x=120]="x",e[e.y=121]="y",e[e.z=122]="z",e[e.A=65]="A",e[e.B=66]="B",e[e.C=67]="C",e[e.D=68]="D",e[e.E=69]="E",e[e.F=70]="F",e[e.G=71]="G",e[e.H=72]="H",e[e.I=73]="I",e[e.J=74]="J",e[e.K=75]="K",e[e.L=76]="L",e[e.M=77]="M",e[e.N=78]="N",e[e.O=79]="O",e[e.P=80]="P",e[e.Q=81]="Q",e[e.R=82]="R",e[e.S=83]="S",e[e.T=84]="T",e[e.U=85]="U",e[e.V=86]="V",e[e.W=87]="W",e[e.X=88]="X",e[e.Y=89]="Y",e[e.Z=90]="Z",e[e.AMPERSAND=38]="AMPERSAND",e[e.ASTERISK=42]="ASTERISK",e[e.AT=64]="AT",e[e.BACKSLASH=92]="BACKSLASH",e[e.BACKTICK=96]="BACKTICK",e[e.BAR=124]="BAR",e[e.CARET=94]="CARET",e[e.CLOSEBRACE=125]="CLOSEBRACE",e[e.CLOSEBRACKET=93]="CLOSEBRACKET",e[e.CLOSEPAREN=41]="CLOSEPAREN",e[e.COLON=58]="COLON",e[e.COMMA=44]="COMMA",e[e.DOLLAR=36]="DOLLAR",e[e.DOT=46]="DOT",e[e.DOUBLEQUOTE=34]="DOUBLEQUOTE",e[e.EQUALS=61]="EQUALS",e[e.EXCLAMATION=33]="EXCLAMATION",e[e.GREATERTHAN=62]="GREATERTHAN",e[e.HASH=35]="HASH",e[e.LESSTHAN=60]="LESSTHAN",e[e.MINUS=45]="MINUS",e[e.OPENBRACE=123]="OPENBRACE",e[e.OPENBRACKET=91]="OPENBRACKET",e[e.OPENPAREN=40]="OPENPAREN",e[e.PERCENT=37]="PERCENT",e[e.PLUS=43]="PLUS",e[e.QUESTION=63]="QUESTION",e[e.SEMICOLON=59]="SEMICOLON",e[e.SINGLEQUOTE=39]="SINGLEQUOTE",e[e.SLASH=47]="SLASH",e[e.TILDE=126]="TILDE",e[e.BACKSPACE=8]="BACKSPACE",e[e.FORMFEED=12]="FORMFEED",e[e.BYTEORDERMARK=65279]="BYTEORDERMARK",e[e.TAB=9]="TAB",e[e.VERTICALTAB=11]="VERTICALTAB"}(n.CharCode||(n.CharCode={})),n.isLineBreak=function(e){switch(e){case 10:case 13:case 8232:case 8233:return!0;default:return!1}},n.isWhiteSpace=function(e){switch(e){case 32:case 9:case 11:case 12:case 160:case 133:case 5760:case 8239:case 8287:case 12288:case 65279:return!0;default:return e>=8192&&e<=8203}},n.isDecimalDigit=function(e){return e>=48&&e<=57},n.isOctalDigit=function(e){return e>=48&&e<=55},n.isTrivialAlphanum=function(e){return e>=97&&e<=122||e>=65&&e<=90||e>=48&&e<=57},n.isIdentifierStart=function(e){const n=32|e;return n>=97&&n<=122||95==e||36==e||e>127&&!((r=e)<170||r>65500)&&i(r,t);var r},n.isKeywordCharacter=function(e){return e>=97&&e<=122},n.isIdentifierPart=function(e){const n=32|e;return n>=97&&n<=122||e>=48&&e<=57||95==e||36==e||e>127&&!((t=e)<170||t>65500)&&i(t,r);var t};const t=[170,170,181,181,186,186,192,214,216,246,248,705,710,721,736,740,748,748,750,750,880,884,886,887,890,893,902,902,904,906,908,908,910,929,931,1013,1015,1153,1162,1319,1329,1366,1369,1369,1377,1415,1488,1514,1520,1522,1568,1610,1646,1647,1649,1747,1749,1749,1765,1766,1774,1775,1786,1788,1791,1791,1808,1808,1810,1839,1869,1957,1969,1969,1994,2026,2036,2037,2042,2042,2048,2069,2074,2074,2084,2084,2088,2088,2112,2136,2208,2208,2210,2220,2308,2361,2365,2365,2384,2384,2392,2401,2417,2423,2425,2431,2437,2444,2447,2448,2451,2472,2474,2480,2482,2482,2486,2489,2493,2493,2510,2510,2524,2525,2527,2529,2544,2545,2565,2570,2575,2576,2579,2600,2602,2608,2610,2611,2613,2614,2616,2617,2649,2652,2654,2654,2674,2676,2693,2701,2703,2705,2707,2728,2730,2736,2738,2739,2741,2745,2749,2749,2768,2768,2784,2785,2821,2828,2831,2832,2835,2856,2858,2864,2866,2867,2869,2873,2877,2877,2908,2909,2911,2913,2929,2929,2947,2947,2949,2954,2958,2960,2962,2965,2969,2970,2972,2972,2974,2975,2979,2980,2984,2986,2990,3001,3024,3024,3077,3084,3086,3088,3090,3112,3114,3123,3125,3129,3133,3133,3160,3161,3168,3169,3205,3212,3214,3216,3218,3240,3242,3251,3253,3257,3261,3261,3294,3294,3296,3297,3313,3314,3333,3340,3342,3344,3346,3386,3389,3389,3406,3406,3424,3425,3450,3455,3461,3478,3482,3505,3507,3515,3517,3517,3520,3526,3585,3632,3634,3635,3648,3654,3713,3714,3716,3716,3719,3720,3722,3722,3725,3725,3732,3735,3737,3743,3745,3747,3749,3749,3751,3751,3754,3755,3757,3760,3762,3763,3773,3773,3776,3780,3782,3782,3804,3807,3840,3840,3904,3911,3913,3948,3976,3980,4096,4138,4159,4159,4176,4181,4186,4189,4193,4193,4197,4198,4206,4208,4213,4225,4238,4238,4256,4293,4295,4295,4301,4301,4304,4346,4348,4680,4682,4685,4688,4694,4696,4696,4698,4701,4704,4744,4746,4749,4752,4784,4786,4789,4792,4798,4800,4800,4802,4805,4808,4822,4824,4880,4882,4885,4888,4954,4992,5007,5024,5108,5121,5740,5743,5759,5761,5786,5792,5866,5870,5872,5888,5900,5902,5905,5920,5937,5952,5969,5984,5996,5998,6e3,6016,6067,6103,6103,6108,6108,6176,6263,6272,6312,6314,6314,6320,6389,6400,6428,6480,6509,6512,6516,6528,6571,6593,6599,6656,6678,6688,6740,6823,6823,6917,6963,6981,6987,7043,7072,7086,7087,7098,7141,7168,7203,7245,7247,7258,7293,7401,7404,7406,7409,7413,7414,7424,7615,7680,7957,7960,7965,7968,8005,8008,8013,8016,8023,8025,8025,8027,8027,8029,8029,8031,8061,8064,8116,8118,8124,8126,8126,8130,8132,8134,8140,8144,8147,8150,8155,8160,8172,8178,8180,8182,8188,8305,8305,8319,8319,8336,8348,8450,8450,8455,8455,8458,8467,8469,8469,8473,8477,8484,8484,8486,8486,8488,8488,8490,8493,8495,8505,8508,8511,8517,8521,8526,8526,8544,8584,11264,11310,11312,11358,11360,11492,11499,11502,11506,11507,11520,11557,11559,11559,11565,11565,11568,11623,11631,11631,11648,11670,11680,11686,11688,11694,11696,11702,11704,11710,11712,11718,11720,11726,11728,11734,11736,11742,11823,11823,12293,12295,12321,12329,12337,12341,12344,12348,12353,12438,12445,12447,12449,12538,12540,12543,12549,12589,12593,12686,12704,12730,12784,12799,13312,19893,19968,40908,40960,42124,42192,42237,42240,42508,42512,42527,42538,42539,42560,42606,42623,42647,42656,42735,42775,42783,42786,42888,42891,42894,42896,42899,42912,42922,43e3,43009,43011,43013,43015,43018,43020,43042,43072,43123,43138,43187,43250,43255,43259,43259,43274,43301,43312,43334,43360,43388,43396,43442,43471,43471,43520,43560,43584,43586,43588,43595,43616,43638,43642,43642,43648,43695,43697,43697,43701,43702,43705,43709,43712,43712,43714,43714,43739,43741,43744,43754,43762,43764,43777,43782,43785,43790,43793,43798,43808,43814,43816,43822,43968,44002,44032,55203,55216,55238,55243,55291,63744,64109,64112,64217,64256,64262,64275,64279,64285,64285,64287,64296,64298,64310,64312,64316,64318,64318,64320,64321,64323,64324,64326,64433,64467,64829,64848,64911,64914,64967,65008,65019,65136,65140,65142,65276,65313,65338,65345,65370,65382,65470,65474,65479,65482,65487,65490,65495,65498,65500],r=[170,170,181,181,186,186,192,214,216,246,248,705,710,721,736,740,748,748,750,750,768,884,886,887,890,893,902,902,904,906,908,908,910,929,931,1013,1015,1153,1155,1159,1162,1319,1329,1366,1369,1369,1377,1415,1425,1469,1471,1471,1473,1474,1476,1477,1479,1479,1488,1514,1520,1522,1552,1562,1568,1641,1646,1747,1749,1756,1759,1768,1770,1788,1791,1791,1808,1866,1869,1969,1984,2037,2042,2042,2048,2093,2112,2139,2208,2208,2210,2220,2276,2302,2304,2403,2406,2415,2417,2423,2425,2431,2433,2435,2437,2444,2447,2448,2451,2472,2474,2480,2482,2482,2486,2489,2492,2500,2503,2504,2507,2510,2519,2519,2524,2525,2527,2531,2534,2545,2561,2563,2565,2570,2575,2576,2579,2600,2602,2608,2610,2611,2613,2614,2616,2617,2620,2620,2622,2626,2631,2632,2635,2637,2641,2641,2649,2652,2654,2654,2662,2677,2689,2691,2693,2701,2703,2705,2707,2728,2730,2736,2738,2739,2741,2745,2748,2757,2759,2761,2763,2765,2768,2768,2784,2787,2790,2799,2817,2819,2821,2828,2831,2832,2835,2856,2858,2864,2866,2867,2869,2873,2876,2884,2887,2888,2891,2893,2902,2903,2908,2909,2911,2915,2918,2927,2929,2929,2946,2947,2949,2954,2958,2960,2962,2965,2969,2970,2972,2972,2974,2975,2979,2980,2984,2986,2990,3001,3006,3010,3014,3016,3018,3021,3024,3024,3031,3031,3046,3055,3073,3075,3077,3084,3086,3088,3090,3112,3114,3123,3125,3129,3133,3140,3142,3144,3146,3149,3157,3158,3160,3161,3168,3171,3174,3183,3202,3203,3205,3212,3214,3216,3218,3240,3242,3251,3253,3257,3260,3268,3270,3272,3274,3277,3285,3286,3294,3294,3296,3299,3302,3311,3313,3314,3330,3331,3333,3340,3342,3344,3346,3386,3389,3396,3398,3400,3402,3406,3415,3415,3424,3427,3430,3439,3450,3455,3458,3459,3461,3478,3482,3505,3507,3515,3517,3517,3520,3526,3530,3530,3535,3540,3542,3542,3544,3551,3570,3571,3585,3642,3648,3662,3664,3673,3713,3714,3716,3716,3719,3720,3722,3722,3725,3725,3732,3735,3737,3743,3745,3747,3749,3749,3751,3751,3754,3755,3757,3769,3771,3773,3776,3780,3782,3782,3784,3789,3792,3801,3804,3807,3840,3840,3864,3865,3872,3881,3893,3893,3895,3895,3897,3897,3902,3911,3913,3948,3953,3972,3974,3991,3993,4028,4038,4038,4096,4169,4176,4253,4256,4293,4295,4295,4301,4301,4304,4346,4348,4680,4682,4685,4688,4694,4696,4696,4698,4701,4704,4744,4746,4749,4752,4784,4786,4789,4792,4798,4800,4800,4802,4805,4808,4822,4824,4880,4882,4885,4888,4954,4957,4959,4992,5007,5024,5108,5121,5740,5743,5759,5761,5786,5792,5866,5870,5872,5888,5900,5902,5908,5920,5940,5952,5971,5984,5996,5998,6e3,6002,6003,6016,6099,6103,6103,6108,6109,6112,6121,6155,6157,6160,6169,6176,6263,6272,6314,6320,6389,6400,6428,6432,6443,6448,6459,6470,6509,6512,6516,6528,6571,6576,6601,6608,6617,6656,6683,6688,6750,6752,6780,6783,6793,6800,6809,6823,6823,6912,6987,6992,7001,7019,7027,7040,7155,7168,7223,7232,7241,7245,7293,7376,7378,7380,7414,7424,7654,7676,7957,7960,7965,7968,8005,8008,8013,8016,8023,8025,8025,8027,8027,8029,8029,8031,8061,8064,8116,8118,8124,8126,8126,8130,8132,8134,8140,8144,8147,8150,8155,8160,8172,8178,8180,8182,8188,8204,8205,8255,8256,8276,8276,8305,8305,8319,8319,8336,8348,8400,8412,8417,8417,8421,8432,8450,8450,8455,8455,8458,8467,8469,8469,8473,8477,8484,8484,8486,8486,8488,8488,8490,8493,8495,8505,8508,8511,8517,8521,8526,8526,8544,8584,11264,11310,11312,11358,11360,11492,11499,11507,11520,11557,11559,11559,11565,11565,11568,11623,11631,11631,11647,11670,11680,11686,11688,11694,11696,11702,11704,11710,11712,11718,11720,11726,11728,11734,11736,11742,11744,11775,11823,11823,12293,12295,12321,12335,12337,12341,12344,12348,12353,12438,12441,12442,12445,12447,12449,12538,12540,12543,12549,12589,12593,12686,12704,12730,12784,12799,13312,19893,19968,40908,40960,42124,42192,42237,42240,42508,42512,42539,42560,42607,42612,42621,42623,42647,42655,42737,42775,42783,42786,42888,42891,42894,42896,42899,42912,42922,43e3,43047,43072,43123,43136,43204,43216,43225,43232,43255,43259,43259,43264,43309,43312,43347,43360,43388,43392,43456,43471,43481,43520,43574,43584,43597,43600,43609,43616,43638,43642,43643,43648,43714,43739,43741,43744,43759,43762,43766,43777,43782,43785,43790,43793,43798,43808,43814,43816,43822,43968,44010,44012,44013,44016,44025,44032,55203,55216,55238,55243,55291,63744,64109,64112,64217,64256,64262,64275,64279,64285,64296,64298,64310,64312,64316,64318,64318,64320,64321,64323,64324,64326,64433,64467,64829,64848,64911,64914,64967,65008,65019,65024,65039,65056,65062,65075,65076,65101,65103,65136,65140,65142,65276,65296,65305,65313,65338,65343,65343,65345,65370,65382,65470,65474,65479,65482,65487,65490,65495,65498,65500];function i(e,n){if(e<n[0])return!1;for(var t,r,i=0,a=n.length;i+1<a;){if(t=i+(a-i>>1),(r=n[t-=1&t])<=e&&e<=n[t+1])return!0;e<r?a=t:i=t+2}return!1}n.indent=function(e,n){for(;n>=4;)e.push("        "),n-=4;n>=2&&(e.push("    "),n-=2),n&&e.push("  ")}},560:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.v128_zero=void 0,n.v128_zero=new Uint8Array(16)},466:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.featureToString=n.Feature=void 0,function(e){e[e.NONE=0]="NONE",e[e.SIGN_EXTENSION=1]="SIGN_EXTENSION",e[e.MUTABLE_GLOBALS=2]="MUTABLE_GLOBALS",e[e.NONTRAPPING_F2I=4]="NONTRAPPING_F2I",e[e.BULK_MEMORY=8]="BULK_MEMORY",e[e.SIMD=16]="SIMD",e[e.THREADS=32]="THREADS",e[e.EXCEPTION_HANDLING=64]="EXCEPTION_HANDLING",e[e.TAIL_CALLS=128]="TAIL_CALLS",e[e.REFERENCE_TYPES=256]="REFERENCE_TYPES",e[e.MULTI_VALUE=512]="MULTI_VALUE",e[e.GC=1024]="GC",e[e.MEMORY64=2048]="MEMORY64"}(n.Feature||(n.Feature={})),n.featureToString=function(e){switch(e){case 1:return"sign-extension";case 2:return"mutable-globals";case 4:return"nontrapping-f2i";case 8:return"bulk-memory";case 16:return"simd";case 32:return"threads";case 64:return"exception-handling";case 128:return"tail-calls";case 256:return"reference-types";case 512:return"multi-value";case 1024:return"gc";case 2048:return"memory64"}return assert(!1),""}},607:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Target=void 0,function(e){e[e.JS=0]="JS",e[e.WASM32=1]="WASM32",e[e.WASM64=2]="WASM64"}(n.Target||(n.Target={}))},604:function(e,n){"use strict";var t=this&&this.__decorate||function(e,n,t,r){var i,a=arguments.length,s=a<3?n:null===r?r=Object.getOwnPropertyDescriptor(n,t):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,n,t,r);else for(var o=e.length-1;o>=0;o--)(i=e[o])&&(s=(a<3?i(s):a>3?i(n,t,s):i(n,t))||s);return a>3&&s&&Object.defineProperty(n,t,s),s};Object.defineProperty(n,"__esModule",{value:!0}),n.TypeinfoFlags=n.Typeinfo=void 0;let r=class{constructor(){this.flags=0,this.base=0}};r=t([unmanaged],r),n.Typeinfo=r,function(e){e[e.NONE=0]="NONE",e[e.ARRAYBUFFERVIEW=1]="ARRAYBUFFERVIEW",e[e.ARRAY=2]="ARRAY",e[e.STATICARRAY=4]="STATICARRAY",e[e.SET=8]="SET",e[e.MAP=16]="MAP",e[e.POINTERFREE=32]="POINTERFREE",e[e.VALUE_ALIGN_0=64]="VALUE_ALIGN_0",e[e.VALUE_ALIGN_1=128]="VALUE_ALIGN_1",e[e.VALUE_ALIGN_2=256]="VALUE_ALIGN_2",e[e.VALUE_ALIGN_3=512]="VALUE_ALIGN_3",e[e.VALUE_ALIGN_4=1024]="VALUE_ALIGN_4",e[e.VALUE_SIGNED=2048]="VALUE_SIGNED",e[e.VALUE_FLOAT=4096]="VALUE_FLOAT",e[e.VALUE_NULLABLE=8192]="VALUE_NULLABLE",e[e.VALUE_MANAGED=16384]="VALUE_MANAGED",e[e.KEY_ALIGN_0=32768]="KEY_ALIGN_0",e[e.KEY_ALIGN_1=65536]="KEY_ALIGN_1",e[e.KEY_ALIGN_2=131072]="KEY_ALIGN_2",e[e.KEY_ALIGN_3=262144]="KEY_ALIGN_3",e[e.KEY_ALIGN_4=524288]="KEY_ALIGN_4",e[e.KEY_SIGNED=1048576]="KEY_SIGNED",e[e.KEY_FLOAT=2097152]="KEY_FLOAT",e[e.KEY_NULLABLE=4194304]="KEY_NULLABLE",e[e.KEY_MANAGED=8388608]="KEY_MANAGED"}(n.TypeinfoFlags||(n.TypeinfoFlags={}))},292:(e,n,t)=>{const r=t.g.binaryen||(t.g.binaryen=t(911));e.exports=r;const{Module:i}=t(656);i.prototype.toText=function(e=!0){return e?r.wrapModule(this.ref).emitStackIR(!0):r.wrapModule(this.ref).emitText()},i.prototype.toAsmjs=function(){return r.wrapModule(this.ref).emitAsmjs()}},710:(e,n,t)=>{t.g.Map_keys=function(e){return Array.from(e.keys())},t.g.Map_values=function(e){return Array.from(e.values())},t.g.Set_values=function(e){return Array.from(e.values())}},620:(e,n,t)=>{const r=new Float64Array(1),i=new Float32Array(r.buffer),a=new Int32Array(r.buffer);t.g.f32_as_i32=function(e){return i[0]=e,a[0]},t.g.i32_as_f32=function(e){return a[0]=e,i[0]},t.g.f64_as_i64=function(e){return r[0]=e,i64_new(a[0],a[1])},t.g.i64_as_f64=function(e){return a[0]=i64_low(e),a[1]=i64_high(e),r[0]}},875:(e,n,t)=>{const r=t.g.Long||t(720);t.g.i64_zero=r.ZERO,t.g.i64_one=r.ONE,t.g.i64_neg_one=r.fromInt(-1),t.g.i64_is=function(e){return r.isLong(e)},t.g.i64_new=function(e,n){return r.fromBits(e,n)},t.g.i64_low=function(e){return e.low},t.g.i64_high=function(e){return e.high},t.g.i64_add=function(e,n){return e.add(n)},t.g.i64_sub=function(e,n){return e.sub(n)},t.g.i64_mul=function(e,n){return e.mul(n)},t.g.i64_pow=function(e,n){var i=n.low,a=n.high;if(a<=0){if(a<0)return e.eq(t.g.i64_neg_one)?1&i?e:r.ONE:e.eq(r.ONE)?e:r.ZERO;if(0==i)return r.ONE;if(1==i)return e;if(2==i)return e.mul(e)}for(var s=r.ONE;i|a;)1&i&&(s=s.mul(e)),n=n.shru(1),e=e.mul(e),i=n.low,a=n.high;return s},t.g.i64_div=function(e,n){return e.div(n)},t.g.i64_div_u=function(e,n){return e.toUnsigned().div(n.toUnsigned()).toSigned()},t.g.i64_rem=function(e,n){return e.mod(n)},t.g.i64_rem_u=function(e,n){return e.toUnsigned().mod(n.toUnsigned()).toSigned()},t.g.i64_and=function(e,n){return e.and(n)},t.g.i64_or=function(e,n){return e.or(n)},t.g.i64_xor=function(e,n){return e.xor(n)},t.g.i64_shl=function(e,n){return e.shl(n)},t.g.i64_shr=function(e,n){return e.shr(n)},t.g.i64_shr_u=function(e,n){return e.shru(n)},t.g.i64_not=function(e){return e.not()},t.g.i64_eq=function(e,n){return e.eq(n)},t.g.i64_ne=function(e,n){return e.ne(n)},t.g.i64_gt=function(e,n){return e.gt(n)},t.g.i64_align=function(e,n){assert(n&&0==(n&n-1));var t=r.fromInt(n-1);return e.add(t).and(t.not())},t.g.i64_is_i8=function(e){return 0===e.high&&e.low>=0&&e.low<=i8.MAX_VALUE||-1===e.high&&e.low>=i8.MIN_VALUE&&e.low<0},t.g.i64_is_i16=function(e){return 0===e.high&&e.low>=0&&e.low<=i16.MAX_VALUE||-1===e.high&&e.low>=i16.MIN_VALUE&&e.low<0},t.g.i64_is_i32=function(e){return 0===e.high&&e.low>=0||-1===e.high&&e.low<0},t.g.i64_is_u8=function(e){return 0===e.high&&e.low>>>0<=u8.MAX_VALUE},t.g.i64_is_u16=function(e){return 0===e.high&&e.low>>>0<=u16.MAX_VALUE},t.g.i64_is_u32=function(e){return 0===e.high},t.g.i64_is_bool=function(e){return 0==(e.high|-2&e.low)};const i=r.fromNumber(f32.MIN_SAFE_INTEGER),a=r.fromNumber(f32.MAX_SAFE_INTEGER);t.g.i64_is_f32=function(e){return e.gte(i)&&e.lte(a)};const s=r.fromNumber(f64.MIN_SAFE_INTEGER),o=r.fromNumber(f64.MAX_SAFE_INTEGER);t.g.i64_is_f64=function(e){return e.gte(s)&&e.lte(o)},t.g.i64_to_f32=function(e){return t.g.Math.fround(e.toNumber())},t.g.i64_to_f64=function(e){return e.toNumber()},t.g.i64_to_string=function(e,n){return n?e.toUnsigned().toString():e.toString()}},352:(e,n,t)=>{var r="undefined"!=typeof window&&window||void 0!==t.g&&t.g||self;r.ASC_TARGET=0,r.ASC_NO_ASSERT=!1,r.ASC_MEMORY_BASE=0,r.ASC_OPTIMIZE_LEVEL=3,r.ASC_SHRINK_LEVEL=0,r.ASC_FEATURE_MUTABLE_GLOBAL=!1,r.ASC_FEATURE_SIGN_EXTENSION=!1,r.ASC_FEATURE_BULK_MEMORY=!1,r.ASC_FEATURE_SIMD=!1,r.ASC_FEATURE_THREADS=!1;var i=new Float64Array(1),a=new Uint32Array(i.buffer);function s(){Error.captureStackTrace?Error.captureStackTrace(this,s):this.stack=this.name+": "+this.message+"\n"+(new Error).stack}function o(e){this.message=e||"assertion failed",Error.captureStackTrace?Error.captureStackTrace(this,o):this.stack=this.name+": "+this.message+"\n"+(new Error).stack}function l(e,n){if(e===n){if(0!==e)return 0;e=1/e,n=1/n}else{var t=e!=e,r=n!=n;if(t|r)return t-r;null==e&&(e=String(e)),null==n&&(n=String(n))}return e>n?1:-1}Object.defineProperties(r.i8=function(e){return e<<24>>24},{MIN_VALUE:{value:-128,writable:!1},MAX_VALUE:{value:127,writable:!1}}),Object.defineProperties(r.i16=function(e){return e<<16>>16},{MIN_VALUE:{value:-32768,writable:!1},MAX_VALUE:{value:32767,writable:!1}}),Object.defineProperties(r.i32=r.isize=function(e){return 0|e},{MIN_VALUE:{value:-2147483648,writable:!1},MAX_VALUE:{value:2147483647,writable:!1}}),Object.defineProperties(r.u8=function(e){return 255&e},{MIN_VALUE:{value:0,writable:!1},MAX_VALUE:{value:255,writable:!1}}),Object.defineProperties(r.u16=function(e){return 65535&e},{MIN_VALUE:{value:0,writable:!1},MAX_VALUE:{value:65535,writable:!1}}),Object.defineProperties(r.u32=r.usize=function(e){return e>>>0},{MIN_VALUE:{value:0,writable:!1},MAX_VALUE:{value:4294967295,writable:!1}}),Object.defineProperties(r.bool=function(e){return!!e},{MIN_VALUE:{value:!1,writable:!1},MAX_VALUE:{value:!0,writable:!1}}),Object.defineProperties(r.f32=function(e){return Math.fround(e)},{EPSILON:{value:1.1920928955078125e-7,writable:!1},MIN_VALUE:{value:1401298464324817e-60,writable:!1},MAX_VALUE:{value:34028234663852886e22,writable:!1},MIN_NORMAL_VALUE:{value:11754943508222875e-54,writable:!1},MIN_SAFE_INTEGER:{value:-16777215,writable:!1},MAX_SAFE_INTEGER:{value:16777215,writable:!1},POSITIVE_INFINITY:{value:1/0,writable:!1},NEGATIVE_INFINITY:{value:-1/0,writable:!1},NaN:{value:NaN,writable:!1}}),Object.defineProperties(r.f64=function(e){return+e},{EPSILON:{value:2220446049250313e-31,writable:!1},MIN_VALUE:{value:5e-324,writable:!1},MAX_VALUE:{value:17976931348623157e292,writable:!1},MIN_NORMAL_VALUE:{value:22250738585072014e-324,writable:!1},MIN_SAFE_INTEGER:{value:-9007199254740991,writable:!1},MAX_SAFE_INTEGER:{value:9007199254740991,writable:!1},POSITIVE_INFINITY:{value:1/0,writable:!1},NEGATIVE_INFINITY:{value:-1/0,writable:!1},NaN:{value:NaN,writable:!1}}),r.clz=Math.clz32,r.ctz=function(e){var n=Math.clz32(e&-e);return e?31-n:n},r.popcnt=function(e){return 16843009*((e=(858993459&(e-=e>>>1&1431655765))+(e>>>2&858993459))+(e>>>4)&252645135)>>>24},r.rotl=function(e,n){return e<<(n&=31)|e>>>32-n},r.rotr=function(e,n){return e>>>(n&=31)|e<<32-n},r.abs=Math.abs,r.max=Math.max,r.min=Math.min,r.ceil=Math.ceil,r.floor=Math.floor,r.nearest=function(e){return.5===Math.abs(e-Math.trunc(e))?2*Math.round(.5*e):Math.round(e)},r.select=function(e,n,t){return t?e:n},r.sqrt=Math.sqrt,r.trunc=Math.trunc,r.copysign=function(e,n){return Math.abs(e)*Math.sign(n)},r.bswap=function(e){var n=e>>8&16711935,t=(16711935&e)<<8;return(n=(e=n|t)>>16&65535)|(t=(65535&e)<<16)},r.bswap16=function(e){return e<<8&65280|e>>8&255|4294901760&e},s.prototype=Object.create(Error.prototype),s.prototype.name="UnreachableError",s.prototype.message="unreachable",r.unreachable=function(){throw new s},o.prototype=Object.create(Error.prototype),o.prototype.name="AssertionError",r.assert=function(e,n){if(e)return e;throw new o(n)},r.changetype=function(e){return e},String.fromCharCodes=function(e){const n=8192,t=e.length;if(t<=n)return String.fromCharCode.apply(String,e);let r=0,i="";for(;r<t;)i+=String.fromCharCode.apply(String,e.slice(r,Math.min(r+n,t))),r+=n;return i},String.fromCodePoints=function(e){const n=8192,t=e.length;if(t<=n)return String.fromCodePoint.apply(String,e);let r=0,i="";for(;r<t;)i+=String.fromCodePoint.apply(String,e.slice(r,Math.min(r+n,t))),r+=n;return i},String.prototype.at||Object.defineProperty(String.prototype,"at",{value:function(e){return this.charAt(e>=0?e:e+this.length)},configurable:!0}),String.prototype.replaceAll||Object.defineProperty(String.prototype,"replaceAll",{value:function(e,n){var t=this.split(e).join(n);return e.length||(t=n+t+n),t},configurable:!0});const u=Array.prototype.sort;Array.prototype.sort=function(e){return u.call(this,e||l)},[Array,Uint8ClampedArray,Uint8Array,Int8Array,Uint16Array,Int16Array,Uint32Array,Int32Array,Float32Array,Float64Array].forEach((e=>{e.prototype.at||Object.defineProperty(e.prototype,"at",{value:function(e){return this[e>=0?e:e+this.length]},configurable:!0})})),r.isInteger=Number.isInteger,r.isFloat=function(e){return"number"==typeof e},r.isNullable=function(e){return!0},r.isReference=function(e){return"object"==typeof e||"string"==typeof e},r.isFunction=function(e){return"function"==typeof e},r.isString=function(e){return"string"==typeof e||e instanceof String},r.isArray=Array.isArray,r.isArrayLike=function(e){return e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&Math.trunc(e.length)===e.length},r.isDefined=function(e){return void 0!==e},r.isConstant=function(e){return!1},r.unchecked=function(e){return e},r.fmod=function(e,n){return e%n},r.fmodf=function(e,n){return Math.fround(e%n)},r.JSMath=Math,Object.defineProperties(r.JSMath,{sincos_sin:{value:0,writable:!0},sincos_cos:{value:0,writable:!0},signbit:{value:function(e){return i[0]=e,Boolean(a[1]>>>31)}},sincos:{value:function(e){this.sincos_sin=Math.sin(e),this.sincos_cos=Math.cos(e)}},exp2:{value:function(e){return Math.pow(2,e)}}}),r.unmanaged=function(){},r.trace=function(e,n){n&&(e+=Array.prototype.slice.call(arguments,2,2+n)),console.error("trace: "+e)},Object.defineProperty(Int8Array,"wrap",{value:function(e,n,t){return new Int8Array(e,n,t)}}),Object.defineProperty(Uint8Array,"wrap",{value:function(e,n,t){return new Uint8Array(e,n,t)}}),Object.defineProperty(Uint8ClampedArray,"wrap",{value:function(e,n,t){return new Uint8ClampedArray(e,n,t)}}),Object.defineProperty(Int16Array,"wrap",{value:function(e,n,t){return new Int16Array(e,n,t)}}),Object.defineProperty(Uint16Array,"wrap",{value:function(e,n,t){return new Uint16Array(e,n,t)}}),Object.defineProperty(Int32Array,"wrap",{value:function(e,n,t){return new Int32Array(e,n,t)}}),Object.defineProperty(Uint32Array,"wrap",{value:function(e,n,t){return new Uint32Array(e,n,t)}}),Object.defineProperty(Float32Array,"wrap",{value:function(e,n,t){return new Float32Array(e,n,t)}}),Object.defineProperty(Float64Array,"wrap",{value:function(e,n,t){return new Float64Array(e,n,t)}})},911:n=>{"use strict";n.exports=e}},t={};function r(e){if(t[e])return t[e].exports;var i=t[e]={exports:{}};return n[e].call(i.exports,i,i.exports,r),i.exports}return r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r(308),r(780)})()},e.exports=r(t(911))},388:(e,n)=>{var t,r=function(e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.instantiate=c,e.instantiateSync=p,e.instantiateStreaming=f,e.demangle=d,e.default=void 0;const n="undefined"!=typeof BigUint64Array,t=Symbol(),r=new TextDecoder("utf-16le");function i(e,n){const t=new Uint32Array(e)[n+-4>>>2]>>>1,i=new Uint16Array(e,n,t);return t<=32?String.fromCharCode.apply(String,i):r.decode(i)}function a(e){const n={};function t(e,n){return e?i(e.buffer,n):"<yet unknown>"}const r=e.env=e.env||{};return r.abort=r.abort||function(e,i,a,s){const o=n.memory||r.memory;throw Error(`abort: ${t(o,e)} at ${t(o,i)}:${a}:${s}`)},r.trace=r.trace||function(e,i,...a){const s=n.memory||r.memory;console.log(`trace: ${t(s,e)}${i?" ":""}${a.slice(0,i).join(", ")}`)},r.seed=r.seed||Date.now,e.Math=e.Math||Math,e.Date=e.Date||Date,n}const s=function(){throw Error("Operation requires compiling with --exportRuntime")};function o(e,t){const r=t.exports,a=r.memory,o=r.table,l=r.__new||s,u=r.__pin||s,c=r.__unpin||s,p=r.__collect||s,f=r.__rtti_base||-1;function h(e){const n=function(e){const n=new Uint32Array(a.buffer);if((e>>>=0)>=n[f>>>2])throw Error(`invalid id: ${e}`);return n[(f+4>>>2)+2*e]}(e);if(!(7&n))throw Error(`not an array: ${e}, flags=${n}`);return n}function g(e){const n=new Uint32Array(a.buffer);if((e>>>=0)>=n[f>>>2])throw Error(`invalid id: ${e}`);return n[(f+4>>>2)+2*e+1]}function x(e){return 31-Math.clz32(e>>>6&31)}function m(e,n,t){const r=a.buffer;if(t)switch(e){case 2:return new Float32Array(r);case 3:return new Float64Array(r)}else switch(e){case 0:return new(n?Int8Array:Uint8Array)(r);case 1:return new(n?Int16Array:Uint16Array)(r);case 2:return new(n?Int32Array:Uint32Array)(r);case 3:return new(n?BigInt64Array:BigUint64Array)(r)}throw Error(`unsupported align: ${e}`)}function _(e){const n=new Uint32Array(a.buffer),t=h(n[e+-8>>>2]),r=x(t);let i=4&t?e:n[e+4>>>2];const s=2&t?n[e+12>>>2]:n[i+-4>>>2]>>>r;return m(r,2048&t,4096&t).subarray(i>>>=r,i+s)}function y(e,n,t){return new e(E(e,n,t))}function E(e,n,t){const r=a.buffer,i=new Uint32Array(r),s=i[t+4>>>2];return new e(r,s,i[s+-4>>>2]>>>n)}function T(n,t,r){e[`__get${t}`]=y.bind(null,n,r),e[`__get${t}View`]=E.bind(null,n,r)}return e.__new=l,e.__pin=u,e.__unpin=c,e.__collect=p,e.__newString=function(e){if(null==e)return 0;const n=e.length,t=l(n<<1,1),r=new Uint16Array(a.buffer);for(var i=0,s=t>>>1;i<n;++i)r[s+i]=e.charCodeAt(i);return t},e.__getString=function(e){if(!e)return null;const n=a.buffer;if(1!==new Uint32Array(n)[e+-8>>>2])throw Error(`not a string: ${e}`);return i(n,e)},e.__newArray=function(e,n){const t=h(e),r=x(t),i=n.length,s=l(i<<r,4&t?e:0);let o;if(4&t)o=s;else{u(s);const n=l(2&t?16:12,e);c(s);const p=new Uint32Array(a.buffer);p[n+0>>>2]=s,p[n+4>>>2]=s,p[n+8>>>2]=i<<r,2&t&&(p[n+12>>>2]=i),o=n}const p=m(r,2048&t,4096&t);if(16384&t)for(let e=0;e<i;++e){const t=n[e];p[(s>>>r)+e]=t}else p.set(n,s>>>r);return o},e.__getArrayView=_,e.__getArray=function(e){const n=_(e),t=n.length,r=new Array(t);for(let e=0;e<t;e++)r[e]=n[e];return r},e.__getArrayBuffer=function(e){const n=a.buffer,t=new Uint32Array(n)[e+-4>>>2];return n.slice(e,e+t)},[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array].forEach((e=>{T(e,e.name,31-Math.clz32(e.BYTES_PER_ELEMENT))})),n&&[BigUint64Array,BigInt64Array].forEach((e=>{T(e,e.name.slice(3),3)})),e.__instanceof=function(e,n){const t=new Uint32Array(a.buffer);let r=t[e+-8>>>2];if(r<=t[f>>>2])do{if(r==n)return!0;r=g(r)}while(r);return!1},e.memory=e.memory||a,e.table=e.table||o,d(r,e)}function l(e){return"undefined"!=typeof Response&&e instanceof Response}function u(e){return e instanceof WebAssembly.Module}async function c(e,n={}){if(l(e=await e))return f(e,n);const t=u(e)?e:await WebAssembly.compile(e),r=a(n),i=await WebAssembly.instantiate(t,n);return{module:t,instance:i,exports:o(r,i)}}function p(e,n={}){const t=u(e)?e:new WebAssembly.Module(e),r=a(n),i=new WebAssembly.Instance(t,n);return{module:t,instance:i,exports:o(r,i)}}async function f(e,n={}){if(!WebAssembly.instantiateStreaming)return c(l(e=await e)?e.arrayBuffer():e,n);const t=a(n),r=await WebAssembly.instantiateStreaming(e,n),i=o(t,r.instance);return{...r,exports:i}}function d(e,n={}){const r=e.__argumentsLength?n=>{e.__argumentsLength.value=n}:e.__setArgumentsLength||e.__setargc||(()=>{});for(let i in e){if(!Object.prototype.hasOwnProperty.call(e,i))continue;const a=e[i];let s=i.split("."),o=n;for(;s.length>1;){let e=s.shift();Object.prototype.hasOwnProperty.call(o,e)||(o[e]={}),o=o[e]}let l=s[0],u=l.indexOf("#");if(u>=0){const n=l.substring(0,u),s=o[n];if(void 0===s||!s.prototype){const e=function(...n){return e.wrap(e.prototype.constructor(0,...n))};e.prototype={valueOf(){return this[t]}},e.wrap=function(n){return Object.create(e.prototype,{[t]:{value:n,writable:!1}})},s&&Object.getOwnPropertyNames(s).forEach((n=>Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(s,n)))),o[n]=e}if(l=l.substring(u+1),o=o[n].prototype,/^(get|set):/.test(l)){if(!Object.prototype.hasOwnProperty.call(o,l=l.substring(4))){let n=e[i.replace("set:","get:")],r=e[i.replace("get:","set:")];Object.defineProperty(o,l,{get(){return n(this[t])},set(e){r(this[t],e)},enumerable:!0})}}else"constructor"===l?(o[l]=(...e)=>(r(e.length),a(...e))).original=a:(o[l]=function(...e){return r(e.length),a(this[t],...e)}).original=a}else/^(get|set):/.test(l)?Object.prototype.hasOwnProperty.call(o,l=l.substring(4))||Object.defineProperty(o,l,{get:e[i.replace("set:","get:")],set:e[i.replace("get:","set:")],enumerable:!0}):"function"==typeof a&&a!==r?(o[l]=(...e)=>(r(e.length),a(...e))).original=a:o[l]=a}return n}var h={instantiate:c,instantiateSync:p,instantiateStreaming:f,demangle:d};return e.default=h,e}({});void 0===(t=function(){return r}.apply(n,[]))||(e.exports=t)},259:(e,n)=>{var t,r=function(e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.Rtrace=e.TOTAL_OVERHEAD=e.OBJECT_OVERHEAD=e.BLOCK_OVERHEAD=void 0;const n=Uint32Array;e.BLOCK_OVERHEAD=4;e.OBJECT_OVERHEAD=16;function t(e){if(!e)throw Error("assertion failed");return e}function r(e,n){return e.split(/\r?\n/).slice(1+n)}e.TOTAL_OVERHEAD=20,Error.stackTraceLimit=15;const i="undefined"!=typeof performance&&performance.now?performance.now:"undefined"!=typeof process&&process.hrtime?()=>{let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:Date.now,a=["","FREE","LEFTFREE","FREE+LEFTFREE"],s=["BLACK/WHITE","WHITE/BLACK","GRAY","INVALID"];class o{constructor(e){this.options=e||{},this.onerror=this.options.onerror||function(){},this.oninfo=this.options.oninfo||function(){},this.oncollect_=this.options.oncollect||function(){},this.memory=null,this.shadow=null,this.shadowStart=4294967296,this.blocks=new Map,this.allocSites=new Map,this.freedBlocks=new Map,this.gcProfileStart=0,this.gcProfile=[],this.allocCount=0,this.resizeCount=0,this.moveCount=0,this.freeCount=0,this.heapBase=4294967296}install(e){return e||(e={}),e.rtrace=Object.assign(e.rtrace||{},{oninit:this.oninit.bind(this),onalloc:this.onalloc.bind(this),onresize:this.onresize.bind(this),onmove:this.onmove.bind(this),onvisit:this.onvisit.bind(this),onfree:this.onfree.bind(this),oninterrupt:this.oninterrupt.bind(this),onyield:this.onyield.bind(this),oncollect:this.oncollect.bind(this),onstore:this.onstore.bind(this),onload:this.onload.bind(this)}),e}syncShadow(){if(this.memory){var e=this.memory.buffer.byteLength-this.shadow.buffer.byteLength;e>0&&this.shadow.grow(e>>>16)}else this.memory=t(this.options.getMemory()),this.shadow=new WebAssembly.Memory({initial:(this.memory.buffer.byteLength+65535&-65536)>>>16})}markShadow(e,r=0){t(this.shadow&&this.shadow.byteLength==this.memory.byteLength),t(0==(3&e.size)),e.ptr<this.shadowStart&&(this.shadowStart=e.ptr);var i=e.size>>>2,a=new n(this.shadow.buffer,e.ptr,i),s=!1,o=r>>>2;for(let n=0;n<o;++n)a[n]==e.ptr||s||(this.onerror(Error("shadow region mismatch: "+a[n]+" != "+e.ptr),e),s=!0);s=!1;for(let n=o;n<i;++n)0==a[n]||s||(this.onerror(Error("shadow region already in use: "+a[n]+" != 0"),e),s=!0),a[n]=e.ptr}unmarkShadow(e,r=e.size){t(this.shadow&&this.shadow.byteLength==this.memory.byteLength);var i=r>>>2,a=new n(this.shadow.buffer,e.ptr,i),s=!1,o=0;r!=e.size&&(t(r>e.size),o=e.size>>>2);for(let n=0;n<i;++n)a[n]==e.ptr||s||(this.onerror(Error("shadow region mismatch: "+a[n]+" != "+e.ptr),e),s=!0),n>=o&&(a[n]=0)}accessShadow(e,n,t,i){if((this.syncShadow(),!(e<this.shadowStart))&&(0==new Uint32Array(this.shadow.buffer,-4&e,1)[0]&&!i)){let i=r((new Error).stack,2);this.onerror(new Error("OOB "+(t?"load":"store")+8*n+" at address "+e+"\n"+i.join("\n")))}}getBlockInfo(e){const[n,t,r,i,o]=new Uint32Array(this.memory.buffer,e,5),l=-4&n;return{ptr:e,size:4+l,mmInfo:{tags:a[3&n],size:l},gcInfo:{color:s[3&t],next:-4&t,prev:r},rtId:i,rtSize:o}}get active(){return Boolean(this.allocCount||this.resizeCount||this.moveCount||this.freeCount)}check(){if(this.oninfo)for(let[e,n]of this.blocks)this.oninfo("LIVE "+e+"\n"+n.allocStack.join("\n"));return this.blocks.size}oninit(e){this.heapBase=e,this.gcProfileStart=0,this.gcProfile.length=0,this.oninfo("INIT heapBase="+e)}onalloc(e){this.syncShadow(),++this.allocCount;var n=this.getBlockInfo(e);if(this.blocks.has(e))this.onerror(Error("duplicate alloc: "+e),n);else{this.oninfo("ALLOC "+e+".."+(e+n.size)),this.markShadow(n);let t=r((new Error).stack,1);this.blocks.set(e,Object.assign(n,{allocStack:t}))}}onresize(e,n){this.syncShadow(),++this.resizeCount;const t=this.getBlockInfo(e);if(this.blocks.has(e)){const r=this.blocks.get(e);r.size!=n&&this.onerror(Error(`size mismatch upon resize: ${e} (${r.size} != ${n})`),t);const i=t.size;this.oninfo("RESIZE "+e+".."+(e+i)+" ("+n+"->"+i+")"),this.blocks.set(e,Object.assign(t,{allocStack:r.allocStack})),i>n?this.markShadow(t,n):i<n&&this.unmarkShadow(t,n)}else this.onerror(Error("orphaned resize: "+e),t)}onmove(e,n){this.syncShadow(),++this.moveCount;var t=this.getBlockInfo(e),r=this.getBlockInfo(n);if(this.blocks.has(e))if(this.blocks.has(n)){const i=this.blocks.get(e),a=t.size,s=r.size;i.size!=a&&this.onerror(Error(`size mismatch upon move: ${e} (${i.size} != ${a})`),t),this.oninfo("MOVE "+e+".."+(e+a)+" -> "+n+".."+(n+s))}else this.onerror(Error("orphaned move (new): "+n),r);else this.onerror(Error("orphaned move (old): "+e),t)}onvisit(e){if(e>this.heapBase&&!this.blocks.has(e)){let n=Error("orphaned visit: "+e),t=this.freedBlocks.get(e);return t&&(n.stack+="\n^ allocated at:\n"+t.allocStack.join("\n"),n.stack+="\n^ freed at:\n"+t.freeStack.join("\n")),this.onerror(n,null),!1}return!0}onfree(e){this.syncShadow(),++this.freeCount;var n=this.getBlockInfo(e);if(this.blocks.has(e)){const t=this.blocks.get(e);n.size!=t.size&&this.onerror(Error(`size mismatch upon free: ${e} (${t.size} != ${n.size})`),n),this.oninfo("FREE "+e+".."+(e+n.size)),this.unmarkShadow(n);const i=this.blocks.get(e);this.blocks.delete(e);const a=i.allocStack,s=r((new Error).stack,1);this.freedBlocks.set(e,{allocStack:a,freeStack:s})}else this.onerror(Error("orphaned free: "+e),n)}oncollect(e){this.oninfo(`COLLECT at ${e}`),this.plot(e),this.oncollect_()}plot(e,n=0){this.gcProfileStart||(this.gcProfileStart=Date.now()),this.gcProfile.push([Date.now()-this.gcProfileStart,e,n])}oninterrupt(e){this.interruptStart=i(),this.plot(e)}onyield(e){var n=i()-this.interruptStart;n>=1&&console.log("interrupted for "+n.toFixed(1)+"ms"),this.plot(e,n)}onstore(e,n,t,r){return this.accessShadow(e+n,t,!1,r),e}onload(e,n,t,r){return this.accessShadow(e+n,t,!0,r),e}}e.Rtrace=o;var l={Rtrace:o};return e.default=l,e}({});void 0===(t=function(){return r}.apply(n,[]))||(e.exports=t)},911:n=>{"use strict";n.exports=e}},t={};function r(e){if(t[e])return t[e].exports;var i=t[e]={exports:{}};return n[e].call(i.exports,i,i.exports,r),i.exports}return r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r(469)})()}));
//# sourceMappingURL=asc.js.map